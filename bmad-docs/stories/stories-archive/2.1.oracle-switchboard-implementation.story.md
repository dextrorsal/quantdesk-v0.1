# 2.1 Oracle Switchboard Implementation

## Story Details
**Status:** Draft  
**Priority:** Critical  
**Department:** Backend  
**Supporting Departments:** Smart Contracts, Database, Caching  
**Complexity:** 
- Technical: High
- Integration: Medium
- Risk: Medium

## User Story
**As a:** QuantDesk trader
**I want:** Reliable, fast oracle price feeds with Pyth-first architecture
**So that:** My market orders execute with accurate pricing and minimal slippage

## Acceptance Criteria

### Functional Criteria
- [ ] Pyth Hermes WebSocket connection provides real-time price feeds
- [ ] In-memory cache layer reduces price fetch latency to < 200ms
- [ ] Price staleness monitoring alerts when data is > 60 seconds old
- [ ] CoinGecko fallback is completely removed from primary price path
- [ ] Database fallback works when Pyth and cache are unavailable

### Integration Requirements
- **Backend:** Enhanced `pythOracleService.ts` with cache-first architecture
- **Database:** Oracle prices stored in `oracle_prices` table with proper indexing
- **Caching:** In-memory price cache with configurable TTL and invalidation
- **Smart Contracts:** Manual Pyth deserialization for on-chain price validation

### Cross-Department Dependencies
- **Dependency 1:** Pyth Network Hermes API access (Dep: Backend)
- **Dependency 2:** Supabase database schema for oracle_prices table (Dep: Database)
- **Dependency 3:** Smart contract Pyth SDK dependency resolution (Dep: Smart Contracts)

## Technical Context
### Current Architecture
The current oracle system uses CoinGecko as primary source with database fallback. The `pythOracleService.ts` has WebSocket connection to Pyth but falls back to CoinGecko when Pyth fails. This creates price gaps and inconsistent data sources that cause market order failures.

### Department-Specific Context

#### Backend Context
- **Services:** `pythOracleService.ts`, `matching.ts`, `orders.ts`
- **Database Tables:** `oracle_prices`, `markets`
- **Cache Strategy:** In-memory Map with TTL, Redis for persistence

#### Smart Contracts Context
- **Program Functions:** Manual Pyth deserialization using `load_price_feed_from_account_info`
- **Account Types:** Pyth price feed accounts for BTC, ETH, SOL
- **Oracle Data:** Price, confidence, publishTime, staleness validation

#### Database Context
- **Tables:** `oracle_prices` (market_id, price, confidence, publish_time, created_at)
- **Indexes:** `idx_oracle_prices_market_time` for efficient price lookups
- **Queries:** Fluent API queries replacing `execute_sql` calls

#### Caching Context
- **Cache Keys:** `price:{market_symbol}` format
- **TTL Strategy:** 30 seconds for active feeds, 5 minutes for stale data
- **Invalidation:** Time-based expiration with manual refresh triggers

#### Oracle Context
- **Price Feeds:** BTC-PERP, ETH-PERP, SOL-PERP via Pyth Hermes
- **Update Frequency:** Real-time via WebSocket, 30s REST fallback
- **Fallback Strategy:** Cache → Pyth Hermes → Database → Error

## Implementation Details
### Development Tasks

#### Backend Tasks (8h)
1. Implement in-memory price cache with Map and TTL management
2. Modify `pythOracleService.getLatestPrice()` to use cache-first architecture
3. Add price staleness monitoring with configurable thresholds
4. Remove CoinGecko fallback from primary price path
5. Add structured logging for price source, staleness, and performance metrics
6. Implement cache warming on service startup
7. Add health check endpoint for oracle service status
8. Create unit tests for cache hit/miss scenarios and staleness detection

#### Smart Contract Tasks (4h)
1. Resolve Pyth SDK dependency conflicts in `Cargo.toml`
2. Implement manual Pyth deserialization using `load_price_feed_from_account_info`
3. Add price staleness and confidence validation in smart contracts
4. Create integration test reading real devnet Pyth feed
5. Update oracle.rs with proper error handling and validation

#### Database Tasks (2h)
1. Verify `oracle_prices` table schema and indexes
2. Update all database queries to use Supabase fluent APIs
3. Add performance monitoring for slow queries (>1000ms)
4. Create database migration scripts if schema changes needed

### Integration Sequence
1. **Phase 1:** Backend cache implementation and Pyth-first logic (Backend)
2. **Phase 2:** Smart contract Pyth integration and dependency resolution (Smart Contracts)
3. **Phase 3:** Database query optimization and performance monitoring (Database)

## Testing Strategy
### Backend Testing
- **Unit Tests:** Cache hit/miss, staleness detection, price source fallback
- **API Tests:** Oracle service health check, price fetch performance
- **Integration Tests:** End-to-end price flow from Pyth to frontend

### Smart Contract Testing
- **Unit Tests:** Manual Pyth deserialization, price validation logic
- **Integration Tests:** Real devnet Pyth feed reading and validation
- **Security Tests:** Price manipulation protection, confidence thresholds

### Cross-Department Testing
- **Contract:** Epic 1 test script validation with new oracle system
- **Data Flow:** Price consistency from Pyth → Backend → Frontend
- **Performance:** Price fetch latency < 200ms, staleness < 60s

## Quality Gates
### Key Performance Indicators
- **Response Time:** P50 < 200ms for price fetches
- **Throughput:** Handle 1000+ concurrent price requests
- **Error Rate:** < 0.1% price fetch failures

### Security Requirements
- **Authentication:** Service-to-service authentication for Pyth API
- **Data Protection:** Price data validation and confidence checks
- **Audit Trail:** Log all price source changes and staleness events

## Risks and Mitigations
### Technical Risks
- **Risk 1:** Pyth Network outage causing price unavailability - *Mitigation:* Cache + database fallback with staleness alerts
- **Risk 2:** Cache memory usage growing too large - *Mitigation:* TTL expiration and size limits

### Integration Risks  
- **Risk 1:** Smart contract Pyth SDK conflicts blocking compilation - *Mitigation:* Manual deserialization approach
- **Risk 2:** Database query performance degradation - *Mitigation:* Index optimization and query monitoring

## Rollout Strategy
### Deployment Phases
1. **Phase 1:** Backend cache implementation (Day 1-2)
2. **Phase 2:** Smart contract Pyth integration (Day 3-4)
3. **Phase 3:** Database optimization and monitoring (Day 5)

### Rollback Plan
- **Trigger:** Epic 1 test script failures or price staleness > 5 minutes
- **Procedure:** Revert to CoinGecko fallback, disable cache, restart services
- **Verification:** Epic 1 test script passes, price staleness < 60s

## Success Metrics
- **User Metrics:** Market orders execute successfully 99.9% of the time
- **Technical Metrics:** Price staleness < 60s, fetch latency < 200ms
- **Business Metrics:** Zero "Price unavailable" errors in Epic 1 test script

## Dev Notes

### Previous Story Insights
Epic 1 completed successfully with basic order placement, position management, and P&L calculation working on devnet. The main issue identified is unreliable oracle pricing causing market order failures.

### Data Models
- **Oracle Price Schema:** `{ market_id: string, price: number, confidence: number, publish_time: number, created_at: timestamp }` [Source: oracle-integration-architecture.md#database-context]
- **Cache Entry Schema:** `{ price: number, confidence: number, publish_time: number, cached_at: timestamp, ttl: number }` [Source: oracle-integration-architecture.md#caching-context]

### API Specifications
- **Price Fetch Endpoint:** `GET /api/oracle/price/{symbol}` returns `{ price: number, confidence: number, staleness: number, source: string }` [Source: oracle-integration-architecture.md#backend-context]
- **Health Check Endpoint:** `GET /api/oracle/health` returns service status and cache statistics [Source: oracle-integration-architecture.md#backend-context]

### File Locations
- **Primary Service:** `backend/src/services/pythOracleService.ts` - Main oracle service with cache implementation [Source: oracle-integration-architecture.md#backend-context]
- **Smart Contract:** `contracts/programs/quantdesk-perp-dex/src/oracle.rs` - Manual Pyth deserialization [Source: oracle-integration-architecture.md#smart-contracts-context]
- **Database Schema:** `database/schema.sql` - Oracle prices table definition [Source: oracle-integration-architecture.md#database-context]

### Testing Requirements
- **Unit Tests:** Cache hit/miss scenarios, staleness detection, price source fallback logic [Source: oracle-integration-architecture.md#testing-strategy]
- **Integration Tests:** End-to-end price flow validation, Epic 1 test script compatibility [Source: oracle-integration-architecture.md#testing-strategy]
- **Performance Tests:** Price fetch latency < 200ms, staleness monitoring < 60s [Source: oracle-integration-architecture.md#quality-gates]

### Technical Constraints
- **Pyth SDK Version:** Must resolve Borsh serialization conflicts with Anchor framework [Source: oracle-integration-architecture.md#smart-contracts-context]
- **Cache Memory:** In-memory cache with size limits and TTL expiration [Source: oracle-integration-architecture.md#caching-context]
- **Database Performance:** All queries must use Supabase fluent APIs, no `execute_sql` calls [Source: oracle-integration-architecture.md#database-context]

---
**Story Created:** $(date)
**Last Updated:** $(date)
**Review Required:** ✅ REVIEWED - Ready for Development
---

*This story implements the Oracle Switchboard as the foundation for Epic 2, ensuring reliable price feeds for production trading operations.*
