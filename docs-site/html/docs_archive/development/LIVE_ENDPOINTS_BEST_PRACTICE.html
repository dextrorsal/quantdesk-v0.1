<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Endpoints Best Practice - QuantDesk Documentation</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <style>
        body {
            font-family: 'JetBrains Mono', 'Monaco', 'Consolas', monospace;
            line-height: 1.6;
            color: #ffffff;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #000000;
            font-size: 14px;
        }
        .container {
            background: #000000;
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #333333;
        }
        .back-link {
            margin-bottom: 20px;
        }
        .back-link a {
            color: #3b82f6;
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s ease;
        }
        .back-link a:hover {
            color: #60a5fa;
            text-decoration: underline;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #ffffff;
            margin-top: 30px;
            margin-bottom: 15px;
            font-weight: 600;
        }
        h1 {
            border-bottom: 2px solid #333333;
            padding-bottom: 10px;
        }
        h2 {
            border-bottom: 1px solid #333333;
            padding-bottom: 8px;
        }
        code {
            background: #1a1a1a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'JetBrains Mono', 'Monaco', 'Consolas', monospace;
            color: #ffffff;
            border: 1px solid #333333;
        }
        pre {
            background: #0a0a0a;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid #333333;
            margin: 20px 0;
        }
        pre code {
            background: none;
            padding: 0;
            color: #ffffff;
            border: none;
        }
        blockquote {
            border-left: 4px solid #3b82f6;
            margin: 0;
            padding-left: 20px;
            color: #d9d9d9;
            background: #1a1a1a;
            padding: 15px 20px;
            border-radius: 0 8px 8px 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            border: 1px solid #333333;
        }
        th, td {
            border: 1px solid #333333;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #1a1a1a;
            font-weight: bold;
            color: #ffffff;
        }
        td {
            color: #d9d9d9;
        }
        ul, ol {
            color: #d9d9d9;
        }
        li {
            margin-bottom: 8px;
        }
        a {
            color: #3b82f6;
            text-decoration: none;
        }
        a:hover {
            color: #60a5fa;
            text-decoration: underline;
        }
        /* Syntax Highlighting Overrides */
        pre[class*="language-"] {
            background: #0a0a0a !important;
            border: 1px solid #333333 !important;
            border-radius: 8px !important;
            padding: 20px !important;
            margin: 20px 0 !important;
            font-family: 'JetBrains Mono', 'Monaco', 'Consolas', monospace !important;
            font-size: 13px !important;
            line-height: 1.5 !important;
        }
        .token.comment { color: #6a9955 !important; }
        .token.keyword { color: #569cd6 !important; }
        .token.string { color: #ce9178 !important; }
        .token.number { color: #b5cea8 !important; }
        .token.function { color: #dcdcaa !important; }
        .token.class-name { color: #4ec9b0 !important; }
        .token.operator { color: #d4d4d4 !important; }
        .token.punctuation { color: #d4d4d4 !important; }
        .token.variable { color: #9cdcfe !important; }
        .token.constant { color: #4fc1ff !important; }
    </style>
</head>
<body>
    <div class="container">
        <div class="back-link">
            <a href="/">&larr; Back to Documentation</a>
        </div>
        <h2>QuantDesk Live Endpoints and Frontend Integration Best Practices</h2>
<p>This guide documents the recommended, production-ready way to expose live market data from the backend and consume it from the frontend (Modern Trading tab). It consolidates what exists today with standard perp DEX practices (Drift/Flash/Hyperliquid style) and MCP-backed guidance.</p>
<h3>Core Objectives</h3>
<ul>
<li>Low-latency, resilient price and depth streams with graceful fallbacks.</li>
<li>Canonical market naming and symbol normalization.</li>
<li>Security (auth, rate limiting) and cache design (Redis) that scales.</li>
<li>Predictable message/REST schemas that are future-proof.</li>
</ul>
<hr />
<h2>1) Backend: Canonical Routes (what exists today)</h2>
<ul>
<li>GET <code>/api/markets</code></li>
<li>Returns active markets with latest oracle price.</li>
<li>GET <code>/api/markets/:symbol/price</code></li>
<li>Returns latest Pyth price for a given symbol.</li>
<li>GET <code>/api/markets/:symbol/orderbook</code></li>
<li>Returns top-of-book (bids/asks) aggregated from pending orders in Postgres.</li>
<li>WebSocket (internal service)</li>
<li>Broadcasts snapshots (order book, trades) at ~1s cadence.</li>
</ul>
<p>Symbols: Prefer canonical perp names <code>BASE-PERP</code> (e.g., <code>SOL-PERP</code>). Accept aliases (<code>SOL</code>, <code>SOL/USDT</code>) and normalize server-side.</p>
<hr />
<h2>2) Price Best Practices (Pyth)</h2>
<ul>
<li>Always expose (and consume) price with confidence. Include: <code>{ price, confidence, slot, ts }</code>.</li>
<li>Volatility handling (Flash Trade pattern):</li>
<li>Compare reported price to EMA; if |price-ema| exceeds threshold → set High Volatility flag.</li>
<li>If confidence/price &gt; 1% (wide CI), switch UI to Close-Only cues and widen spreads.</li>
<li>Frontend consumption order:
  1) WebSocket price stream (if connected)
  2) REST polling fallback: <code>GET /api/markets/:symbol/price</code> (2–5s)
  3) Last cached value from Redis (stale-while-revalidate; mark UI as “delayed” when &gt;3s old)</li>
</ul>
<hr />
<h2>3) Order Book Best Practices</h2>
<ul>
<li>REST: <code>GET /api/markets/:symbol/orderbook</code> returns
  <code>json
  {
    "success": true,
    "orderbook": {
      "symbol": "SOL-PERP",
      "bids": [[price, size], ...],
      "asks": [[price, size], ...],
      "spread": number,
      "timestamp": number
    }
  }</code></li>
<li>WS: Mirror the same shape inside a compact envelope (see §6).</li>
<li>Depth size: top 20 levels per side by default; support <code>?levels=n</code> (&lt;=100) with sane rate limits.</li>
<li>Heatmap/UI: scale bar width to max(size) in current viewport; clamp extremes.</li>
<li>Latency: target 1s cadence; WS preferred, REST polling fallback 1–2s with jitter.</li>
</ul>
<hr />
<h2>4) Caching and Redis</h2>
<ul>
<li>Keys (namespace): <code>qd:{ENV}:price:{SYMBOL}</code> and <code>qd:{ENV}:orderbook:{SYMBOL}</code>.</li>
<li>TTL: 1–3s for price/orderbook snapshots; update on each tick.</li>
<li>Pub/Sub channels: <code>qd:{ENV}:price</code> and <code>qd:{ENV}:orderbook</code> for broadcasting cache updates to WS layer.</li>
<li>Health: <code>/health/redis</code> endpoint; on cache miss, hit source and repopulate.</li>
</ul>
<hr />
<h2>5) WebSocket Message Envelope (forward-compatible)</h2>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;v&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;orderbook|price|trades&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;symbol&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SOL-PERP&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;ts&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1730930000000</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;data&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* shape matches REST payload for that resource */</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>Include <code>v</code> for versioning.</li>
<li>For price: <code>data = { price, confidence, slot }</code>.</li>
<li>For orderbook: <code>data = { bids, asks, spread }</code> (arrays of <code>[price,size]</code>).</li>
<li>Consider gzip/deflate if payload growth becomes an issue.</li>
</ul>
<hr />
<h2>6) Frontend Consumption Pattern (Modern Trading Tab)</h2>
<ul>
<li>Symbol routing: <code>/trading/:symbol</code> → normalize to <code>BASE-PERP</code> internally; store canonical in context.</li>
<li>Price source: PriceContext</li>
<li>Primary: WS stream (optional mode; no-console-error on failure),</li>
<li>Fallback: <code>GET /api/markets/:symbol/price</code> (2–5s),</li>
<li>Show volatility flag and widen displayed spread if <code>confidence/price &gt; 1%</code>.</li>
<li>Order book source: DepthService (new)</li>
<li>Poll <code>GET /api/markets/:symbol/orderbook</code> every 1s with jitter and SWR cache (keep last snapshot for smooth UI).</li>
<li>When WS is stable, switch to WS updates and reduce REST frequency.</li>
<li>Resilience:</li>
<li>Backoff with jitter; stop after N attempts; show “disconnected” UI badge.</li>
<li>Treat snapshots older than 3s as stale (badge + dim heatmap).</li>
</ul>
<hr />
<h2>7) Security and Rate Limiting</h2>
<ul>
<li>Public routes (<code>/api/markets</code>, <code>/api/markets/:symbol/price</code>, <code>/api/markets/:symbol/orderbook</code>) → public rate limiter; 429 + <code>Retry-After</code>.</li>
<li>Authed routes (<code>/api/orders</code>, <code>/api/positions</code>, etc.) → SIWS session cookie; never trust wallet address from client without server verification.</li>
<li>Input validation: whitelist <code>:symbol</code> to known markets; reject unknowns.</li>
<li>CORS: allow local dev origins; restrict in production.</li>
</ul>
<hr />
<h2>8) Naming and Normalization</h2>
<ul>
<li>Canonical: <code>BASE-PERP</code> uppercase (e.g., <code>SOL-PERP</code>).</li>
<li>Accept: <code>SOL</code>, <code>SOL/USDT</code>, <code>SOLUSDT</code> and map to canonical internally.</li>
<li>Include <code>marketId</code> in responses for stable joins; UI stores both <code>symbol</code> and <code>marketId</code>.</li>
</ul>
<hr />
<h2>9) Monitoring and Metrics</h2>
<ul>
<li>Log: endpoint latencies, Redis hit ratio, WS deliver success/fail, reconnect counts.</li>
<li>Alert on: price staleness (&gt;5s), orderbook staleness (&gt;3s), WS disconnect loops, Redis error rate.</li>
</ul>
<hr />
<h2>10) Implementation Checklist</h2>
<ul>
<li>[ ] Frontend DepthService: poll <code>/api/markets/:symbol/orderbook</code> + SWR cache.</li>
<li>[ ] PriceContext: expose <code>{ price, confidence, ts }</code>, with WS optional mode.</li>
<li>[ ] Symbol utils: normalize to <code>BASE-PERP</code>; map aliases.</li>
<li>[ ] Redis cache + Pub/Sub wired in backend services.</li>
<li>[ ] WS envelope v1; fallback REST parity.</li>
<li>[ ] Volatility flag + UI badges based on confidence/EMA.</li>
</ul>
<hr />
<h2>References (MCP-backed)</h2>
<ul>
<li>Drift v2 WS orderbook structure and cadence.</li>
<li>Flash Trade pricing engine (volatility/confidence handling, close-only rules).</li>
<li>Helius Yellowstone gRPC resilience patterns (ping/pong, reconnect).</li>
</ul>
    </div>
</body>
</html>