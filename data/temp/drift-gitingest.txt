(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div align="center">
  <img height="120x" src="https://uploads-ssl.webflow.com/611580035ad59b20437eb024/616f97a42f5637c4517d0193_Logo%20(1)%20(1).png" />

  <h1 style="margin-top:20px;">Drift Protocol v2</h1>

  <p>
    <a href="https://drift-labs.github.io/v2-teacher/"><img alt="Docs" src="https://img.shields.io/badge/docs-tutorials-blueviolet" /></a>
    <a href="https://discord.com/channels/849494028176588802/878700556904980500"><img alt="Discord Chat" src="https://img.shields.io/discord/889577356681945098?color=blueviolet" /></a>
    <a href="https://opensource.org/licenses/Apache-2.0"><img alt="License" src="https://img.shields.io/github/license/project-serum/anchor?color=blueviolet" /></a>
  </p>
</div>

# Drift Protocol v2

This repository provides open source access to Drift V2's Typescript SDK, Solana Programs, and more.

Integrating Drift? [Go here](./sdk/README.md)

# SDK Guide

SDK docs can be found [here](./sdk/README.md)

# Example Bot Implementations

Example bots (makers, liquidators, fillers, etc) can be found [here](https://github.com/drift-labs/keeper-bots-v2)

# Building Locally

Note: If you are running the build on an Apple computer with an M1 chip, please set the default rust toolchain to `stable-x86_64-apple-darwin`

```bash
rustup default stable-x86_64-apple-darwin
```

## Compiling Programs

```bash
# build v2
anchor build
# install packages
yarn
# build sdk
cd sdk/ && yarn && yarn build && cd ..
```

## Running Rust Test

```bash
cargo test
```

## Running Javascript Tests

```bash
bash test-scripts/run-anchor-tests.sh
```

# Development (with devcontainer)

We've provided a devcontainer `Dockerfile` to help you spin up a dev environment with the correct versions of Rust, Solana, and Anchor for program development.

Build the container and tag it `drift-dev`:
```
cd .devcontainer && docker build -t drift-dev .
```

Open a shell to the container:
```
# Find the container ID first
docker ps

# Then exec into it
docker exec -it <CONTAINER_ID> /bin/bash
```

Alternatively use an extension provided by your IDE to make use of the dev container. For example on vscode/cursor:

```
1. Press Ctrl+Shift+P (or Cmd+Shift+P on Mac)
2. Type "Dev Containers: Reopen in Container"
3. Select it and wait for the container to build
4. The IDE terminal should be targeting the dev container now
```

Use the dev container as you would a local build environment:
```
# build program
anchor build

# update idl
anchor build -- --features anchor-test && cp target/idl/drift.json sdk/src/idl/drift.json

# run cargo tests
cargo test

# run typescript tests
bash test-scripts/run-anchor-tests.sh
```

# Bug Bounty

Information about the Bug Bounty can be found [here](./bug-bounty/README.md)



================================================
FILE: Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[workspace]
exclude = ["programs/openbook_v2"]

[scripts]
# to run local validator tests, use "./test-scripts/run-ts-mocha" in "test"
test = "echo" # need to call anchor test to update metadata field in idl before running tests, so just do a noop
lint = "yarn prettify:fix && cargo fmt"
fulltest = 'cargo test && bash ./test-scripts/run-anchor-tests.sh'
watch_ts = 'find ./programs/clearing_house/src/* ./tests ./sdk/src | entr -c bash ./test-scripts/single-anchor-test.sh'
watch_build = 'find ./programs/clearing_house/src/* ./tests ./sdk/src | entr -c anchor build'
watch_cargo = 'find ./programs/clearing_house/src/* ./tests ./sdk/src | entr -c cargo test -- --show-output'

[programs.localnet]
drift = "dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH"
pyth = "FsJ3A3u2vn5cTVofAjvy6y5kwABJAqYWpe4975bi2epH"
token_faucet = "V4v1mQiAdLz4qwckEb45WqHYceYizoib39cDBHSWfaB"

[[test.validator.account]]
address = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
filename = "./deps/configs/usdc.json"

[[test.validator.account]]
address = "3rdJbqfnagQ4yx9HXJViD4zc4xpiSqmFsKpPuSCQVyQL"
filename = "./deps/configs/pyth_lazer_storage.json"


================================================
FILE: AUDIT.md
================================================
- [Neodyme Audit (Protocol V2)](https://github.com/drift-labs/audits/blob/master/protocol-v2/neodyme.pdf)
- [Trail of Bits Audit (Protocol V2)](https://github.com/drift-labs/audits/blob/master/protocol-v2/tob.pdf)



================================================
FILE: Cargo.toml
================================================
[workspace]
members = [
	"programs/*",
]
exclude = [
	"deps/serum-dex"
]

[profile.release]
lto = "fat"
codegen-units = 1

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1



================================================
FILE: codecov.yml
================================================
comment:
  layout: "header, diff, flags, components"

component_management:
  individual_components:
    - component_id: drift
      name: drift
      paths:
        - programs/drift


================================================
FILE: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2021 Drift Labs

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


================================================
FILE: package.json
================================================
{
	"directories": {
		"test": "tests"
	},
	"author": "",
	"license": "ISC",
	"devDependencies": {
		"@coral-xyz/anchor": "0.29.0",
		"@coral-xyz/anchor-30": "npm:@coral-xyz/anchor@0.30.1",
		"@project-serum/common": "0.0.1-beta.3",
		"@project-serum/serum": "0.13.65",
		"@pythnetwork/client": "2.21.0",
		"@pythnetwork/price-service-client": "1.9.0",
		"@solana/spl-token": "0.4.13",
		"@solana/web3.js": "1.73.2",
		"@types/bn.js": "5.1.6",
		"@types/chai": "5.0.0",
		"@types/mocha": "8.2.3",
		"@typescript-eslint/eslint-plugin": "6.21.0",
		"@typescript-eslint/parser": "6.21.0",
		"chai": "4.4.1",
		"eslint": "8.57.0",
		"eslint-config-prettier": "8.3.0",
		"eslint-plugin-prettier": "3.4.0",
		"husky": "7.0.4",
		"prettier": "3.0.1",
		"typedoc": "0.23.23",
		"typescript": "5.4.5"
	},
	"dependencies": {
		"@ellipsis-labs/phoenix-sdk": "1.4.2",
		"@msgpack/msgpack": "^3.1.2",
		"@pythnetwork/pyth-solana-receiver": "0.8.0",
		"@switchboard-xyz/common": "3.0.14",
		"@switchboard-xyz/on-demand": "2.4.1",
		"anchor-bankrun": "0.3.0",
		"chai-bn": "0.2.2",
		"csvtojson": "2.0.10",
		"dotenv": "16.4.5",
		"json2csv": "5.0.7",
		"nanoid": "3.3.4",
		"rpc-websockets": "7.5.1",
		"solana-bankrun": "0.3.0",
		"zod": "4.0.17",
		"zstddec": "0.1.0"
	},
	"scripts": {
		"generate-docs": "typedoc --skipErrorChecking --logLevel Error",
		"prepare": "husky install",
		"prettify": "prettier --check './sdk/src/**/*.ts' './tests/**.ts' './cli/**.ts'",
		"prettify:fix": "prettier --write './sdk/src/**/*.ts' './tests/**.ts' './cli/**.ts'",
		"lint": "eslint . --ext ts --quiet --format unix",
		"lint:fix": "eslint . --ext ts --fix",
		"update-idl": "anchor build -- --features anchor-test && cp target/idl/drift.json sdk/src/idl/drift.json"
	},
	"engines": {
		"node": ">=12"
	},
	"resolutions": {
		"chalk": "4.1.2",
		"debug": "<4.4.2",
		"ansi-styles": "4.3.0",
		"supports-color": "7.2.0",
		"strip-ansi": "6.0.1",
		"ansi-regex": "5.0.1",
		"wrap-ansi": "7.0.0",
		"color-convert": "<3.1.1",
		"color-name": "<2.0.1",
		"color-string": "<2.1.1",
		"simple-swizzle": "<0.2.3",
		"is-arrayish": "<0.3.3",
		"slice-ansi": "3.0.0",
		"error-ex": "<1.3.3",
		"backslash": "<0.2.1",
		"chalk-template": "<1.1.1",
		"supports-hyperlinks": "<4.1.1",
		"has-ansi": "<6.0.1"
	},
	"overrides": {
		"chalk": "4.1.2",
		"debug": "<4.4.2",
		"ansi-styles": "4.3.0",
		"supports-color": "7.2.0",
		"strip-ansi": "6.0.1",
		"ansi-regex": "5.0.1",
		"wrap-ansi": "7.0.0",
		"color-convert": "<3.1.1",
		"color-name": "<2.0.1",
		"color-string": "<2.1.1",
		"simple-swizzle": "<0.2.3",
		"is-arrayish": "<0.3.3",
		"slice-ansi": "3.0.0",
		"error-ex": "<1.3.3",
		"backslash": "<0.2.1",
		"chalk-template": "<1.1.1",
		"supports-hyperlinks": "<4.1.1",
		"has-ansi": "<6.0.1"
	}
}



================================================
FILE: SECURITY.md
================================================
# Bug Bounty Overview
Drift offers bug bounties for Drift's on-chain program code; UI only bugs are omitted.

|Severity|Description|Bug Bounty|
|-----------|--------------|-------------|
|Critical|Bugs that freeze user funds or drain the contract's holdings or involve theft of funds without user signatures|10% of the value of the hack up to $500,000|
|High|Bugs that could temporarily freeze user funds or incorrectly assign value to user funds|$10,000 to $50,000 per bug, assessed on a case by case basis|
|Medium/Low|Bugs that don't threaten user funds|$1,000 to $5,000 per bug, assessed on a case by case basis|

The severity guidelines are based on [Immunefi's classification system](https://immunefi.com/severity-updated/).
Note that these are simply guidelines for the severity of the bugs. Each bug bounty submission will be evaluated on a case-by-case basis.

## Submission
Please email hello@drift.trade with a detailed description of the attack vector. For critical and moderate bugs, we require a proof of concept done on a privately deployed mainnet contract. We will reach back out in 1 business day with additional questions or the next steps on the bug bounty.

## Bug Bounty Payment
Bug bounties will be paid in USDC. Alternative payment methods can be used on a case-by-case basis.

## Invalid Bug Bounties
The following are out of scope for the bug bounty:
1. Attacks that the reporter has already exploited themselves, leading to damage.
2. Attacks requiring access to leaked keys/credentials.
3. Attacks requiring access to privileged addresses (governance, admin).
4. Incorrect data supplied by third party oracles (this does not exclude oracle manipulation/flash loan attacks).
5. Lack of liquidity.
6. Third party, off-chain bot errors (for instance bugs with an arbitrage bot running on the smart contracts).
7. Best practice critiques.
8. Sybil attacks.
9. Attempted phishing or other social engineering attacks involving Drift contributors or users
10. Denial of service, or automated testing of services that generate significant traffic.
11. Any submission violating [Immunefi's rules](https://immunefi.com/rules/) 






================================================
FILE: tsconfig.json
================================================
{
	"compilerOptions": {
		"types": ["mocha", "chai"],
		"typeRoots": ["./node_modules/@types"],
		"lib": ["es2015"],
		"module": "commonjs",
		"target": "es6",
		"esModuleInterop": true,
		"skipLibCheck": true,
		"resolveJsonModule": true
	}
}



================================================
FILE: typedoc.json
================================================
{
    "tsconfig": "sdk/tsconfig.json",
    "entryPoints": ["sdk/src/index.ts"],
    "out": "docs/sdk/"
}


================================================
FILE: .eslintrc.js
================================================
module.exports = {
	"root": true,
	"parser": "@typescript-eslint/parser",
	"env": {
		"browser": true,
		"node": true
	},
	"ignorePatterns": ["**/lib", "**/node_modules", "migrations"],
	"plugins": [],
	"extends": [
		"eslint:recommended",
		"plugin:@typescript-eslint/eslint-recommended",
		"plugin:@typescript-eslint/recommended"
	],
	"rules": {
		"@typescript-eslint/explicit-function-return-type": "off",
		"@typescript-eslint/ban-ts-ignore": "off",
		"@typescript-eslint/ban-ts-comment": "off",
		"@typescript-eslint/no-explicit-any": "off",
		"@typescript-eslint/no-unused-vars": [
			2,
			{
				"argsIgnorePattern": "^_",
				"varsIgnorePattern": "^_"
			}
		],
		"@typescript-eslint/no-var-requires": 0,
		"@typescript-eslint/no-empty-function": 0,
		"no-mixed-spaces-and-tabs": [2, "smart-tabs"],
		"no-prototype-builtins": "off",
		"semi": 2,
		"no-restricted-imports": [
			"error",
			{
				"patterns": [
					{
						// Restrict importing BN from bn.js
						"group": ["bn.js"],
						"message": "Import BN from @drift-labs/sdk instead",
					},
					{
						// Prevent imports from index files within the same package
						group: [
							'**/index',
							'**/index.ts',
						],
						message:
							'Do not import from index file within the same package. Import directly from source files instead. This prevents barrel imports.',
					},
				],
			},
		],
	}
};



================================================
FILE: .prettierignore
================================================
**/node_modules/**


================================================
FILE: .prettierrc.js
================================================
module.exports = {
	semi: true,
	trailingComma: 'es5',
	singleQuote: true,
	printWidth: 80,
	tabWidth: 2,
	useTabs: true,
	bracketSameLine: false,
	endOfLine: 'auto',
};



================================================
FILE: .verified-build.json
================================================
{
  "dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH": ["--commit-hash", "8d2cd726afdc800f89c841ff3cf1968980719df0", "--library-name", "drift"]
}



================================================
FILE: bug-bounty/README.md
================================================
# Bug Bounty for v2 (coming soon)



================================================
FILE: cli/README.md
================================================
## Installation
```shell
yarn &&
tsc &&
npm link &&
drift config init
```


================================================
FILE: cli/cli.ts
================================================
#!/usr/bin/env node
import { Command, OptionValues, program } from 'commander';
const promptly = require('promptly');
const colors = require('colors');
import os from 'os';
import fs from 'fs';
import log from 'loglevel';
import { Admin, User, initialize, Markets, Wallet } from '@drift-labs/sdk';
import { Connection, Keypair, PublicKey } from '@solana/web3.js';
import { BN } from '@drift-labs/sdk';
import {
	ASSOCIATED_TOKEN_PROGRAM_ID,
	Token,
	TOKEN_PROGRAM_ID,
} from '@solana/spl-token';

log.setLevel(log.levels.INFO);

function commandWithDefaultOption(commandName: string): Command {
	return program
		.command(commandName)
		.option('-e, --env <env>', 'environment e.g devnet, mainnet-beta')
		.option('-k, --keypair <path>', 'Solana wallet')
		.option('-u, --url <url>', 'rpc url e.g. https://api.devnet.solana.com');
}

export function loadKeypair(keypairPath: string): Keypair {
	if (!keypairPath || keypairPath == '') {
		throw new Error('Keypair is required!');
	}
	const loaded = Keypair.fromSecretKey(
		new Uint8Array(JSON.parse(fs.readFileSync(keypairPath).toString()))
	);
	log.info(`wallet public key: ${loaded.publicKey}`);
	return loaded;
}

function adminFromOptions(options: OptionValues): Admin {
	let { env, keypair, url } = options;
	const config = getConfig();
	if (!env) {
		env = config.env;
	}
	log.info(`env: ${env}`);
	const sdkConfig = initialize({ env: env });

	if (!url) {
		url = config.url;
	}
	log.info(`url: ${url}`);
	const connection = new Connection(url);

	if (!keypair) {
		keypair = config.keypair;
	}
	const wallet = new Wallet(loadKeypair(keypair));

	return Admin.from(
		connection,
		wallet,
		new PublicKey(sdkConfig.DRIFT_PROGRAM_ID)
	);
}

async function wrapActionInAdminSubscribeUnsubscribe(
	options: OptionValues,
	action: (admin: Admin) => Promise<void>
): Promise<void> {
	const admin = adminFromOptions(options);
	log.info(`DriftClient subscribing`);
	await admin.subscribe();
	log.info(`DriftClient subscribed`);

	try {
		await action(admin);
	} catch (e) {
		log.error(e);
	}

	log.info(`DriftClient unsubscribing`);
	await admin.unsubscribe();
	log.info(`DriftClient unsubscribed`);
}

async function wrapActionInUserSubscribeUnsubscribe(
	options: OptionValues,
	action: (user: User) => Promise<void>
): Promise<void> {
	const admin = adminFromOptions(options);
	log.info(`DriftClient subscribing`);
	await admin.subscribe();
	log.info(`DriftClient subscribed`);
	const driftUser = User.from(admin, admin.wallet.publicKey);
	log.info(`User subscribing`);
	await driftUser.subscribe();
	log.info(`User subscribed`);

	try {
		await action(driftUser);
	} catch (e) {
		log.error(e);
	}

	log.info(`User unsubscribing`);
	await driftUser.unsubscribe();
	log.info(`User unsubscribed`);

	log.info(`DriftClient unsubscribing`);
	await admin.unsubscribe();
	log.info(`DriftClient unsubscribed`);
}

function logError(msg: string) {
	log.error(colors.red(msg));
}

function marketIndexFromSymbol(symbol: string): BN {
	const market = Markets.filter(
		(market) => market.baseAssetSymbol === symbol
	)[0];
	if (!market) {
		const msg = `Could not find market index for ${symbol}`;
		logError(msg);
		throw Error(msg);
	}
	return market.marketIndex;
}

commandWithDefaultOption('initialize')
	.argument('<collateral mint>', 'The collateral mint')
	.argument(
		'<admin controls prices>',
		'Whether the admin should control prices'
	)
	.action(
		async (collateralMint, adminControlsPrices, options: OptionValues) => {
			await wrapActionInAdminSubscribeUnsubscribe(
				options,
				async (admin: Admin) => {
					log.info(`collateralMint: ${collateralMint}`);
					log.info(`adminControlsPrices: ${adminControlsPrices}`);
					const collateralMintPublicKey = new PublicKey(collateralMint);
					log.info(`DriftClient initializing`);
					await admin.initialize(collateralMintPublicKey, adminControlsPrices);
				}
			);
		}
	);

commandWithDefaultOption('initialize-market')
	.argument(
		'<market index>',
		'Where the market will be initialized in the markets account'
	)
	.argument('<price oracle>', 'The public key for the oracle')
	.argument('<base asset reserve>', 'AMM base asset reserve')
	.argument('<quote asset reserve>', 'AMM quote asset reserve')
	.argument('<periodicity>', 'AMM quote asset reserve')
	.argument('<peg multiplier>', 'AMM peg multiplier')
	.action(
		async (
			marketIndex,
			priceOracle,
			baseAssetReserve,
			quoteAssetReserve,
			periodicity,
			pegMultiplier,
			options: OptionValues
		) => {
			await wrapActionInAdminSubscribeUnsubscribe(
				options,
				async (admin: Admin) => {
					log.info(`marketIndex: ${marketIndex}`);
					marketIndex = new BN(marketIndex);
					log.info(`priceOracle: ${priceOracle}`);
					priceOracle = new PublicKey(priceOracle);
					log.info(`baseAssetReserve: ${baseAssetReserve}`);
					baseAssetReserve = new BN(baseAssetReserve);
					log.info(`quoteAssetReserve: ${quoteAssetReserve}`);
					quoteAssetReserve = new BN(quoteAssetReserve);
					log.info(`periodicity: ${periodicity}`);
					periodicity = new BN(periodicity);
					log.info(`pegMultiplier: ${pegMultiplier}`);
					pegMultiplier = new BN(pegMultiplier);
					log.info(`Initializing market`);
					await admin.initializeMarket(
						priceOracle,
						baseAssetReserve,
						quoteAssetReserve,
						periodicity,
						pegMultiplier
					);
				}
			);
		}
	);

commandWithDefaultOption('update-discount-mint')
	.argument('<discount mint>', 'New discount mint')
	.action(async (discountMint, options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				log.info(`discountMint: ${discountMint}`);
				discountMint = new PublicKey(discountMint);
				await admin.updateDiscountMint(discountMint);
			}
		);
	});

commandWithDefaultOption('increase-k')
	.argument('<market>', 'The market to adjust k for')
	.argument('<numerator>', 'Numerator to multiply k by')
	.argument('<denominator>', 'Denominator to divide k by')
	.option('--force', 'Skip percent change check')
	.action(async (market, numerator, denominator, options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				log.info(`market: ${market}`);
				log.info(`numerator: ${numerator}`);
				log.info(`denominator: ${denominator}`);
				market = marketIndexFromSymbol(market);
				numerator = new BN(numerator);
				denominator = new BN(denominator);

				if (numerator.lt(denominator)) {
					logError('To increase k, numerator must be larger than denominator');
					return;
				}

				const percentChange = Math.abs(
					(numerator.toNumber() / denominator.toNumber()) * 100 - 100
				);
				if (percentChange > 10 && options.force !== true) {
					logError(
						`Specified input would lead to ${percentChange.toFixed(2)}% change`
					);
					return;
				}

				const answer = await promptly.prompt(
					`You are increasing k by ${percentChange}%. Are you sure you want to do this? y/n`
				);
				if (answer !== 'y') {
					log.info('Canceling');
					return;
				}

				const amm = admin.getMarketsAccount().markets[market.toNumber()].amm;
				const oldSqrtK = amm.sqrtK;
				log.info(`Current sqrt k: ${oldSqrtK.toString()}`);

				const newSqrtK = oldSqrtK.mul(numerator).div(denominator);
				log.info(`New sqrt k: ${newSqrtK.toString()}`);

				log.info(`Updating K`);
				await admin.updateK(market, newSqrtK);
				log.info(`Updated K`);
			}
		);
	});

commandWithDefaultOption('decrease-k')
	.argument('<market>', 'The market to adjust k for')
	.argument('<numerator>', 'Numerator to multiply k by')
	.argument('<denominator>', 'Denominator to divide k by')
	.option('--force', 'Skip percent change check')
	.action(async (market, numerator, denominator, options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				log.info(`market: ${market}`);
				log.info(`numerator: ${numerator}`);
				log.info(`denominator: ${denominator}`);
				market = marketIndexFromSymbol(market);
				numerator = new BN(numerator);
				denominator = new BN(denominator);

				if (numerator.gt(denominator)) {
					logError('To decrease k, numerator must be less than denominator');
					return;
				}

				const percentChange = Math.abs(
					(numerator.toNumber() / denominator.toNumber()) * 100 - 100
				);
				if (percentChange > 2) {
					logError(
						`Specified input would lead to ${percentChange.toFixed(2)}% change`
					);
					return;
				}

				const answer = await promptly.prompt(
					`You are decreasing k by ${percentChange}%. Are you sure you want to do this? y/n`
				);
				if (answer !== 'y' && options.force !== true) {
					log.info('Canceling');
					return;
				}

				const amm = admin.getMarketsAccount().markets[market.toNumber()].amm;
				const oldSqrtK = amm.sqrtK;
				log.info(`Current sqrt k: ${oldSqrtK.toString()}`);

				const newSqrtK = oldSqrtK.mul(numerator).div(denominator);
				log.info(`New sqrt k: ${newSqrtK.toString()}`);

				log.info(`Updating K`);
				await admin.updateK(market, newSqrtK);
				log.info(`Updated K`);
			}
		);
	});

commandWithDefaultOption('repeg')
	.argument('<market>', 'The market to adjust k for')
	.argument('<peg>', 'New Peg')
	.action(async (market, peg, options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				log.info(`market: ${market}`);
				log.info(`peg: ${peg}`);
				market = marketIndexFromSymbol(market);
				peg = new BN(peg);

				const amm = admin.getMarketsAccount().markets[market.toNumber()].amm;
				const oldPeg = amm.pegMultiplier;
				log.info(`Current peg: ${oldPeg.toString()}`);

				log.info(`Updating peg`);
				await admin.repegAmmCurve(peg, market);
				log.info(`Updated peg`);
			}
		);
	});

commandWithDefaultOption('pause-exchange').action(
	async (options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				const answer = await promptly.prompt(
					`Are you sure you want to 'pause' the exchange? y/n`
				);
				if (answer !== 'y') {
					log.info('Canceling');
					return;
				}
				await admin.updateExchangePaused(true);
				log.info(`Exchange was paused`);
			}
		);
	}
);

commandWithDefaultOption('unpause-exchange').action(
	async (options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				const answer = await promptly.prompt(
					`Are you sure you want to 'unpause' the exchange? y/n`
				);
				if (answer !== 'y') {
					log.info('Canceling');
					return;
				}
				await admin.updateExchangePaused(false);
				log.info(`Exchange was unpaused`);
			}
		);
	}
);

commandWithDefaultOption('pause-funding').action(
	async (options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				const answer = await promptly.prompt(
					`Are you sure you want to 'pause' funding? y/n`
				);
				if (answer !== 'y') {
					log.info('Canceling');
					return;
				}
				await admin.updateFundingPaused(true);
				log.info(`Funding was paused`);
			}
		);
	}
);

commandWithDefaultOption('unpause-funding').action(
	async (options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				const answer = await promptly.prompt(
					`Are you sure you want to 'unpause' funding? y/n`
				);
				if (answer !== 'y') {
					log.info('Canceling');
					return;
				}
				await admin.updateFundingPaused(false);
				log.info(`Funding was unpaused`);
			}
		);
	}
);

commandWithDefaultOption('update-oracle-twap')
	.argument('<market>', 'The market to update oracle twap for')
	.action(async (market, options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				log.info(`market: ${market}`);
				market = marketIndexFromSymbol(market);

				log.info(`Updating amm oracle twap`);
				await admin.updateAmmOracleTwap(market);
				log.info(`Updated oracle twap`);
			}
		);
	});

commandWithDefaultOption('reset-oracle-twap')
	.argument('<market>', 'The market to reset oracle twap for')
	.action(async (market, options: OptionValues) => {
		await wrapActionInAdminSubscribeUnsubscribe(
			options,
			async (admin: Admin) => {
				log.info(`market: ${market}`);
				market = marketIndexFromSymbol(market);

				log.info(`Resetting amm oracle twap`);
				await admin.resetAmmOracleTwap(market);
				log.info(`Reset oracle twap`);
			}
		);
	});

commandWithDefaultOption('deposit')
	.argument('<amount>', 'The amount to deposit')
	.action(async (amount, options: OptionValues) => {
		await wrapActionInUserSubscribeUnsubscribe(options, async (user: User) => {
			log.info(`amount: ${amount}`);
			amount = new BN(amount);

			const associatedTokenPublicKey = await Token.getAssociatedTokenAddress(
				ASSOCIATED_TOKEN_PROGRAM_ID,
				TOKEN_PROGRAM_ID,
				user.driftClient.getStateAccount().collateralMint,
				user.authority
			);

			await user.driftClient.depositCollateral(
				amount,
				associatedTokenPublicKey
			);
		});
	});

function getConfigFileDir(): string {
	return os.homedir() + `/.config/drift-v1`;
}

function getConfigFilePath(): string {
	return `${getConfigFileDir()}/config.json`;
}

function getConfig() {
	if (!fs.existsSync(getConfigFilePath())) {
		console.error('drfit-v1 config does not exit. Run `drift-v1 config init`');
		return;
	}

	return JSON.parse(fs.readFileSync(getConfigFilePath(), 'utf8'));
}

const config = program.command('config');
config.command('init').action(async () => {
	const defaultConfig = {
		env: 'devnet',
		url: 'https://api.devnet.solana.com',
		keypair: `${os.homedir()}/.config/solana/id.json`,
	};

	const dir = getConfigFileDir();
	if (!fs.existsSync(getConfigFileDir())) {
		fs.mkdirSync(dir, { recursive: true });
	}

	fs.writeFileSync(getConfigFilePath(), JSON.stringify(defaultConfig));
});

config
	.command('set')
	.argument('<key>', 'the config key e.g. env, url, keypair')
	.argument('<value>')
	.action(async (key, value) => {
		if (key !== 'env' && key !== 'url' && key !== 'keypair') {
			console.error(`Key must be env, url or keypair`);
			return;
		}

		const config = JSON.parse(fs.readFileSync(getConfigFilePath(), 'utf8'));
		config[key] = value;
		fs.writeFileSync(getConfigFilePath(), JSON.stringify(config));
	});

config.command('get').action(async () => {
	const config = getConfig();
	console.log(JSON.stringify(config, null, 4));
});

program.parse(process.argv);



================================================
FILE: cli/package.json
================================================
{
	"name": "drift-v1-cli",
	"version": "0.0.0",
	"description": "",
	"bin": {
		"drift": "./build/cli.js"
	},
	"scripts": {},
	"author": "crispheaney",
	"license": "ISC",
	"dependencies": {
		"@drift-labs/sdk": "file:../sdk",
		"@project-serum/anchor": "0.24.2",
		"@solana/spl-token": "^0.1.8",
		"@solana/web3.js": "^1.30.2",
		"@types/node": "^16.7.10",
		"colors": "^1.4.0",
		"commander": "8.1.0",
		"loglevel": "^1.7.1",
		"promptly": "^3.2.0"
	}
}



================================================
FILE: cli/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es6",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./build",
    "resolveJsonModule": true
  }
}


================================================
FILE: deploy-scripts/build-devnet.sh
================================================
#!/bin/sh
anchor build -- --no-default-features --features no-entrypoint


================================================
FILE: deploy-scripts/deploy-devnet.sh
================================================
#!/bin/sh
anchor upgrade --program-id dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH --provider.cluster devnet --provider.wallet $SOLANA_PATH/$DEVNET_ADMIN target/deploy/drift.so


================================================
FILE: deploy-scripts/verified-build.sh
================================================
#!/bin/sh
solana-verify build --library-name drift


================================================
FILE: deps/configs/pyth_lazer_storage.json
================================================
{
  "pubkey": "3rdJbqfnagQ4yx9HXJViD4zc4xpiSqmFsKpPuSCQVyQL",
  "account": {
    "lamports": 1461600,
    "data": [
      "0XX/ucSvRAkL/td28gTUmmjn6CkzKyvYXJOMcup4pEKu3cXcP7cvDAv+13byBNSaaOfoKTMrK9hck4xy6nikQq7dxdw/ty8MAQAAAAAAAAAB9lIQvuT89bHO4eU3+rz9lQECl2U7lK8E1FT8Rz6Ug0/oNgZ6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
      "base64"
    ],
    "owner": "pytd2yyk641x7ak7mkaasSJVXh6YYZnC7wTmtgAyxPt",
    "executable": false,
    "rentEpoch": 367
  }
}



================================================
FILE: deps/configs/usdc.json
================================================
{
  "pubkey": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  "account": {
    "lamports": 1461600,
    "data": [
      "AQAAANuZX+JRadFByrm7upK6oB+fLh7OffTLKsBRkPN/zB+dAAAAAAAAAAAGAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
      "base64"
    ],
    "owner": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    "executable": false,
    "rentEpoch": 367
  }
}



================================================
FILE: programs/drift/Cargo.toml
================================================
[package]
name = "drift"
version = "2.143.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "drift"
path = "src/lib.rs"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
mainnet-beta=[]
anchor-test= []
default=["mainnet-beta", "no-entrypoint"]
drift-rs=[]

[dependencies]
anchor-lang = "0.29.0"
solana-program = "1.16"
anchor-spl = "0.29.0"
pyth-client = "0.2.2"
pyth-lazer-solana-contract = { git = "https://github.com/drift-labs/pyth-crosschain", rev = "d790d1cb4da873a949cf33ff70349b7614b232eb", features = ["no-entrypoint"]}
pythnet-sdk = { git = "https://github.com/drift-labs/pyth-crosschain", rev = "3e8a24ecd0bcf22b787313e2020f4186bb22c729"}
pyth-solana-receiver-sdk = { git = "https://github.com/drift-labs/pyth-crosschain", rev = "3e8a24ecd0bcf22b787313e2020f4186bb22c729"}
bytemuck = { version = "1.4.0" }
borsh = "0.10.3"
hex = "0.4.3"
num-traits = "0.2"
uint = { version = "0.9.1", default-features = false }
num-derive = "0.3"
thiserror = "1.0"
num-integer = "0.1.44"
arrayref = "0.3.6"
base64 = "0.13.0"
serum_dex = { git = "https://github.com/project-serum/serum-dex", rev = "85b4f14", version = "0.5.6", features = ["no-entrypoint"] }
enumflags2 = "0.6.4"
phoenix-v1 = { git = "https://github.com/drift-labs/phoenix-v1", rev = "7703c5", version = "0.2.4", features = ["no-entrypoint"] }
solana-security-txt = "1.1.0"
static_assertions = "1.1.0"
drift-macros = { git = "https://github.com/drift-labs/drift-macros.git", rev = "c57d87" }
switchboard = { path = "../switchboard", features = ["no-entrypoint"] }
openbook-v2-light = { path = "../openbook_v2", features = ["no-entrypoint"] }
ahash = "=0.8.6"
switchboard-on-demand = { path = "../switchboard-on-demand", features = ["no-entrypoint"] }
byteorder = "1.4.3"

[dev-dependencies]
bytes = "1.2.0"
pyth = { path = "../pyth", features = ["no-entrypoint"]}
base64 = "0.13.0"



================================================
FILE: programs/drift/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
FILE: programs/drift/src/error.rs
================================================
use anchor_lang::prelude::*;

pub type DriftResult<T = ()> = std::result::Result<T, ErrorCode>;

#[error_code]
#[derive(PartialEq, Eq)]
pub enum ErrorCode {
    #[msg("Invalid Spot Market Authority")]
    InvalidSpotMarketAuthority,
    #[msg("Clearing house not insurance fund authority")]
    InvalidInsuranceFundAuthority,
    #[msg("Insufficient deposit")]
    InsufficientDeposit,
    #[msg("Insufficient collateral")]
    InsufficientCollateral,
    #[msg("Sufficient collateral")]
    SufficientCollateral,
    #[msg("Max number of positions taken")]
    MaxNumberOfPositions,
    #[msg("Admin Controls Prices Disabled")]
    AdminControlsPricesDisabled,
    #[msg("Market Delisted")]
    MarketDelisted,
    #[msg("Market Index Already Initialized")]
    MarketIndexAlreadyInitialized,
    #[msg("User Account And User Positions Account Mismatch")]
    UserAccountAndUserPositionsAccountMismatch,
    #[msg("User Has No Position In Market")]
    UserHasNoPositionInMarket,
    #[msg("Invalid Initial Peg")]
    InvalidInitialPeg,
    #[msg("AMM repeg already configured with amt given")]
    InvalidRepegRedundant,
    #[msg("AMM repeg incorrect repeg direction")]
    InvalidRepegDirection,
    #[msg("AMM repeg out of bounds pnl")]
    InvalidRepegProfitability,
    #[msg("Slippage Outside Limit Price")]
    SlippageOutsideLimit,
    #[msg("Order Size Too Small")]
    OrderSizeTooSmall,
    #[msg("Price change too large when updating K")]
    InvalidUpdateK,
    #[msg("Admin tried to withdraw amount larger than fees collected")]
    AdminWithdrawTooLarge,
    #[msg("Math Error")]
    MathError,
    #[msg("Conversion to u128/u64 failed with an overflow or underflow")]
    BnConversionError,
    #[msg("Clock unavailable")]
    ClockUnavailable,
    #[msg("Unable To Load Oracles")]
    UnableToLoadOracle,
    #[msg("Price Bands Breached")]
    PriceBandsBreached,
    #[msg("Exchange is paused")]
    ExchangePaused,
    #[msg("Invalid whitelist token")]
    InvalidWhitelistToken,
    #[msg("Whitelist token not found")]
    WhitelistTokenNotFound,
    #[msg("Invalid discount token")]
    InvalidDiscountToken,
    #[msg("Discount token not found")]
    DiscountTokenNotFound,
    #[msg("Referrer not found")]
    ReferrerNotFound,
    #[msg("ReferrerNotFound")]
    ReferrerStatsNotFound,
    #[msg("ReferrerMustBeWritable")]
    ReferrerMustBeWritable,
    #[msg("ReferrerMustBeWritable")]
    ReferrerStatsMustBeWritable,
    #[msg("ReferrerAndReferrerStatsAuthorityUnequal")]
    ReferrerAndReferrerStatsAuthorityUnequal,
    #[msg("InvalidReferrer")]
    InvalidReferrer,
    #[msg("InvalidOracle")]
    InvalidOracle,
    #[msg("OracleNotFound")]
    OracleNotFound,
    #[msg("Liquidations Blocked By Oracle")]
    LiquidationsBlockedByOracle,
    #[msg("Can not deposit more than max deposit")]
    MaxDeposit,
    #[msg("Can not delete user that still has collateral")]
    CantDeleteUserWithCollateral,
    #[msg("AMM funding out of bounds pnl")]
    InvalidFundingProfitability,
    #[msg("Casting Failure")]
    CastingFailure,
    #[msg("InvalidOrder")]
    InvalidOrder,
    #[msg("InvalidOrderMaxTs")]
    InvalidOrderMaxTs,
    #[msg("InvalidOrderMarketType")]
    InvalidOrderMarketType,
    #[msg("InvalidOrderForInitialMarginReq")]
    InvalidOrderForInitialMarginReq,
    #[msg("InvalidOrderNotRiskReducing")]
    InvalidOrderNotRiskReducing,
    #[msg("InvalidOrderSizeTooSmall")]
    InvalidOrderSizeTooSmall,
    #[msg("InvalidOrderNotStepSizeMultiple")]
    InvalidOrderNotStepSizeMultiple,
    #[msg("InvalidOrderBaseQuoteAsset")]
    InvalidOrderBaseQuoteAsset,
    #[msg("InvalidOrderIOC")]
    InvalidOrderIOC,
    #[msg("InvalidOrderPostOnly")]
    InvalidOrderPostOnly,
    #[msg("InvalidOrderIOCPostOnly")]
    InvalidOrderIOCPostOnly,
    #[msg("InvalidOrderTrigger")]
    InvalidOrderTrigger,
    #[msg("InvalidOrderAuction")]
    InvalidOrderAuction,
    #[msg("InvalidOrderOracleOffset")]
    InvalidOrderOracleOffset,
    #[msg("InvalidOrderMinOrderSize")]
    InvalidOrderMinOrderSize,
    #[msg("Failed to Place Post-Only Limit Order")]
    PlacePostOnlyLimitFailure,
    #[msg("User has no order")]
    UserHasNoOrder,
    #[msg("Order Amount Too Small")]
    OrderAmountTooSmall,
    #[msg("Max number of orders taken")]
    MaxNumberOfOrders,
    #[msg("Order does not exist")]
    OrderDoesNotExist,
    #[msg("Order not open")]
    OrderNotOpen,
    #[msg("FillOrderDidNotUpdateState")]
    FillOrderDidNotUpdateState,
    #[msg("Reduce only order increased risk")]
    ReduceOnlyOrderIncreasedRisk,
    #[msg("Unable to load AccountLoader")]
    UnableToLoadAccountLoader,
    #[msg("Trade Size Too Large")]
    TradeSizeTooLarge,
    #[msg("User cant refer themselves")]
    UserCantReferThemselves,
    #[msg("Did not receive expected referrer")]
    DidNotReceiveExpectedReferrer,
    #[msg("Could not deserialize referrer")]
    CouldNotDeserializeReferrer,
    #[msg("Could not deserialize referrer stats")]
    CouldNotDeserializeReferrerStats,
    #[msg("User Order Id Already In Use")]
    UserOrderIdAlreadyInUse,
    #[msg("No positions liquidatable")]
    NoPositionsLiquidatable,
    #[msg("Invalid Margin Ratio")]
    InvalidMarginRatio,
    #[msg("Cant Cancel Post Only Order")]
    CantCancelPostOnlyOrder,
    #[msg("InvalidOracleOffset")]
    InvalidOracleOffset,
    #[msg("CantExpireOrders")]
    CantExpireOrders,
    #[msg("CouldNotLoadMarketData")]
    CouldNotLoadMarketData,
    #[msg("PerpMarketNotFound")]
    PerpMarketNotFound,
    #[msg("InvalidMarketAccount")]
    InvalidMarketAccount,
    #[msg("UnableToLoadMarketAccount")]
    UnableToLoadPerpMarketAccount,
    #[msg("MarketWrongMutability")]
    MarketWrongMutability,
    #[msg("UnableToCastUnixTime")]
    UnableToCastUnixTime,
    #[msg("CouldNotFindSpotPosition")]
    CouldNotFindSpotPosition,
    #[msg("NoSpotPositionAvailable")]
    NoSpotPositionAvailable,
    #[msg("InvalidSpotMarketInitialization")]
    InvalidSpotMarketInitialization,
    #[msg("CouldNotLoadSpotMarketData")]
    CouldNotLoadSpotMarketData,
    #[msg("SpotMarketNotFound")]
    SpotMarketNotFound,
    #[msg("InvalidSpotMarketAccount")]
    InvalidSpotMarketAccount,
    #[msg("UnableToLoadSpotMarketAccount")]
    UnableToLoadSpotMarketAccount,
    #[msg("SpotMarketWrongMutability")]
    SpotMarketWrongMutability,
    #[msg("SpotInterestNotUpToDate")]
    SpotMarketInterestNotUpToDate,
    #[msg("SpotMarketInsufficientDeposits")]
    SpotMarketInsufficientDeposits,
    #[msg("UserMustSettleTheirOwnPositiveUnsettledPNL")]
    UserMustSettleTheirOwnPositiveUnsettledPNL,
    #[msg("CantUpdatePoolBalanceType")]
    CantUpdatePoolBalanceType,
    #[msg("InsufficientCollateralForSettlingPNL")]
    InsufficientCollateralForSettlingPNL,
    #[msg("AMMNotUpdatedInSameSlot")]
    AMMNotUpdatedInSameSlot,
    #[msg("AuctionNotComplete")]
    AuctionNotComplete,
    #[msg("MakerNotFound")]
    MakerNotFound,
    #[msg("MakerNotFound")]
    MakerStatsNotFound,
    #[msg("MakerMustBeWritable")]
    MakerMustBeWritable,
    #[msg("MakerMustBeWritable")]
    MakerStatsMustBeWritable,
    #[msg("MakerOrderNotFound")]
    MakerOrderNotFound,
    #[msg("CouldNotDeserializeMaker")]
    CouldNotDeserializeMaker,
    #[msg("CouldNotDeserializeMaker")]
    CouldNotDeserializeMakerStats,
    #[msg("AuctionPriceDoesNotSatisfyMaker")]
    AuctionPriceDoesNotSatisfyMaker,
    #[msg("MakerCantFulfillOwnOrder")]
    MakerCantFulfillOwnOrder,
    #[msg("MakerOrderMustBePostOnly")]
    MakerOrderMustBePostOnly,
    #[msg("CantMatchTwoPostOnlys")]
    CantMatchTwoPostOnlys,
    #[msg("OrderBreachesOraclePriceLimits")]
    OrderBreachesOraclePriceLimits,
    #[msg("OrderMustBeTriggeredFirst")]
    OrderMustBeTriggeredFirst,
    #[msg("OrderNotTriggerable")]
    OrderNotTriggerable,
    #[msg("OrderDidNotSatisfyTriggerCondition")]
    OrderDidNotSatisfyTriggerCondition,
    #[msg("PositionAlreadyBeingLiquidated")]
    PositionAlreadyBeingLiquidated,
    #[msg("PositionDoesntHaveOpenPositionOrOrders")]
    PositionDoesntHaveOpenPositionOrOrders,
    #[msg("AllOrdersAreAlreadyLiquidations")]
    AllOrdersAreAlreadyLiquidations,
    #[msg("CantCancelLiquidationOrder")]
    CantCancelLiquidationOrder,
    #[msg("UserIsBeingLiquidated")]
    UserIsBeingLiquidated,
    #[msg("LiquidationsOngoing")]
    LiquidationsOngoing,
    #[msg("WrongSpotBalanceType")]
    WrongSpotBalanceType,
    #[msg("UserCantLiquidateThemself")]
    UserCantLiquidateThemself,
    #[msg("InvalidPerpPositionToLiquidate")]
    InvalidPerpPositionToLiquidate,
    #[msg("InvalidBaseAssetAmountForLiquidatePerp")]
    InvalidBaseAssetAmountForLiquidatePerp,
    #[msg("InvalidPositionLastFundingRate")]
    InvalidPositionLastFundingRate,
    #[msg("InvalidPositionDelta")]
    InvalidPositionDelta,
    #[msg("UserBankrupt")]
    UserBankrupt,
    #[msg("UserNotBankrupt")]
    UserNotBankrupt,
    #[msg("UserHasInvalidBorrow")]
    UserHasInvalidBorrow,
    #[msg("DailyWithdrawLimit")]
    DailyWithdrawLimit,
    #[msg("DefaultError")]
    DefaultError,
    #[msg("Insufficient LP tokens")]
    InsufficientLPTokens,
    #[msg("Cant LP with a market position")]
    CantLPWithPerpPosition,
    #[msg("Unable to burn LP tokens")]
    UnableToBurnLPTokens,
    #[msg("Trying to remove liqudity too fast after adding it")]
    TryingToRemoveLiquidityTooFast,
    #[msg("Invalid Spot Market Vault")]
    InvalidSpotMarketVault,
    #[msg("Invalid Spot Market State")]
    InvalidSpotMarketState,
    #[msg("InvalidSerumProgram")]
    InvalidSerumProgram,
    #[msg("InvalidSerumMarket")]
    InvalidSerumMarket,
    #[msg("InvalidSerumBids")]
    InvalidSerumBids,
    #[msg("InvalidSerumAsks")]
    InvalidSerumAsks,
    #[msg("InvalidSerumOpenOrders")]
    InvalidSerumOpenOrders,
    #[msg("FailedSerumCPI")]
    FailedSerumCPI,
    #[msg("FailedToFillOnExternalMarket")]
    FailedToFillOnExternalMarket,
    #[msg("InvalidFulfillmentConfig")]
    InvalidFulfillmentConfig,
    #[msg("InvalidFeeStructure")]
    InvalidFeeStructure,
    #[msg("Insufficient IF shares")]
    InsufficientIFShares,
    #[msg("the Market has paused this action")]
    MarketActionPaused,
    #[msg("the Market status doesnt allow placing orders")]
    MarketPlaceOrderPaused,
    #[msg("the Market status doesnt allow filling orders")]
    MarketFillOrderPaused,
    #[msg("the Market status doesnt allow withdraws")]
    MarketWithdrawPaused,
    #[msg("Action violates the Protected Asset Tier rules")]
    ProtectedAssetTierViolation,
    #[msg("Action violates the Isolated Asset Tier rules")]
    IsolatedAssetTierViolation,
    #[msg("User Cant Be Deleted")]
    UserCantBeDeleted,
    #[msg("Reduce Only Withdraw Increased Risk")]
    ReduceOnlyWithdrawIncreasedRisk,
    #[msg("Max Open Interest")]
    MaxOpenInterest,
    #[msg("Cant Resolve Perp Bankruptcy")]
    CantResolvePerpBankruptcy,
    #[msg("Liquidation Doesnt Satisfy Limit Price")]
    LiquidationDoesntSatisfyLimitPrice,
    #[msg("Margin Trading Disabled")]
    MarginTradingDisabled,
    #[msg("Invalid Market Status to Settle Perp Pnl")]
    InvalidMarketStatusToSettlePnl,
    #[msg("PerpMarketNotInSettlement")]
    PerpMarketNotInSettlement,
    #[msg("PerpMarketNotInReduceOnly")]
    PerpMarketNotInReduceOnly,
    #[msg("PerpMarketSettlementBufferNotReached")]
    PerpMarketSettlementBufferNotReached,
    #[msg("PerpMarketSettlementUserHasOpenOrders")]
    PerpMarketSettlementUserHasOpenOrders,
    #[msg("PerpMarketSettlementUserHasActiveLP")]
    PerpMarketSettlementUserHasActiveLP,
    #[msg("UnableToSettleExpiredUserPosition")]
    UnableToSettleExpiredUserPosition,
    #[msg("UnequalMarketIndexForSpotTransfer")]
    UnequalMarketIndexForSpotTransfer,
    #[msg("InvalidPerpPositionDetected")]
    InvalidPerpPositionDetected,
    #[msg("InvalidSpotPositionDetected")]
    InvalidSpotPositionDetected,
    #[msg("InvalidAmmDetected")]
    InvalidAmmDetected,
    #[msg("InvalidAmmForFillDetected")]
    InvalidAmmForFillDetected,
    #[msg("InvalidAmmLimitPriceOverride")]
    InvalidAmmLimitPriceOverride,
    #[msg("InvalidOrderFillPrice")]
    InvalidOrderFillPrice,
    #[msg("SpotMarketBalanceInvariantViolated")]
    SpotMarketBalanceInvariantViolated,
    #[msg("SpotMarketVaultInvariantViolated")]
    SpotMarketVaultInvariantViolated,
    #[msg("InvalidPDA")]
    InvalidPDA,
    #[msg("InvalidPDASigner")]
    InvalidPDASigner,
    #[msg("RevenueSettingsCannotSettleToIF")]
    RevenueSettingsCannotSettleToIF,
    #[msg("NoRevenueToSettleToIF")]
    NoRevenueToSettleToIF,
    #[msg("NoAmmPerpPnlDeficit")]
    NoAmmPerpPnlDeficit,
    #[msg("SufficientPerpPnlPool")]
    SufficientPerpPnlPool,
    #[msg("InsufficientPerpPnlPool")]
    InsufficientPerpPnlPool,
    #[msg("PerpPnlDeficitBelowThreshold")]
    PerpPnlDeficitBelowThreshold,
    #[msg("MaxRevenueWithdrawPerPeriodReached")]
    MaxRevenueWithdrawPerPeriodReached,
    #[msg("InvalidSpotPositionDetected")]
    MaxIFWithdrawReached,
    #[msg("NoIFWithdrawAvailable")]
    NoIFWithdrawAvailable,
    #[msg("InvalidIFUnstake")]
    InvalidIFUnstake,
    #[msg("InvalidIFUnstakeSize")]
    InvalidIFUnstakeSize,
    #[msg("InvalidIFUnstakeCancel")]
    InvalidIFUnstakeCancel,
    #[msg("InvalidIFForNewStakes")]
    InvalidIFForNewStakes,
    #[msg("InvalidIFRebase")]
    InvalidIFRebase,
    #[msg("InvalidInsuranceUnstakeSize")]
    InvalidInsuranceUnstakeSize,
    #[msg("InvalidOrderLimitPrice")]
    InvalidOrderLimitPrice,
    #[msg("InvalidIFDetected")]
    InvalidIFDetected,
    #[msg("InvalidAmmMaxSpreadDetected")]
    InvalidAmmMaxSpreadDetected,
    #[msg("InvalidConcentrationCoef")]
    InvalidConcentrationCoef,
    #[msg("InvalidSrmVault")]
    InvalidSrmVault,
    #[msg("InvalidVaultOwner")]
    InvalidVaultOwner,
    #[msg("InvalidMarketStatusForFills")]
    InvalidMarketStatusForFills,
    #[msg("IFWithdrawRequestInProgress")]
    IFWithdrawRequestInProgress,
    #[msg("NoIFWithdrawRequestInProgress")]
    NoIFWithdrawRequestInProgress,
    #[msg("IFWithdrawRequestTooSmall")]
    IFWithdrawRequestTooSmall,
    #[msg("IncorrectSpotMarketAccountPassed")]
    IncorrectSpotMarketAccountPassed,
    #[msg("BlockchainClockInconsistency")]
    BlockchainClockInconsistency,
    #[msg("InvalidIFSharesDetected")]
    InvalidIFSharesDetected,
    #[msg("NewLPSizeTooSmall")]
    NewLPSizeTooSmall,
    #[msg("MarketStatusInvalidForNewLP")]
    MarketStatusInvalidForNewLP,
    #[msg("InvalidMarkTwapUpdateDetected")]
    InvalidMarkTwapUpdateDetected,
    #[msg("MarketSettlementAttemptOnActiveMarket")]
    MarketSettlementAttemptOnActiveMarket,
    #[msg("MarketSettlementRequiresSettledLP")]
    MarketSettlementRequiresSettledLP,
    #[msg("MarketSettlementAttemptTooEarly")]
    MarketSettlementAttemptTooEarly,
    #[msg("MarketSettlementTargetPriceInvalid")]
    MarketSettlementTargetPriceInvalid,
    #[msg("UnsupportedSpotMarket")]
    UnsupportedSpotMarket,
    #[msg("SpotOrdersDisabled")]
    SpotOrdersDisabled,
    #[msg("Market Being Initialized")]
    MarketBeingInitialized,
    #[msg("Invalid Sub Account Id")]
    InvalidUserSubAccountId,
    #[msg("Invalid Trigger Order Condition")]
    InvalidTriggerOrderCondition,
    #[msg("Invalid Spot Position")]
    InvalidSpotPosition,
    #[msg("Cant transfer between same user account")]
    CantTransferBetweenSameUserAccount,
    #[msg("Invalid Perp Position")]
    InvalidPerpPosition,
    #[msg("Unable To Get Limit Price")]
    UnableToGetLimitPrice,
    #[msg("Invalid Liquidation")]
    InvalidLiquidation,
    #[msg("Spot Fulfillment Config Disabled")]
    SpotFulfillmentConfigDisabled,
    #[msg("Invalid Maker")]
    InvalidMaker,
    #[msg("Failed Unwrap")]
    FailedUnwrap,
    #[msg("Max Number Of Users")]
    MaxNumberOfUsers,
    #[msg("InvalidOracleForSettlePnl")]
    InvalidOracleForSettlePnl,
    #[msg("MarginOrdersOpen")]
    MarginOrdersOpen,
    #[msg("TierViolationLiquidatingPerpPnl")]
    TierViolationLiquidatingPerpPnl,
    #[msg("CouldNotLoadUserData")]
    CouldNotLoadUserData,
    #[msg("UserWrongMutability")]
    UserWrongMutability,
    #[msg("InvalidUserAccount")]
    InvalidUserAccount,
    #[msg("CouldNotLoadUserData")]
    CouldNotLoadUserStatsData,
    #[msg("UserWrongMutability")]
    UserStatsWrongMutability,
    #[msg("InvalidUserAccount")]
    InvalidUserStatsAccount,
    #[msg("UserNotFound")]
    UserNotFound,
    #[msg("UnableToLoadUserAccount")]
    UnableToLoadUserAccount,
    #[msg("UserStatsNotFound")]
    UserStatsNotFound,
    #[msg("UnableToLoadUserStatsAccount")]
    UnableToLoadUserStatsAccount,
    #[msg("User Not Inactive")]
    UserNotInactive,
    #[msg("RevertFill")]
    RevertFill,
    #[msg("Invalid MarketAccount for Deletion")]
    InvalidMarketAccountforDeletion,
    #[msg("Invalid Spot Fulfillment Params")]
    InvalidSpotFulfillmentParams,
    #[msg("Failed to Get Mint")]
    FailedToGetMint,
    #[msg("FailedPhoenixCPI")]
    FailedPhoenixCPI,
    #[msg("FailedToDeserializePhoenixMarket")]
    FailedToDeserializePhoenixMarket,
    #[msg("InvalidPricePrecision")]
    InvalidPricePrecision,
    #[msg("InvalidPhoenixProgram")]
    InvalidPhoenixProgram,
    #[msg("InvalidPhoenixMarket")]
    InvalidPhoenixMarket,
    #[msg("InvalidSwap")]
    InvalidSwap,
    #[msg("SwapLimitPriceBreached")]
    SwapLimitPriceBreached,
    #[msg("SpotMarketReduceOnly")]
    SpotMarketReduceOnly,
    #[msg("FundingWasNotUpdated")]
    FundingWasNotUpdated,
    #[msg("ImpossibleFill")]
    ImpossibleFill,
    #[msg("CantUpdatePerpBidAskTwap")]
    CantUpdatePerpBidAskTwap,
    #[msg("UserReduceOnly")]
    UserReduceOnly,
    #[msg("InvalidMarginCalculation")]
    InvalidMarginCalculation,
    #[msg("CantPayUserInitFee")]
    CantPayUserInitFee,
    #[msg("CantReclaimRent")]
    CantReclaimRent,
    #[msg("InsuranceFundOperationPaused")]
    InsuranceFundOperationPaused,
    #[msg("NoUnsettledPnl")]
    NoUnsettledPnl,
    #[msg("PnlPoolCantSettleUser")]
    PnlPoolCantSettleUser,
    #[msg("OracleInvalid")]
    OracleNonPositive,
    #[msg("OracleTooVolatile")]
    OracleTooVolatile,
    #[msg("OracleTooUncertain")]
    OracleTooUncertain,
    #[msg("OracleStaleForMargin")]
    OracleStaleForMargin,
    #[msg("OracleInsufficientDataPoints")]
    OracleInsufficientDataPoints,
    #[msg("OracleStaleForAMM")]
    OracleStaleForAMM,
    #[msg("Unable to parse pull oracle message")]
    UnableToParsePullOracleMessage,
    #[msg("Can not borow more than max borrows")]
    MaxBorrows,
    #[msg("Updates must be monotonically increasing")]
    OracleUpdatesNotMonotonic,
    #[msg("Trying to update price feed with the wrong feed id")]
    OraclePriceFeedMessageMismatch,
    #[msg("The message in the update must be a PriceFeedMessage")]
    OracleUnsupportedMessageType,
    #[msg("Could not deserialize the message in the update")]
    OracleDeserializeMessageFailed,
    #[msg("Wrong guardian set owner in update price atomic")]
    OracleWrongGuardianSetOwner,
    #[msg("Oracle post update atomic price feed account must be drift program")]
    OracleWrongWriteAuthority,
    #[msg("Oracle vaa owner must be wormhole program")]
    OracleWrongVaaOwner,
    #[msg("Multi updates must have 2 or fewer accounts passed in remaining accounts")]
    OracleTooManyPriceAccountUpdates,
    #[msg("Don't have the same remaining accounts number and pyth updates left")]
    OracleMismatchedVaaAndPriceUpdates,
    #[msg("Remaining account passed does not match oracle update derived pda")]
    OracleBadRemainingAccountPublicKey,
    #[msg("FailedOpenbookV2CPI")]
    FailedOpenbookV2CPI,
    #[msg("InvalidOpenbookV2Program")]
    InvalidOpenbookV2Program,
    #[msg("InvalidOpenbookV2Market")]
    InvalidOpenbookV2Market,
    #[msg("Non zero transfer fee")]
    NonZeroTransferFee,
    #[msg("Liquidation order failed to fill")]
    LiquidationOrderFailedToFill,
    #[msg("Invalid prediction market order")]
    InvalidPredictionMarketOrder,
    #[msg("Ed25519 Ix must be before place and make SignedMsg order ix")]
    InvalidVerificationIxIndex,
    #[msg("SignedMsg message verificaiton failed")]
    SigVerificationFailed,
    #[msg("Market index mismatched b/w taker and maker SignedMsg order params")]
    MismatchedSignedMsgOrderParamsMarketIndex,
    #[msg("Invalid SignedMsg order param")]
    InvalidSignedMsgOrderParam,
    #[msg("Place and take order success condition failed")]
    PlaceAndTakeOrderSuccessConditionFailed,
    #[msg("Invalid High Leverage Mode Config")]
    InvalidHighLeverageModeConfig,
    #[msg("Invalid RFQ User Account")]
    InvalidRFQUserAccount,
    #[msg("RFQUserAccount should be mutable")]
    RFQUserAccountWrongMutability,
    #[msg("RFQUserAccount has too many active RFQs")]
    RFQUserAccountFull,
    #[msg("RFQ order not filled as expected")]
    RFQOrderNotFilled,
    #[msg("RFQ orders must be jit makers")]
    InvalidRFQOrder,
    #[msg("RFQ matches must be valid")]
    InvalidRFQMatch,
    #[msg("Invalid SignedMsg user account")]
    InvalidSignedMsgUserAccount,
    #[msg("SignedMsg account wrong mutability")]
    SignedMsgUserAccountWrongMutability,
    #[msg("SignedMsgUserAccount has too many active orders")]
    SignedMsgUserOrdersAccountFull,
    #[msg("Order with SignedMsg uuid does not exist")]
    SignedMsgOrderDoesNotExist,
    #[msg("SignedMsg order id cannot be 0s")]
    InvalidSignedMsgOrderId,
    #[msg("Invalid pool id")]
    InvalidPoolId,
    #[msg("Invalid Protected Maker Mode Config")]
    InvalidProtectedMakerModeConfig,
    #[msg("Invalid pyth lazer storage owner")]
    InvalidPythLazerStorageOwner,
    #[msg("Verification of pyth lazer message failed")]
    UnverifiedPythLazerMessage,
    #[msg("Invalid pyth lazer message")]
    InvalidPythLazerMessage,
    #[msg("Pyth lazer message does not correspond to correct fed id")]
    PythLazerMessagePriceFeedMismatch,
    #[msg("InvalidLiquidateSpotWithSwap")]
    InvalidLiquidateSpotWithSwap,
    #[msg("User in SignedMsg message does not match user in ix context")]
    SignedMsgUserContextUserMismatch,
    #[msg("User fuel overflow threshold not met")]
    UserFuelOverflowThresholdNotMet,
    #[msg("FuelOverflow account not found")]
    FuelOverflowAccountNotFound,
    #[msg("Invalid Transfer Perp Position")]
    InvalidTransferPerpPosition,
    #[msg("Invalid SignedMsgUserOrders resize")]
    InvalidSignedMsgUserOrdersResize,
    #[msg("Could not deserialize high leverage mode config")]
    CouldNotDeserializeHighLeverageModeConfig,
    #[msg("Invalid If Rebalance Config")]
    InvalidIfRebalanceConfig,
    #[msg("Invalid If Rebalance Swap")]
    InvalidIfRebalanceSwap,
    #[msg("Invalid RevenueShare resize")]
    InvalidRevenueShareResize,
    #[msg("Builder has been revoked")]
    BuilderRevoked,
    #[msg("Builder fee is greater than max fee bps")]
    InvalidBuilderFee,
    #[msg("RevenueShareEscrow authority mismatch")]
    RevenueShareEscrowAuthorityMismatch,
    #[msg("RevenueShareEscrow has too many active orders")]
    RevenueShareEscrowOrdersAccountFull,
    #[msg("Invalid RevenueShareAccount")]
    InvalidRevenueShareAccount,
    #[msg("Cannot revoke builder with open orders")]
    CannotRevokeBuilderWithOpenOrders,
    #[msg("Unable to load builder account")]
    UnableToLoadRevenueShareAccount,
}

#[macro_export]
macro_rules! print_error {
    ($err:expr) => {{
        || {
            let error_code: ErrorCode = $err;
            msg!("{:?} thrown at {}:{}", error_code, file!(), line!());
            $err
        }
    }};
}

#[macro_export]
macro_rules! math_error {
    () => {{
        || {
            let error_code = $crate::error::ErrorCode::MathError;
            msg!("Error {} thrown at {}:{}", error_code, file!(), line!());
            error_code
        }
    }};
}



================================================
FILE: programs/drift/src/ids.rs
================================================
pub mod pyth_program {
    use solana_program::declare_id;
    #[cfg(feature = "mainnet-beta")]
    declare_id!("FsJ3A3u2vn5cTVofAjvy6y5kwABJAqYWpe4975bi2epH");
    #[cfg(not(feature = "mainnet-beta"))]
    declare_id!("gSbePebfvPy7tRqimPoVecS2UsBvYv46ynrzWocc92s");
}

pub mod wormhole_program {
    use solana_program::declare_id;
    declare_id!("HDwcJBJXjL9FpJ7UBsYBtaDjsBUhuLCUYoz3zr8SWWaQ");
}

pub mod drift_oracle_receiver_program {
    use solana_program::declare_id;
    declare_id!("G6EoTTTgpkNBtVXo96EQp2m6uwwVh2Kt6YidjkmQqoha");
}

pub mod pyth_lazer_program {
    use solana_program::declare_id;
    declare_id!("pytd2yyk641x7ak7mkaasSJVXh6YYZnC7wTmtgAyxPt");
}

pub mod switchboard_program {
    use solana_program::declare_id;
    declare_id!("SW1TCH7qEPTdLsDHRgPuMQjbQxKdH2aBStViMFnt64f");
}

pub mod switchboard_on_demand {
    use solana_program::declare_id;
    #[cfg(feature = "mainnet-beta")]
    declare_id!("SBondMDrcV3K4kxZR1HNVT7osZxAHVHgYXL5Ze1oMUv");
    #[cfg(not(feature = "mainnet-beta"))]
    declare_id!("Aio4gaXjXzJNVLtzwtNVmSqGKpANtXhybbkhtAC94ji2");
}

pub mod serum_program {
    use solana_program::declare_id;
    #[cfg(feature = "mainnet-beta")]
    declare_id!("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX");
    #[cfg(not(feature = "mainnet-beta"))]
    declare_id!("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY");
}

pub mod srm_mint {
    use solana_program::declare_id;
    declare_id!("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt");
}

pub mod msrm_mint {
    use solana_program::declare_id;
    declare_id!("MSRMcoVyrFxnSgo5uXwone5SKcGhT1KEJMFEkMEWf9L");
}

pub mod jupiter_mainnet_6 {
    use solana_program::declare_id;
    declare_id!("JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4");
}
pub mod jupiter_mainnet_4 {
    use solana_program::declare_id;
    declare_id!("JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB");
}
pub mod jupiter_mainnet_3 {
    use solana_program::declare_id;
    declare_id!("JUP3c2Uh3WA4Ng34tw6kPd2G4C5BB21Xo36Je1s32Ph");
}

pub mod marinade_mainnet {
    use solana_program::declare_id;
    declare_id!("MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD");
}

pub mod admin_hot_wallet {
    use solana_program::declare_id;
    #[cfg(not(feature = "anchor-test"))]
    declare_id!("5hMjmxexWu954pX9gB9jkHxMqdjpxArQS2XdvkaevRax");
    #[cfg(feature = "anchor-test")]
    declare_id!("1ucYHAGrBbi1PaecC4Ptq5ocZLWGLBmbGWysoDGNB1N");
}

pub mod if_rebalance_wallet {
    use solana_program::declare_id;
    declare_id!("BuynBZjr5yiZCFpXngFQ31BAwechmFE1Ab6vNP3f5PTt");
}

pub mod lighthouse {
    use solana_program::declare_id;
    declare_id!("L2TExMFKdjpN9kozasaurPirfHy9P8sbXoAN1qA3S95");
}

pub mod mm_oracle_crank_wallet {
    use solana_program::declare_id;
    #[cfg(not(feature = "anchor-test"))]
    #[cfg(feature = "mainnet-beta")]
    declare_id!("uZ1N4C9dc71Euu4GLYt5UURpFtg1WWSwo3F4Rn46Fr3");
    #[cfg(not(feature = "anchor-test"))]
    #[cfg(not(feature = "mainnet-beta"))]
    declare_id!("8X35rQUK2u9hfn8rMPwwr6ZSEUhbmfDPEapp589XyoM1");
    #[cfg(feature = "anchor-test")]
    declare_id!("1ucYHAGrBbi1PaecC4Ptq5ocZLWGLBmbGWysoDGNB1N");
}

pub mod amm_spread_adjust_wallet {
    use solana_program::declare_id;
    #[cfg(not(feature = "anchor-test"))]
    declare_id!("w1DrTeayRMutAiwzfJfK9zLcpkF7RzwPy1BLCgQA1aF");
    #[cfg(feature = "anchor-test")]
    declare_id!("1ucYHAGrBbi1PaecC4Ptq5ocZLWGLBmbGWysoDGNB1N");
}

pub mod dflow_mainnet_aggregator_4 {
    use solana_program::declare_id;
    declare_id!("DF1ow4tspfHX9JwWJsAb9epbkA8hmpSEAtxXy1V27QBH");
}

pub mod titan_mainnet_argos_v1 {
    use solana_program::declare_id;
    declare_id!("T1TANpTeScyeqVzzgNViGDNrkQ6qHz9KrSBS4aNXvGT");
}



================================================
FILE: programs/drift/src/macros.rs
================================================
#[macro_export]
macro_rules! get_struct_values {
    ($struct:expr, $($property: ident),+) => {{
        ($(
            $struct.$property,
        )+)
    }};
}

#[macro_export]
macro_rules! get_then_update_id {
    ($struct:expr, $property: ident) => {{
        let current_id = $struct.$property;
        $struct.$property = current_id.checked_add(1).or(Some(1)).unwrap();
        current_id
    }};
}

#[macro_export]
macro_rules! validate {
        ($assert:expr, $err:expr) => {{
            if ($assert) {
                Ok(())
            } else {
                let error_code: ErrorCode = $err;
                msg!("Error {} thrown at {}:{}", error_code, file!(), line!());
                Err(error_code)
            }
        }};
        ($assert:expr, $err:expr, $($arg:tt)+) => {{
        if ($assert) {
            Ok(())
        } else {
            let error_code: ErrorCode = $err;
            msg!("Error {} thrown at {}:{}", error_code, file!(), line!());
            msg!($($arg)*);
            Err(error_code)
        }
    }};
}

#[macro_export]
macro_rules! dlog {
    ($($variable: expr),+) => {{
        $(
            msg!("{}: {}", stringify!($variable), $variable);
        )+
    }};
    ($($arg:tt)+) => {{
            #[cfg(not(feature = "mainnet-beta"))]
            msg!($($arg)+);
    }};
}

#[macro_export]
macro_rules! load_mut {
    ($account_loader:expr) => {{
        $account_loader.load_mut().map_err(|e| {
            msg!("e {:?}", e);
            let error_code = ErrorCode::UnableToLoadAccountLoader;
            msg!("Error {} thrown at {}:{}", error_code, file!(), line!());
            error_code
        })
    }};
}

#[macro_export]
macro_rules! load {
    ($account_loader:expr) => {{
        $account_loader.load().map_err(|_| {
            let error_code = ErrorCode::UnableToLoadAccountLoader;
            msg!("Error {} thrown at {}:{}", error_code, file!(), line!());
            error_code
        })
    }};
}

#[macro_export]
macro_rules! safe_increment {
    ($struct:expr, $value:expr) => {{
        $struct = $struct.checked_add($value).ok_or_else(math_error!())?
    }};
}

#[macro_export]
macro_rules! safe_decrement {
    ($struct:expr, $value:expr) => {{
        $struct = $struct.checked_sub($value).ok_or_else(math_error!())?
    }};
}

/// Calculate the sha256 digest of anchor encoded `struct`
#[macro_export]
macro_rules! digest_struct {
    ($struct:expr) => {
        solana_program::hash::hash(&$struct.try_to_vec().unwrap()).to_bytes()
    };
}

/// Calculate the hexified sha256 digest of anchor encoded `struct`
#[macro_export]
macro_rules! digest_struct_hex {
    ($struct:expr) => {{
        hex::encode(digest_struct!($struct)).into_bytes()
    }};
}

/// same as `solana_program::msg!` but it can compile away for off-chain use
#[macro_export]
macro_rules! msg {
    ($msg:expr) => {
        #[cfg(not(feature = "drift-rs"))]
        solana_program::msg!($msg)
    };
    ($($arg:tt)*) => {
        #[cfg(not(feature = "drift-rs"))]
        (solana_program::msg!(&format!($($arg)*)));
    }
}

#[macro_export]
macro_rules! compute_fn {
    ($msg:expr=> $($tt:tt)*) => {
        ::solana_program::msg!(concat!($msg, " {"));
        ::solana_program::log::sol_log_compute_units();
        let res = { $($tt)* };
        ::solana_program::log::sol_log_compute_units();
        ::solana_program::msg!(concat!(" } // ", $msg));
        res
    };
}



================================================
FILE: programs/drift/src/signer.rs
================================================
pub fn get_signer_seeds(nonce: &u8) -> [&[u8]; 2] {
    [b"drift_signer".as_ref(), bytemuck::bytes_of(nonce)]
}



================================================
FILE: programs/drift/src/test_utils.rs
================================================
use anchor_lang::prelude::{AccountInfo, Pubkey};
use anchor_lang::{Owner, ZeroCopy};
use bytes::BytesMut;

use pyth::pc::Price;

use crate::state::user::{Order, PerpPosition, SpotPosition};

pub fn get_positions(position: PerpPosition) -> [PerpPosition; 8] {
    let mut positions = [PerpPosition::default(); 8];
    positions[0] = position;
    positions
}

pub fn get_orders(order: Order) -> [Order; 32] {
    let mut orders = [Order::default(); 32];
    orders[0] = order;
    orders
}

#[macro_export]
macro_rules! get_orders {
    ($($order: expr),+) => {
        {
            let mut orders = [Order::default(); 32];
            let mut index = 0;
            $(
                index += 1;
                orders[index - 1] = $order;
            )+
            orders
        }
    };
}

pub fn get_spot_positions(spot_position: SpotPosition) -> [SpotPosition; 8] {
    let mut spot_positions = [SpotPosition::default(); 8];
    if spot_position.market_index == 0 {
        spot_positions[0] = spot_position;
    } else {
        spot_positions[1] = spot_position;
    }
    spot_positions
}

pub fn get_account_bytes<T: bytemuck::Pod>(account: &mut T) -> BytesMut {
    let mut bytes = BytesMut::new();
    let data = bytemuck::bytes_of_mut(account);
    bytes.extend_from_slice(data);
    bytes
}

pub fn get_anchor_account_bytes<T: ZeroCopy + Owner>(account: &mut T) -> BytesMut {
    let mut bytes = BytesMut::new();
    bytes.extend_from_slice(&T::discriminator());
    let data = bytemuck::bytes_of_mut(account);
    bytes.extend_from_slice(data);
    bytes
}

pub fn create_account_info<'a>(
    key: &'a Pubkey,
    is_writable: bool,
    lamports: &'a mut u64,
    bytes: &'a mut [u8],
    owner: &'a Pubkey,
) -> AccountInfo<'a> {
    AccountInfo::new(key, false, is_writable, lamports, bytes, owner, false, 0)
}

pub fn get_pyth_price(price: i64, expo: i32) -> Price {
    let mut pyth_price = Price::default();
    let price = price * 10_i64.pow(expo as u32);
    pyth_price.agg.price = price;
    pyth_price.twap = price;
    pyth_price.expo = expo;
    pyth_price
}

pub fn get_hardcoded_pyth_price(price: i64, expo: i32) -> Price {
    let mut pyth_price = Price::default();
    pyth_price.agg.price = price;
    pyth_price.twap = price;
    pyth_price.expo = expo;
    pyth_price
}

#[macro_export]
macro_rules! create_anchor_account_info {
    ($account:expr, $type:ident, $name: ident) => {
        let key = Pubkey::default();
        let mut lamports = 0;
        let mut data = get_anchor_account_bytes(&mut $account);
        let owner = $type::owner();
        let $name = create_account_info(&key, true, &mut lamports, &mut data[..], &owner);
    };
    ($account:expr, $pubkey:expr, $type:ident, $name: ident) => {
        let mut lamports = 0;
        let mut data = get_anchor_account_bytes(&mut $account);
        let owner = $type::owner();
        let $name = create_account_info($pubkey, true, &mut lamports, &mut data[..], &owner);
    };
}

#[macro_export]
macro_rules! create_account_info {
    ($account:expr, $owner:expr, $name: ident) => {
        let key = Pubkey::default();
        let mut lamports = 0;
        let mut data = get_account_bytes(&mut $account);
        let owner = $type::owner();
        let $name = create_account_info(&key, true, &mut lamports, &mut data[..], $owner);
    };
    ($account:expr, $pubkey:expr, $owner:expr, $name: ident) => {
        let mut lamports = 0;
        let mut data = get_account_bytes(&mut $account);
        let $name = create_account_info($pubkey, true, &mut lamports, &mut data[..], $owner);
    };
}



================================================
FILE: programs/drift/src/controller/amm.rs
================================================
use std::cmp::{max, min, Ordering};

use crate::msg;
use anchor_lang::prelude::*;

use crate::controller::position::PositionDirection;
use crate::controller::repeg::apply_cost_to_market;
use crate::controller::spot_balance::{
    transfer_revenue_pool_to_spot_balance, transfer_spot_balance_to_revenue_pool,
    transfer_spot_balances, update_spot_balances,
};
use crate::error::{DriftResult, ErrorCode};
use crate::get_then_update_id;
use crate::math::amm::{calculate_net_user_pnl, calculate_quote_asset_amount_swapped};
use crate::math::amm_spread::{calculate_spread_reserves, get_spread_reserves};
use crate::math::casting::Cast;
use crate::math::constants::{
    CONCENTRATION_PRECISION, FEE_POOL_TO_REVENUE_POOL_THRESHOLD, K_BPS_UPDATE_SCALE,
    MAX_CONCENTRATION_COEFFICIENT, MAX_K_BPS_INCREASE, MAX_SQRT_K,
};
use crate::math::cp_curve::get_update_k_result;
use crate::math::repeg::get_total_fee_lower_bound;
use crate::math::safe_math::SafeMath;
use crate::math::spot_balance::get_token_amount;
use crate::math::spot_withdraw::{
    get_max_withdraw_for_market_with_token_amount, validate_spot_balances,
};
use crate::math::{amm, amm_spread, bn, cp_curve, quote_asset::*};

use crate::state::events::CurveRecord;
use crate::state::oracle::OraclePriceData;
use crate::state::perp_market::{PerpMarket, AMM};
use crate::state::spot_market::{SpotBalance, SpotBalanceType, SpotMarket};
use crate::state::user::{SpotPosition, User};
use crate::validate;

#[cfg(test)]
mod tests;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SwapDirection {
    Add,
    Remove,
}

fn calculate_quote_asset_amount_surplus(
    quote_asset_reserve_before: u128,
    quote_asset_reserve_after: u128,
    swap_direction: SwapDirection,
    peg_multiplier: u128,
    initial_quote_asset_amount: u128,
    round_down: bool,
) -> DriftResult<u128> {
    let quote_asset_reserve_change = match swap_direction {
        SwapDirection::Add => quote_asset_reserve_before.safe_sub(quote_asset_reserve_after)?,

        SwapDirection::Remove => quote_asset_reserve_after.safe_sub(quote_asset_reserve_before)?,
    };

    let mut actual_quote_asset_amount =
        reserve_to_asset_amount(quote_asset_reserve_change, peg_multiplier)?;

    // Compensate for +1 quote asset amount added when removing base asset
    if round_down {
        actual_quote_asset_amount = actual_quote_asset_amount.safe_add(1)?;
    }

    let quote_asset_amount_surplus = if actual_quote_asset_amount > initial_quote_asset_amount {
        actual_quote_asset_amount.safe_sub(initial_quote_asset_amount)?
    } else {
        initial_quote_asset_amount.safe_sub(actual_quote_asset_amount)?
    };

    Ok(quote_asset_amount_surplus)
}

pub fn swap_base_asset(
    market: &mut PerpMarket,
    base_asset_swap_amount: u64,
    direction: SwapDirection,
) -> DriftResult<(u64, i64)> {
    let (
        new_base_asset_reserve,
        new_quote_asset_reserve,
        quote_asset_amount,
        quote_asset_amount_surplus,
    ) = calculate_base_swap_output_with_spread(&market.amm, base_asset_swap_amount, direction)?;

    market.amm.base_asset_reserve = new_base_asset_reserve;
    market.amm.quote_asset_reserve = new_quote_asset_reserve;

    Ok((
        quote_asset_amount,
        quote_asset_amount_surplus.cast::<i64>()?,
    ))
}

pub fn calculate_base_swap_output_with_spread(
    amm: &AMM,
    base_asset_swap_amount: u64,
    direction: SwapDirection,
) -> DriftResult<(u128, u128, u64, u64)> {
    // first do the swap with spread reserves to figure out how much base asset is acquired
    let (base_asset_reserve_with_spread, quote_asset_reserve_with_spread) = get_spread_reserves(
        amm,
        match direction {
            SwapDirection::Add => PositionDirection::Short,
            SwapDirection::Remove => PositionDirection::Long,
        },
    )?;

    let (new_quote_asset_reserve_with_spread, _) = amm::calculate_swap_output(
        base_asset_swap_amount.cast()?,
        base_asset_reserve_with_spread,
        direction,
        amm.sqrt_k,
    )?;

    let quote_asset_amount = calculate_quote_asset_amount_swapped(
        quote_asset_reserve_with_spread,
        new_quote_asset_reserve_with_spread,
        direction,
        amm.peg_multiplier,
    )?;

    let (new_quote_asset_reserve, new_base_asset_reserve) = amm::calculate_swap_output(
        base_asset_swap_amount.cast()?,
        amm.base_asset_reserve,
        direction,
        amm.sqrt_k,
    )?;

    // calculate the quote asset surplus by taking the difference between what quote_asset_amount is
    // with and without spread
    let quote_asset_amount_surplus = calculate_quote_asset_amount_surplus(
        new_quote_asset_reserve,
        amm.quote_asset_reserve,
        match direction {
            SwapDirection::Remove => SwapDirection::Add,
            SwapDirection::Add => SwapDirection::Remove,
        },
        amm.peg_multiplier,
        quote_asset_amount,
        direction == SwapDirection::Remove,
    )?;

    Ok((
        new_base_asset_reserve,
        new_quote_asset_reserve,
        quote_asset_amount.cast::<u64>()?,
        quote_asset_amount_surplus.cast::<u64>()?,
    ))
}

pub fn update_spread_reserves(market: &mut PerpMarket) -> DriftResult {
    let (new_ask_base_asset_reserve, new_ask_quote_asset_reserve) =
        calculate_spread_reserves(market, PositionDirection::Long)?;
    let (new_bid_base_asset_reserve, new_bid_quote_asset_reserve) =
        calculate_spread_reserves(market, PositionDirection::Short)?;

    if market.amm.reference_price_offset == 0 {
        market.amm.ask_base_asset_reserve =
            new_ask_base_asset_reserve.min(market.amm.base_asset_reserve);
        market.amm.bid_base_asset_reserve =
            new_bid_base_asset_reserve.max(market.amm.base_asset_reserve);
        market.amm.ask_quote_asset_reserve =
            new_ask_quote_asset_reserve.max(market.amm.quote_asset_reserve);
        market.amm.bid_quote_asset_reserve =
            new_bid_quote_asset_reserve.min(market.amm.quote_asset_reserve);
    } else {
        market.amm.ask_base_asset_reserve = new_ask_base_asset_reserve;
        market.amm.bid_base_asset_reserve = new_bid_base_asset_reserve;
        market.amm.ask_quote_asset_reserve = new_ask_quote_asset_reserve;
        market.amm.bid_quote_asset_reserve = new_bid_quote_asset_reserve;
    }

    Ok(())
}

pub fn update_spreads(
    market: &mut PerpMarket,
    reserve_price: u64,
    slot: Option<u64>,
) -> DriftResult<(u32, u32)> {
    let max_ref_offset = market.amm.get_max_reference_price_offset()?;

    let reference_price_offset = if max_ref_offset > 0 {
        let liquidity_ratio =
            amm_spread::calculate_inventory_liquidity_ratio_for_reference_price_offset(
                market.amm.base_asset_amount_with_amm,
                market.amm.base_asset_reserve,
                market.amm.min_base_asset_reserve,
                market.amm.max_base_asset_reserve,
            )?;

        let signed_liquidity_ratio =
            liquidity_ratio.safe_mul(market.amm.get_protocol_owned_position()?.signum().cast()?)?;

        let deadband_pct = market.amm.get_reference_price_offset_deadband_pct()?;
        let liquidity_fraction_after_deadband =
            if signed_liquidity_ratio.unsigned_abs() <= deadband_pct {
                0
            } else {
                signed_liquidity_ratio.safe_sub(
                    deadband_pct
                        .cast::<i128>()?
                        .safe_mul(signed_liquidity_ratio.signum())?,
                )?
            };

        amm_spread::calculate_reference_price_offset(
            reserve_price,
            market.amm.last_24h_avg_funding_rate,
            liquidity_fraction_after_deadband,
            market.amm.min_order_size,
            market
                .amm
                .historical_oracle_data
                .last_oracle_price_twap_5min,
            market.amm.last_mark_price_twap_5min,
            market.amm.historical_oracle_data.last_oracle_price_twap,
            market.amm.last_mark_price_twap,
            max_ref_offset,
        )?
    } else {
        0
    };

    let (mut long_spread, mut short_spread) = if market.amm.curve_update_intensity > 0 {
        amm_spread::calculate_spread(
            market.amm.base_spread,
            market.amm.last_oracle_reserve_price_spread_pct,
            market.amm.last_oracle_conf_pct,
            market.amm.max_spread,
            market.amm.quote_asset_reserve,
            market.amm.terminal_quote_asset_reserve,
            market.amm.peg_multiplier,
            market.amm.base_asset_amount_with_amm,
            reserve_price,
            market.amm.total_fee_minus_distributions,
            market.amm.net_revenue_since_last_funding,
            market.amm.base_asset_reserve,
            market.amm.min_base_asset_reserve,
            market.amm.max_base_asset_reserve,
            market.amm.mark_std,
            market.amm.oracle_std,
            market.amm.long_intensity_volume,
            market.amm.short_intensity_volume,
            market.amm.volume_24h,
            market.amm.amm_inventory_spread_adjustment,
        )?
    } else {
        let half_base_spread = market.amm.base_spread.safe_div(2)?;
        (half_base_spread, half_base_spread)
    };

    if market.amm.amm_spread_adjustment < 0 {
        let adjustment = market.amm.amm_spread_adjustment.unsigned_abs().cast()?;
        long_spread = long_spread
            .saturating_sub(long_spread.saturating_mul(adjustment).safe_div(100)?)
            .max(1);
        short_spread = short_spread
            .saturating_sub(short_spread.saturating_mul(adjustment).safe_div(100)?)
            .max(1);
    } else if market.amm.amm_spread_adjustment > 0 {
        let adjustment = market.amm.amm_spread_adjustment.cast()?;
        long_spread = long_spread
            .saturating_add(long_spread.saturating_mul(adjustment).safe_div_ceil(100)?)
            .max(1);
        short_spread = short_spread
            .saturating_add(short_spread.saturating_mul(adjustment).safe_div_ceil(100)?)
            .max(1);
    }

    market.amm.long_spread = long_spread;
    market.amm.short_spread = short_spread;

    let do_reference_price_smooth = {
        let sign_changed: bool =
            reference_price_offset.signum() != market.amm.reference_price_offset.signum();

        sign_changed && market.amm.curve_update_intensity > 100
    };

    if do_reference_price_smooth {
        let slots_passed = slot.map_or(0, |s| s.saturating_sub(market.amm.last_update_slot));

        let reference_price_delta = {
            let full_offset_delta = reference_price_offset
                .cast::<i128>()?
                .saturating_sub(market.amm.reference_price_offset.cast::<i128>()?);
            let raw = full_offset_delta
                .abs()
                .cast::<i128>()?
                .min(slots_passed.cast::<i128>()?.safe_mul(1000)?)
                .cast::<i128>()?
                .safe_div(10_i128)?
                .cast::<i32>()?;

            full_offset_delta.signum().cast::<i32>()?
                * (raw.max(10).min(if market.amm.reference_price_offset != 0 {
                    market.amm.reference_price_offset.abs()
                } else {
                    reference_price_offset.abs()
                }))
        };

        market.amm.reference_price_offset = market
            .amm
            .reference_price_offset
            .safe_add(reference_price_delta)?;

        if reference_price_delta < 0 {
            market.amm.long_spread = market
                .amm
                .long_spread
                .safe_add(reference_price_delta.unsigned_abs())?;
            market.amm.short_spread = market
                .amm
                .short_spread
                .safe_add(market.amm.reference_price_offset.unsigned_abs())?;
        } else {
            market.amm.short_spread = market
                .amm
                .short_spread
                .safe_add(reference_price_delta.unsigned_abs())?;
            market.amm.long_spread = market
                .amm
                .long_spread
                .safe_add(market.amm.reference_price_offset.unsigned_abs())?;
        }
    } else {
        market.amm.reference_price_offset = reference_price_offset;
    }

    update_spread_reserves(market)?;

    Ok((long_spread, short_spread))
}

pub fn update_concentration_coef(market: &mut PerpMarket, scale: u128) -> DriftResult {
    validate!(
        scale > 0,
        ErrorCode::InvalidConcentrationCoef,
        "invalid scale",
    )?;

    let new_concentration_coef =
        CONCENTRATION_PRECISION + (MAX_CONCENTRATION_COEFFICIENT - CONCENTRATION_PRECISION) / scale;

    validate!(
        new_concentration_coef > CONCENTRATION_PRECISION
            && new_concentration_coef <= MAX_CONCENTRATION_COEFFICIENT,
        ErrorCode::InvalidConcentrationCoef,
        "invalid new_concentration_coef",
    )?;

    market.amm.concentration_coef = new_concentration_coef;

    let (_, terminal_quote_reserves, terminal_base_reserves) =
        amm::calculate_terminal_price_and_reserves(&market.amm)?;

    validate!(
        terminal_quote_reserves == market.amm.terminal_quote_asset_reserve,
        ErrorCode::InvalidAmmDetected,
        "invalid terminal_quote_reserves",
    )?;

    // updating the concentration_coef changes the min/max base_asset_reserve
    // doing so adds ability to improve amm constant product curve's slippage
    // by increasing k as same factor as scale w/o increasing imbalance risk
    let (min_base_asset_reserve, max_base_asset_reserve) =
        amm::calculate_bid_ask_bounds(market.amm.concentration_coef, terminal_base_reserves)?;

    market.amm.max_base_asset_reserve = max_base_asset_reserve;
    market.amm.min_base_asset_reserve = min_base_asset_reserve;

    let reserve_price_after = market.amm.reserve_price()?;
    update_spreads(market, reserve_price_after, None)?;

    let (max_bids, max_asks) = amm::calculate_market_open_bids_asks(&market.amm)?;
    validate!(
        max_bids > market.amm.base_asset_amount_with_amm && max_asks < market.amm.base_asset_amount_with_amm,
        ErrorCode::InvalidConcentrationCoef,
        "amm.base_asset_amount_with_amm exceeds the unload liquidity available after concentration adjustment"
    )?;

    Ok(())
}

pub fn formulaic_update_k(
    market: &mut PerpMarket,
    _oracle_price_data: &OraclePriceData,
    funding_imbalance_cost: i128,
    now: i64,
) -> DriftResult {
    let peg_multiplier_before = market.amm.peg_multiplier;
    let base_asset_reserve_before = market.amm.base_asset_reserve;
    let quote_asset_reserve_before = market.amm.quote_asset_reserve;
    let sqrt_k_before = market.amm.sqrt_k;

    let funding_imbalance_cost_i64 = funding_imbalance_cost.cast::<i64>()?;

    // calculate budget
    let budget = if funding_imbalance_cost_i64 < 0 {
        // negative cost is period revenue, if spread is low give back half in k increase
        if max(market.amm.long_spread, market.amm.short_spread) <= market.amm.base_spread {
            funding_imbalance_cost_i64.safe_div(2)?.abs()
        } else {
            0
        }
    } else if market.amm.net_revenue_since_last_funding < funding_imbalance_cost_i64 {
        // cost exceeded period revenue, take back half in k decrease
        max(0, market.amm.net_revenue_since_last_funding)
            .safe_sub(funding_imbalance_cost_i64)?
            .safe_div(2)?
    } else {
        0
    };

    if (budget > 0 && market.amm.sqrt_k < MAX_SQRT_K) || (budget < 0 && market.amm.can_lower_k()?) {
        // single k scale is capped by .1% increase and .1% decrease (regardless of budget)
        let k_pct_upper_bound = K_BPS_UPDATE_SCALE
            + MAX_K_BPS_INCREASE * (market.amm.curve_update_intensity as i128) / 100;
        let k_pct_lower_bound = K_BPS_UPDATE_SCALE
            - MAX_K_BPS_INCREASE * (market.amm.curve_update_intensity as i128) / 100;

        let (k_scale_numerator, k_scale_denominator) = cp_curve::calculate_budgeted_k_scale(
            market,
            budget.cast::<i128>()?,
            k_pct_upper_bound,
            k_pct_lower_bound,
        )?;

        let new_sqrt_k = bn::U192::from(market.amm.sqrt_k)
            .safe_mul(bn::U192::from(k_scale_numerator))?
            .safe_div(bn::U192::from(k_scale_denominator))?;

        let update_k_result = get_update_k_result(market, new_sqrt_k, true)?;

        let adjustment_cost = cp_curve::adjust_k_cost(market, &update_k_result)?;

        let cost_applied = apply_cost_to_market(market, adjustment_cost, true)?;

        if cost_applied {
            cp_curve::update_k(market, &update_k_result)?;

            let peg_multiplier_after = market.amm.peg_multiplier;
            let base_asset_reserve_after = market.amm.base_asset_reserve;
            let quote_asset_reserve_after = market.amm.quote_asset_reserve;
            let sqrt_k_after = market.amm.sqrt_k;

            emit!(CurveRecord {
                ts: now,
                record_id: get_then_update_id!(market, next_curve_record_id),
                market_index: market.market_index,
                peg_multiplier_before,
                base_asset_reserve_before,
                quote_asset_reserve_before,
                sqrt_k_before,
                peg_multiplier_after,
                base_asset_reserve_after,
                quote_asset_reserve_after,
                sqrt_k_after,
                base_asset_amount_long: market.amm.base_asset_amount_long.unsigned_abs(),
                base_asset_amount_short: market.amm.base_asset_amount_short.unsigned_abs(),
                base_asset_amount_with_amm: market.amm.base_asset_amount_with_amm,
                number_of_users: market.number_of_users,
                adjustment_cost,
                total_fee: market.amm.total_fee,
                total_fee_minus_distributions: market.amm.total_fee_minus_distributions,
                oracle_price: market.amm.historical_oracle_data.last_oracle_price,
                fill_record: market.next_fill_record_id as u128,
            });
        }
    }
    Ok(())
}

pub fn get_fee_pool_tokens(
    perp_market: &mut PerpMarket,
    spot_market: &mut SpotMarket,
) -> DriftResult<i128> {
    get_token_amount(
        perp_market.amm.fee_pool.balance(),
        spot_market,
        perp_market.amm.fee_pool.balance_type(),
    )?
    .cast()
}

fn calculate_revenue_pool_transfer(
    market: &PerpMarket,
    spot_market: &SpotMarket,
    amm_fee_pool_token_amount_after: u128,
    terminal_state_surplus: i128,
) -> DriftResult<i128> {
    // Calculates the revenue pool transfer amount for a given market state (positive = send to revenue pool, negative = pull from revenue pool)
    // If the AMM budget is above `FEE_POOL_TO_REVENUE_POOL_THRESHOLD` (in surplus), settle fees collected to the revenue pool depending on the health of the AMM state
    // Otherwise, spull from the revenue pool (up to a constraint amount)

    let amm_budget_surplus =
        terminal_state_surplus.saturating_sub(FEE_POOL_TO_REVENUE_POOL_THRESHOLD.cast()?);

    if amm_budget_surplus > 0 {
        let fee_pool_threshold = amm_fee_pool_token_amount_after
            .saturating_sub(
                FEE_POOL_TO_REVENUE_POOL_THRESHOLD
                    .safe_add(market.amm.total_social_loss)?
                    .cast()?,
            )
            .cast()?;

        let total_liq_fees_for_revenue_pool = market
            .amm
            .total_liquidation_fee
            .min(
                market
                    .insurance_claim
                    .quote_settled_insurance
                    .safe_add(market.insurance_claim.quote_max_insurance)?
                    .cast()?,
            )
            .cast::<i128>()?;

        let max_revenue_to_settle = market
            .insurance_claim
            .revenue_withdraw_since_last_settle
            .safe_add(
                market
                    .insurance_claim
                    .max_revenue_withdraw_per_period
                    .cast()?,
            )?
            .min(market.amm.net_revenue_since_last_funding)
            .max(0);

        let total_fee_for_if = get_total_fee_lower_bound(market)?.cast::<i128>()?;

        let revenue_pool_transfer = total_fee_for_if
            .safe_add(total_liq_fees_for_revenue_pool)?
            .saturating_sub(market.amm.total_fee_withdrawn.cast()?)
            .max(0)
            .min(fee_pool_threshold)
            .min(max_revenue_to_settle.cast()?);

        validate!(
            revenue_pool_transfer >= 0,
            ErrorCode::InsufficientPerpPnlPool,
            "revenue_pool_transfer negative ({})",
            revenue_pool_transfer
        )?;

        Ok(revenue_pool_transfer)
    } else if amm_budget_surplus < 0 {
        let max_revenue_withdraw_allowed = market
            .insurance_claim
            .max_revenue_withdraw_per_period
            .cast::<i64>()?
            .saturating_sub(market.insurance_claim.revenue_withdraw_since_last_settle)
            .cast::<u128>()?
            .min(
                get_token_amount(
                    spot_market.revenue_pool.scaled_balance,
                    spot_market,
                    &SpotBalanceType::Deposit,
                )?
                .cast()?,
            )
            .min(
                market
                    .insurance_claim
                    .max_revenue_withdraw_per_period
                    .cast()?,
            );

        if max_revenue_withdraw_allowed > 0 {
            let revenue_pool_transfer = -(amm_budget_surplus
                .abs()
                .min(max_revenue_withdraw_allowed.cast()?));
            Ok(revenue_pool_transfer)
        } else {
            Ok(0)
        }
    } else {
        Ok(0)
    }
}

pub fn update_pool_balances(
    market: &mut PerpMarket,
    spot_market: &mut SpotMarket,
    user_quote_position: &SpotPosition,
    user_unsettled_pnl: i128,
    now: i64,
) -> DriftResult<i128> {
    // current spot_market balance of amm fee pool
    let amm_fee_pool_token_amount = get_token_amount(
        market.amm.fee_pool.balance(),
        spot_market,
        market.amm.fee_pool.balance_type(),
    )?
    .cast::<i128>()?;

    let mut fraction_for_amm = 100;

    let amm_target_max_fee_pool_token_amount = market
        .amm
        .total_fee_minus_distributions
        .safe_add(market.amm.total_liquidation_fee.cast()?)?
        .safe_sub(market.amm.total_fee_withdrawn.cast()?)?;

    if amm_target_max_fee_pool_token_amount <= amm_fee_pool_token_amount {
        // owe the market pnl pool before settling user
        let pnl_pool_addition =
            max(0, amm_target_max_fee_pool_token_amount).safe_sub(amm_fee_pool_token_amount)?;

        if pnl_pool_addition < 0 {
            transfer_spot_balances(
                pnl_pool_addition.abs(),
                spot_market,
                &mut market.amm.fee_pool,
                &mut market.pnl_pool,
            )?;
        }

        fraction_for_amm = 0;
    }

    {
        let amm_target_min_fee_pool_token_amount = get_total_fee_lower_bound(market)?
            .safe_add(market.amm.total_liquidation_fee)?
            .safe_sub(market.amm.total_fee_withdrawn)?;

        let amm_fee_pool_token_amount = get_token_amount(
            market.amm.fee_pool.balance(),
            spot_market,
            market.amm.fee_pool.balance_type(),
        )?;

        if amm_fee_pool_token_amount < amm_target_min_fee_pool_token_amount {
            let pnl_pool_token_amount = get_token_amount(
                market.pnl_pool.balance(),
                spot_market,
                market.pnl_pool.balance_type(),
            )?;

            let pnl_pool_removal = amm_target_min_fee_pool_token_amount
                .safe_sub(amm_fee_pool_token_amount)?
                .min(pnl_pool_token_amount);

            if pnl_pool_removal > 0 {
                transfer_spot_balances(
                    pnl_pool_removal.cast::<i128>()?,
                    spot_market,
                    &mut market.pnl_pool,
                    &mut market.amm.fee_pool,
                )?;
            }
        }

        let amm_fee_pool_token_amount_after = get_token_amount(
            market.amm.fee_pool.balance(),
            spot_market,
            market.amm.fee_pool.balance_type(),
        )?;

        let terminal_state_surplus = market
            .amm
            .total_fee_minus_distributions
            .safe_sub(market.amm.total_fee_withdrawn.cast()?)?;

        // market can perform withdraw from revenue pool
        if spot_market.insurance_fund.last_revenue_settle_ts
            > market.insurance_claim.last_revenue_withdraw_ts
        {
            validate!(now >= market.insurance_claim.last_revenue_withdraw_ts && now >= spot_market.insurance_fund.last_revenue_settle_ts,
                ErrorCode::BlockchainClockInconsistency,
                "issue with clock unix timestamp {} < market.insurance_claim.last_revenue_withdraw_ts={}/spot_market.last_revenue_settle_ts={}",
                now,
                market.insurance_claim.last_revenue_withdraw_ts,
                spot_market.insurance_fund.last_revenue_settle_ts,
            )?;
            market.insurance_claim.revenue_withdraw_since_last_settle = 0;
        }

        let revenue_pool_transfer = calculate_revenue_pool_transfer(
            market,
            spot_market,
            amm_fee_pool_token_amount_after,
            terminal_state_surplus,
        )?;

        match revenue_pool_transfer.cmp(&0) {
            Ordering::Greater => {
                transfer_spot_balance_to_revenue_pool(
                    revenue_pool_transfer.unsigned_abs(),
                    spot_market,
                    &mut market.amm.fee_pool,
                )?;

                market.amm.total_fee_withdrawn = market
                    .amm
                    .total_fee_withdrawn
                    .safe_add(revenue_pool_transfer.unsigned_abs())?;
            }
            Ordering::Less => {
                transfer_revenue_pool_to_spot_balance(
                    revenue_pool_transfer.unsigned_abs(),
                    spot_market,
                    &mut market.amm.fee_pool,
                )?;
            }
            Ordering::Equal => (),
        }

        if revenue_pool_transfer != 0 {
            market.amm.total_fee_minus_distributions = market
                .amm
                .total_fee_minus_distributions
                .safe_sub(revenue_pool_transfer)?;

            market.insurance_claim.revenue_withdraw_since_last_settle = market
                .insurance_claim
                .revenue_withdraw_since_last_settle
                .safe_sub(revenue_pool_transfer.cast()?)?;
            market.insurance_claim.last_revenue_withdraw_ts = now;
        }
    }

    // market pnl pool pays (what it can to) user_unsettled_pnl and pnl_to_settle_to_amm
    let pnl_pool_token_amount = get_token_amount(
        market.pnl_pool.balance(),
        spot_market,
        market.pnl_pool.balance_type(),
    )?;

    let pnl_to_settle_with_user = if user_unsettled_pnl > 0 {
        min(user_unsettled_pnl, pnl_pool_token_amount.cast::<i128>()?)
    } else {
        let token_amount = user_quote_position.get_signed_token_amount(spot_market)?;

        // dont settle negative pnl to spot borrows when utilization is high (> 80%)
        let max_withdraw_amount =
            -get_max_withdraw_for_market_with_token_amount(spot_market, token_amount, false)?
                .cast::<i128>()?;

        max_withdraw_amount.max(user_unsettled_pnl)
    };

    let pnl_fraction_for_amm = if fraction_for_amm > 0 && pnl_to_settle_with_user < 0 {
        let pnl_fraction_for_amm = pnl_to_settle_with_user.safe_div(fraction_for_amm)?;
        update_spot_balances(
            pnl_fraction_for_amm.unsigned_abs(),
            &SpotBalanceType::Deposit,
            spot_market,
            &mut market.amm.fee_pool,
            false,
        )?;
        pnl_fraction_for_amm
    } else {
        0
    };

    let pnl_to_settle_with_market = -(pnl_to_settle_with_user.safe_sub(pnl_fraction_for_amm)?);

    update_spot_balances(
        pnl_to_settle_with_market.unsigned_abs(),
        if pnl_to_settle_with_market >= 0 {
            &SpotBalanceType::Deposit
        } else {
            &SpotBalanceType::Borrow
        },
        spot_market,
        &mut market.pnl_pool,
        false,
    )?;

    let _depositors_claim = validate_spot_balances(spot_market)?;

    Ok(pnl_to_settle_with_user)
}

pub fn update_pnl_pool_and_user_balance(
    market: &mut PerpMarket,
    bank: &mut SpotMarket,
    user: &mut User,
    unrealized_pnl_with_fee: i128,
) -> DriftResult<i128> {
    let pnl_to_settle_with_user = if unrealized_pnl_with_fee > 0 {
        unrealized_pnl_with_fee.min(
            get_token_amount(
                market.pnl_pool.scaled_balance,
                bank,
                market.pnl_pool.balance_type(),
            )?
            .cast()?,
        )
    } else {
        unrealized_pnl_with_fee
    };

    validate!(
        unrealized_pnl_with_fee == pnl_to_settle_with_user,
        ErrorCode::InsufficientPerpPnlPool,
        "pnl_pool_amount doesnt have enough ({} < {})",
        pnl_to_settle_with_user,
        unrealized_pnl_with_fee
    )?;

    if unrealized_pnl_with_fee == 0 {
        msg!(
            "User has no unsettled pnl for market {}",
            market.market_index
        );
        return Ok(0);
    } else if pnl_to_settle_with_user == 0 {
        msg!(
            "Pnl Pool cannot currently settle with user for market {}",
            market.market_index
        );
        return Ok(0);
    }

    let user_spot_position = user.get_quote_spot_position_mut();

    transfer_spot_balances(
        pnl_to_settle_with_user,
        bank,
        &mut market.pnl_pool,
        user_spot_position,
    )?;

    Ok(pnl_to_settle_with_user)
}

pub fn move_price(
    market: &mut PerpMarket,
    base_asset_reserve: u128,
    quote_asset_reserve: u128,
    sqrt_k: u128,
) -> DriftResult {
    market.amm.base_asset_reserve = base_asset_reserve;

    let k = bn::U256::from(sqrt_k).safe_mul(bn::U256::from(sqrt_k))?;

    market.amm.quote_asset_reserve = k
        .safe_div(bn::U256::from(base_asset_reserve))?
        .try_to_u128()?;

    validate!(
        (quote_asset_reserve.cast::<i128>()? - market.amm.quote_asset_reserve.cast::<i128>()?)
            .abs()
            < 100,
        ErrorCode::InvalidAmmDetected,
        "quote_asset_reserve passed doesnt reconcile enough {} vs {}",
        quote_asset_reserve.cast::<i128>()?,
        market.amm.quote_asset_reserve.cast::<i128>()?
    )?;

    market.amm.sqrt_k = sqrt_k;

    let (_, terminal_quote_reserves, terminal_base_reserves) =
        amm::calculate_terminal_price_and_reserves(&market.amm)?;
    market.amm.terminal_quote_asset_reserve = terminal_quote_reserves;

    let (min_base_asset_reserve, max_base_asset_reserve) =
        amm::calculate_bid_ask_bounds(market.amm.concentration_coef, terminal_base_reserves)?;

    market.amm.max_base_asset_reserve = max_base_asset_reserve;
    market.amm.min_base_asset_reserve = min_base_asset_reserve;

    let reserve_price_after = market.amm.reserve_price()?;
    update_spreads(market, reserve_price_after, None)?;

    Ok(())
}

// recenter peg with balanced terminal reserves
pub fn recenter_perp_market_amm(
    market: &mut PerpMarket,
    peg_multiplier: u128,
    sqrt_k: u128,
) -> DriftResult {
    // calculate base/quote reserves for balanced terminal reserves
    let swap_direction = if market.amm.base_asset_amount_with_amm > 0 {
        SwapDirection::Remove
    } else {
        SwapDirection::Add
    };
    let (new_quote_asset_amount, new_base_asset_amount) = amm::calculate_swap_output(
        market.amm.base_asset_amount_with_amm.unsigned_abs(),
        sqrt_k,
        swap_direction,
        sqrt_k,
    )?;

    market.amm.base_asset_reserve = new_base_asset_amount;

    let k = bn::U256::from(sqrt_k).safe_mul(bn::U256::from(sqrt_k))?;

    market.amm.quote_asset_reserve = k
        .safe_div(bn::U256::from(new_base_asset_amount))?
        .try_to_u128()?;

    validate!(
        (new_quote_asset_amount.cast::<i128>()? - market.amm.quote_asset_reserve.cast::<i128>()?)
            .abs()
            < 100,
        ErrorCode::InvalidAmmDetected,
        "quote_asset_reserve passed doesnt reconcile enough"
    )?;

    market.amm.sqrt_k = sqrt_k;
    // todo: ensure correct terminal state cost for altering sqrt_k

    market.amm.peg_multiplier = peg_multiplier;

    let (_, terminal_quote_reserves, terminal_base_reserves) =
        amm::calculate_terminal_price_and_reserves(&market.amm)?;
    market.amm.terminal_quote_asset_reserve = terminal_quote_reserves;

    let (min_base_asset_reserve, max_base_asset_reserve) =
        amm::calculate_bid_ask_bounds(market.amm.concentration_coef, terminal_base_reserves)?;

    market.amm.max_base_asset_reserve = max_base_asset_reserve;
    market.amm.min_base_asset_reserve = min_base_asset_reserve;

    let reserve_price_after = market.amm.reserve_price()?;
    update_spreads(market, reserve_price_after, None)?;

    Ok(())
}

// recalculate and update summary stats on amm which are prone too accumulating integer math errors
pub fn calculate_perp_market_amm_summary_stats(
    perp_market: &PerpMarket,
    spot_market: &SpotMarket,
    perp_market_oracle_price: i64,
    exclude_liquidation_fee: bool,
) -> DriftResult<i128> {
    let pnl_pool_token_amount = get_token_amount(
        perp_market.pnl_pool.scaled_balance,
        spot_market,
        perp_market.pnl_pool.balance_type(),
    )?;

    let fee_pool_token_amount = get_token_amount(
        perp_market.amm.fee_pool.scaled_balance,
        spot_market,
        perp_market.amm.fee_pool.balance_type(),
    )?;

    let pnl_tokens_available: i128 = pnl_pool_token_amount
        .safe_add(fee_pool_token_amount)?
        .cast()?;

    let net_user_pnl = calculate_net_user_pnl(&perp_market.amm, perp_market_oracle_price)?;

    // amm's mm_fee can be incorrect with drifting integer math error
    let mut new_total_fee_minus_distributions = pnl_tokens_available.safe_sub(net_user_pnl)?;

    if exclude_liquidation_fee {
        new_total_fee_minus_distributions = new_total_fee_minus_distributions
            .safe_sub(perp_market.amm.total_liquidation_fee.cast()?)?;
    }

    Ok(new_total_fee_minus_distributions)
}



================================================
FILE: programs/drift/src/controller/funding.rs
================================================
use std::cmp::max;

use anchor_lang::prelude::*;
use solana_program::clock::UnixTimestamp;

use crate::controller::amm::formulaic_update_k;
use crate::controller::position::{
    get_position_index, update_quote_asset_and_break_even_amount, PositionDirection,
};
use crate::error::DriftResult;
use crate::get_then_update_id;
use crate::math::amm;
use crate::math::casting::Cast;
use crate::math::constants::{
    FUNDING_RATE_BUFFER, FUNDING_RATE_OFFSET_DENOMINATOR, ONE_HOUR_I128, TWENTY_FOUR_HOUR,
};
use crate::math::funding::{calculate_funding_payment, calculate_funding_rate_long_short};
use crate::math::helpers::on_the_hour_update;
use crate::math::safe_math::SafeMath;
use crate::math::stats::calculate_new_twap;

use crate::math::oracle;

use crate::state::events::{FundingPaymentRecord, FundingRateRecord};
use crate::state::oracle_map::OracleMap;
use crate::state::perp_market::{PerpMarket, AMM};
use crate::state::perp_market_map::PerpMarketMap;
use crate::state::state::OracleGuardRails;
use crate::state::user::User;

pub fn settle_funding_payment(
    user: &mut User,
    user_key: &Pubkey,
    market: &mut PerpMarket,
    now: UnixTimestamp,
) -> DriftResult {
    let position_index = match get_position_index(&user.perp_positions, market.market_index) {
        Ok(position_index) => position_index,
        Err(_) => return Ok(()),
    };

    if user.perp_positions[position_index].base_asset_amount == 0 {
        return Ok(());
    }

    let amm: &AMM = &market.amm;

    let amm_cumulative_funding_rate = if user.perp_positions[position_index].base_asset_amount > 0 {
        amm.cumulative_funding_rate_long
    } else {
        amm.cumulative_funding_rate_short
    };

    if amm_cumulative_funding_rate
        != user.perp_positions[position_index]
            .last_cumulative_funding_rate
            .cast()?
    {
        let market_funding_payment = calculate_funding_payment(
            amm_cumulative_funding_rate,
            &user.perp_positions[position_index],
        )?;

        user.update_cumulative_perp_funding(market_funding_payment)?;

        let market_position = &mut user.perp_positions[position_index];

        emit!(FundingPaymentRecord {
            ts: now,
            user_authority: user.authority,
            user: *user_key,
            market_index: market_position.market_index,
            funding_payment: market_funding_payment, //10e13
            user_last_cumulative_funding: market_position.last_cumulative_funding_rate, //10e14
            amm_cumulative_funding_long: amm.cumulative_funding_rate_long, //10e14
            amm_cumulative_funding_short: amm.cumulative_funding_rate_short, //10e14
            base_asset_amount: market_position.base_asset_amount, //10e13
        });

        market_position.last_cumulative_funding_rate = amm_cumulative_funding_rate.cast()?;
        update_quote_asset_and_break_even_amount(market_position, market, market_funding_payment)?;
        market.amm.net_unsettled_funding_pnl = market
            .amm
            .net_unsettled_funding_pnl
            .safe_sub(market_funding_payment)?;
    }

    Ok(())
}

pub fn settle_funding_payments(
    user: &mut User,
    user_key: &Pubkey,
    perp_market_map: &PerpMarketMap,
    now: UnixTimestamp,
) -> DriftResult {
    for position_index in 0..user.perp_positions.len() {
        if user.perp_positions[position_index].base_asset_amount == 0 {
            continue;
        }

        let market =
            &mut perp_market_map.get_ref_mut(&user.perp_positions[position_index].market_index)?;
        let amm: &AMM = &market.amm;

        let amm_cumulative_funding_rate =
            if user.perp_positions[position_index].base_asset_amount > 0 {
                amm.cumulative_funding_rate_long
            } else {
                amm.cumulative_funding_rate_short
            };

        if amm_cumulative_funding_rate
            != user.perp_positions[position_index]
                .last_cumulative_funding_rate
                .cast()?
        {
            let market_funding_payment = calculate_funding_payment(
                amm_cumulative_funding_rate,
                &user.perp_positions[position_index],
            )?;

            user.update_cumulative_perp_funding(market_funding_payment)?;

            let market_position = &mut user.perp_positions[position_index];

            emit!(FundingPaymentRecord {
                ts: now,
                user_authority: user.authority,
                user: *user_key,
                market_index: market_position.market_index,
                funding_payment: market_funding_payment, //1e6
                user_last_cumulative_funding: market_position.last_cumulative_funding_rate, //1e9
                amm_cumulative_funding_long: amm.cumulative_funding_rate_long, //1e9
                amm_cumulative_funding_short: amm.cumulative_funding_rate_short, //1e9
                base_asset_amount: market_position.base_asset_amount, //1e9
            });

            market_position.last_cumulative_funding_rate = amm_cumulative_funding_rate.cast()?;
            update_quote_asset_and_break_even_amount(
                market_position,
                market,
                market_funding_payment,
            )?;
            market.amm.net_unsettled_funding_pnl = market
                .amm
                .net_unsettled_funding_pnl
                .safe_sub(market_funding_payment)?;
        }
    }

    Ok(())
}

#[allow(clippy::comparison_chain)]
pub fn update_funding_rate(
    market_index: u16,
    market: &mut PerpMarket,
    oracle_map: &mut OracleMap,
    now: UnixTimestamp,
    slot: u64,
    guard_rails: &OracleGuardRails,
    funding_paused: bool,
    precomputed_reserve_price: Option<u64>,
) -> DriftResult<bool> {
    let reserve_price = match precomputed_reserve_price {
        Some(reserve_price) => reserve_price,
        None => market.amm.reserve_price()?,
    };
    // Pause funding if oracle is invalid or if mark/oracle spread is too divergent
    let block_funding_rate_update = oracle::block_operation(
        market,
        oracle_map.get_price_data(&market.oracle_id())?,
        guard_rails,
        reserve_price,
        slot,
    )?;

    let time_until_next_update = on_the_hour_update(
        now,
        market.amm.last_funding_rate_ts,
        market.amm.funding_period,
    )?;

    let valid_funding_update =
        !funding_paused && !block_funding_rate_update && (time_until_next_update == 0);

    if valid_funding_update {
        let oracle_price_data = oracle_map.get_price_data(&market.oracle_id())?;
        let sanitize_clamp_denominator = market.get_sanitize_clamp_denominator()?;
        let mm_oracle_price_data =
            market.get_mm_oracle_price_data(*oracle_price_data, slot, &guard_rails.validity)?;

        let oracle_price_twap = amm::update_oracle_price_twap(
            &mut market.amm,
            now,
            &mm_oracle_price_data,
            Some(reserve_price),
            sanitize_clamp_denominator,
        )?;

        // price relates to execution premium / direction
        let (execution_premium_price, execution_premium_direction) =
            if market.amm.long_spread > market.amm.short_spread {
                (
                    market.amm.ask_price(reserve_price)?,
                    Some(PositionDirection::Long),
                )
            } else if market.amm.long_spread < market.amm.short_spread {
                (
                    market.amm.bid_price(reserve_price)?,
                    Some(PositionDirection::Short),
                )
            } else {
                (reserve_price, None)
            };

        let sanitize_clamp_denominator = market.get_sanitize_clamp_denominator()?;
        let mid_price_twap = amm::update_mark_twap_from_estimates(
            &mut market.amm,
            now,
            Some(execution_premium_price),
            execution_premium_direction,
            sanitize_clamp_denominator,
        )?;

        let period_adjustment = (24_i128)
            .safe_mul(ONE_HOUR_I128)?
            .safe_div(max(ONE_HOUR_I128, market.amm.funding_period as i128))?;
        // funding period = 1 hour, window = 1 day
        // low periodicity => quickly updating/settled funding rates => lower funding rate payment per interval
        let price_spread = mid_price_twap.cast::<i64>()?.safe_sub(oracle_price_twap)?;

        // add offset 1/FUNDING_RATE_OFFSET_DENOMINATOR*365. if FUNDING_RATE_OFFSET_DENOMINATOR = 5000 => 7.3% annualized rate
        let price_spread_with_offset = price_spread.safe_add(
            oracle_price_twap
                .abs()
                .safe_div(FUNDING_RATE_OFFSET_DENOMINATOR)?,
        )?;

        // clamp price divergence based on contract tier for funding rate calculation
        let max_price_spread =
            market.get_max_price_divergence_for_funding_rate(oracle_price_twap)?;
        let clamped_price_spread =
            price_spread_with_offset.clamp(-max_price_spread, max_price_spread);

        let funding_rate = clamped_price_spread
            .cast::<i128>()?
            .safe_mul(FUNDING_RATE_BUFFER.cast()?)?
            .safe_div(period_adjustment.cast()?)?
            .cast::<i64>()?;

        let (funding_rate_long, funding_rate_short, funding_imbalance_revenue) =
            calculate_funding_rate_long_short(market, funding_rate.cast()?)?;

        if market.amm.curve_update_intensity > 0 {
            // if funding_imbalance_revenue is positive, protocol receives.
            // if funding_imbalance_cost is positive, protocol spends.
            let funding_imbalance_cost = -funding_imbalance_revenue;
            formulaic_update_k(market, oracle_price_data, funding_imbalance_cost, now)?;
        }

        market.amm.cumulative_funding_rate_long = market
            .amm
            .cumulative_funding_rate_long
            .safe_add(funding_rate_long)?;

        market.amm.cumulative_funding_rate_short = market
            .amm
            .cumulative_funding_rate_short
            .safe_add(funding_rate_short)?;

        market.amm.last_funding_rate = funding_rate;
        market.amm.last_funding_oracle_twap = oracle_price_twap;
        market.amm.last_funding_rate_long = funding_rate_long.cast()?;
        market.amm.last_funding_rate_short = funding_rate_short.cast()?;
        market.amm.last_24h_avg_funding_rate = calculate_new_twap(
            funding_rate,
            now,
            market.amm.last_24h_avg_funding_rate,
            market.amm.last_funding_rate_ts,
            TWENTY_FOUR_HOUR,
        )?;

        market.amm.net_unsettled_funding_pnl = market
            .amm
            .net_unsettled_funding_pnl
            .safe_sub(funding_imbalance_revenue.cast()?)?;

        market.amm.last_funding_rate_ts = now;

        emit!(FundingRateRecord {
            ts: now,
            record_id: get_then_update_id!(market, next_funding_rate_record_id),
            market_index,
            funding_rate,
            funding_rate_long,
            funding_rate_short,
            cumulative_funding_rate_long: market.amm.cumulative_funding_rate_long,
            cumulative_funding_rate_short: market.amm.cumulative_funding_rate_short,
            mark_price_twap: mid_price_twap,
            oracle_price_twap,
            period_revenue: market.amm.net_revenue_since_last_funding,
            base_asset_amount_with_amm: market.amm.base_asset_amount_with_amm,
            base_asset_amount_with_unsettled_lp: market.amm.base_asset_amount_with_unsettled_lp,
        });

        market.amm.net_revenue_since_last_funding = 0;
    } else {
        return Ok(false);
    }

    Ok(true)
}



================================================
FILE: programs/drift/src/controller/insurance.rs
================================================
use crate::msg;
use anchor_lang::prelude::*;
use anchor_spl::token_interface::{Mint, TokenAccount, TokenInterface};

use std::iter::Peekable;
use std::slice::Iter;

use crate::controller::spot_balance::{
    update_revenue_pool_balances, update_spot_balances, update_spot_market_cumulative_interest,
};
use crate::controller::token::send_from_program_vault;
use crate::error::DriftResult;
use crate::error::ErrorCode;
use crate::math::amm::calculate_net_user_pnl;
use crate::math::casting::Cast;
use crate::math::constants::{
    MAX_APR_PER_REVENUE_SETTLE_TO_INSURANCE_FUND_VAULT,
    MAX_APR_PER_REVENUE_SETTLE_TO_INSURANCE_FUND_VAULT_GOV, ONE_YEAR, PERCENTAGE_PRECISION,
    SHARE_OF_REVENUE_ALLOCATED_TO_INSURANCE_FUND_VAULT_DENOMINATOR,
    SHARE_OF_REVENUE_ALLOCATED_TO_INSURANCE_FUND_VAULT_NUMERATOR,
};
use crate::math::fuel::calculate_insurance_fuel_bonus;
use crate::math::helpers::get_proportion_u128;
use crate::math::helpers::on_the_hour_update;
use crate::math::insurance::{
    calculate_if_shares_lost, calculate_rebase_info, calculate_share_price,
    if_shares_to_vault_amount, vault_amount_to_if_shares,
};
use crate::math::orders::calculate_fill_price;
use crate::math::safe_math::SafeMath;
use crate::math::spot_balance::get_token_amount;
use crate::math::spot_withdraw::validate_spot_market_vault_amount;
use crate::state::events::{
    InsuranceFundRecord, InsuranceFundStakeRecord, InsuranceFundSwapRecord, StakeAction,
    TransferProtocolIfSharesToRevenuePoolRecord,
};
use crate::state::if_rebalance_config::IfRebalanceConfig;
use crate::state::insurance_fund_stake::InsuranceFundStake;
use crate::state::perp_market::PerpMarket;
use crate::state::spot_market::{SpotBalanceType, SpotMarket};
use crate::state::state::State;
use crate::state::user::UserStats;
use crate::{emit, validate, FUEL_START_TS, GOV_SPOT_MARKET_INDEX, QUOTE_SPOT_MARKET_INDEX};

#[cfg(test)]
mod tests;

pub fn update_user_stats_if_stake_amount(
    if_stake_amount_delta: i64,
    insurance_vault_amount: u64,
    insurance_fund_stake: &mut InsuranceFundStake,
    user_stats: &mut UserStats,
    spot_market: &mut SpotMarket,
    now: i64,
) -> DriftResult {
    if spot_market.market_index != QUOTE_SPOT_MARKET_INDEX
        && spot_market.market_index != GOV_SPOT_MARKET_INDEX
        && spot_market.fuel_boost_insurance == 0
    {
        return Ok(());
    }

    let if_stake_amount = if if_stake_amount_delta >= 0 {
        if_shares_to_vault_amount(
            insurance_fund_stake.checked_if_shares(spot_market)?,
            spot_market.insurance_fund.total_shares,
            insurance_vault_amount.safe_add(if_stake_amount_delta.unsigned_abs())?,
        )?
    } else {
        if_shares_to_vault_amount(
            insurance_fund_stake.checked_if_shares(spot_market)?,
            spot_market.insurance_fund.total_shares,
            insurance_vault_amount.safe_sub(if_stake_amount_delta.unsigned_abs())?,
        )?
    };

    if spot_market.market_index == QUOTE_SPOT_MARKET_INDEX {
        user_stats.if_staked_quote_asset_amount = if_stake_amount;
    } else if spot_market.market_index == GOV_SPOT_MARKET_INDEX {
        user_stats.if_staked_gov_token_amount = if_stake_amount;
    }

    if spot_market.fuel_boost_insurance != 0 && now >= FUEL_START_TS {
        let now_u32: u32 = now.cast()?;
        let since_last = now_u32.safe_sub(
            user_stats
                .last_fuel_if_bonus_update_ts
                .max(FUEL_START_TS.cast()?),
        )?;

        // calculate their stake amount prior to update
        let fuel_bonus_insurance = calculate_insurance_fuel_bonus(
            spot_market,
            if_stake_amount,
            if_stake_amount_delta,
            since_last,
        )?;

        user_stats.fuel_insurance = user_stats
            .fuel_insurance
            .saturating_add(fuel_bonus_insurance.cast()?);
        user_stats.last_fuel_if_bonus_update_ts = now_u32;
    }

    Ok(())
}

pub fn add_insurance_fund_stake(
    amount: u64,
    insurance_vault_amount: u64,
    insurance_fund_stake: &mut InsuranceFundStake,
    user_stats: &mut UserStats,
    spot_market: &mut SpotMarket,
    now: i64,
    admin_deposit: bool,
) -> DriftResult {
    validate!(
        !(insurance_vault_amount == 0 && spot_market.insurance_fund.total_shares != 0),
        ErrorCode::InvalidIFForNewStakes,
        "Insurance Fund balance should be non-zero for new stakers to enter"
    )?;

    apply_rebase_to_insurance_fund(insurance_vault_amount, spot_market)?;
    apply_rebase_to_insurance_fund_stake(insurance_fund_stake, spot_market)?;

    let if_shares_before = insurance_fund_stake.checked_if_shares(spot_market)?;
    let total_if_shares_before = spot_market.insurance_fund.total_shares;
    let user_if_shares_before = spot_market.insurance_fund.user_shares;

    let n_shares = vault_amount_to_if_shares(
        amount,
        spot_market.insurance_fund.total_shares,
        insurance_vault_amount,
    )?;

    // reset cost basis if no shares
    insurance_fund_stake.cost_basis = if if_shares_before == 0 {
        amount.cast()?
    } else {
        insurance_fund_stake.cost_basis.safe_add(amount.cast()?)?
    };

    insurance_fund_stake.increase_if_shares(n_shares, spot_market)?;

    spot_market.insurance_fund.total_shares =
        spot_market.insurance_fund.total_shares.safe_add(n_shares)?;

    spot_market.insurance_fund.user_shares =
        spot_market.insurance_fund.user_shares.safe_add(n_shares)?;

    update_user_stats_if_stake_amount(
        amount.cast()?,
        insurance_vault_amount,
        insurance_fund_stake,
        user_stats,
        spot_market,
        now,
    )?;

    let if_shares_after = insurance_fund_stake.checked_if_shares(spot_market)?;

    emit!(InsuranceFundStakeRecord {
        ts: now,
        user_authority: user_stats.authority,
        action: if admin_deposit {
            StakeAction::AdminDeposit
        } else {
            StakeAction::Stake
        },
        amount,
        market_index: spot_market.market_index,
        insurance_vault_amount_before: insurance_vault_amount,
        if_shares_before,
        user_if_shares_before,
        total_if_shares_before,
        if_shares_after,
        total_if_shares_after: spot_market.insurance_fund.total_shares,
        user_if_shares_after: spot_market.insurance_fund.user_shares,
    });

    Ok(())
}

pub fn apply_rebase_to_insurance_fund(
    insurance_fund_vault_balance: u64,
    spot_market: &mut SpotMarket,
) -> DriftResult {
    if insurance_fund_vault_balance != 0
        && insurance_fund_vault_balance.cast::<u128>()? < spot_market.insurance_fund.total_shares
    {
        let (expo_diff, rebase_divisor) = calculate_rebase_info(
            spot_market.insurance_fund.total_shares,
            insurance_fund_vault_balance,
        )?;

        spot_market.insurance_fund.total_shares = spot_market
            .insurance_fund
            .total_shares
            .safe_div(rebase_divisor)?;
        spot_market.insurance_fund.user_shares = spot_market
            .insurance_fund
            .user_shares
            .safe_div(rebase_divisor)?;
        spot_market.insurance_fund.shares_base = spot_market
            .insurance_fund
            .shares_base
            .safe_add(expo_diff.cast::<u128>()?)?;

        msg!("rebasing insurance fund: expo_diff={}", expo_diff);
    }

    if insurance_fund_vault_balance != 0 && spot_market.insurance_fund.total_shares == 0 {
        spot_market.insurance_fund.total_shares = insurance_fund_vault_balance.cast::<u128>()?;
    }

    Ok(())
}

pub fn apply_rebase_to_insurance_fund_stake(
    insurance_fund_stake: &mut InsuranceFundStake,
    spot_market: &mut SpotMarket,
) -> DriftResult {
    if spot_market.insurance_fund.shares_base != insurance_fund_stake.if_base {
        validate!(
            spot_market.insurance_fund.shares_base > insurance_fund_stake.if_base,
            ErrorCode::InvalidIFRebase,
            "Rebase expo out of bounds"
        )?;

        let expo_diff = (spot_market.insurance_fund.shares_base - insurance_fund_stake.if_base)
            .cast::<u32>()?;

        let rebase_divisor = 10_u128.pow(expo_diff);

        msg!(
            "rebasing insurance fund stake: base: {} -> {} ",
            insurance_fund_stake.if_base,
            spot_market.insurance_fund.shares_base,
        );

        insurance_fund_stake.if_base = spot_market.insurance_fund.shares_base;

        let old_if_shares = insurance_fund_stake.unchecked_if_shares();
        let new_if_shares = old_if_shares.safe_div(rebase_divisor)?;

        msg!(
            "rebasing insurance fund stake: shares -> {} ",
            new_if_shares
        );

        insurance_fund_stake.update_if_shares(new_if_shares, spot_market)?;

        insurance_fund_stake.last_withdraw_request_shares = insurance_fund_stake
            .last_withdraw_request_shares
            .safe_div(rebase_divisor)?;
    }

    Ok(())
}

pub fn request_remove_insurance_fund_stake(
    n_shares: u128,
    insurance_vault_amount: u64,
    insurance_fund_stake: &mut InsuranceFundStake,
    user_stats: &mut UserStats,
    spot_market: &mut SpotMarket,
    now: i64,
) -> DriftResult {
    msg!("n_shares {}", n_shares);
    insurance_fund_stake.last_withdraw_request_shares = n_shares;

    apply_rebase_to_insurance_fund(insurance_vault_amount, spot_market)?;
    apply_rebase_to_insurance_fund_stake(insurance_fund_stake, spot_market)?;

    let if_shares_before = insurance_fund_stake.checked_if_shares(spot_market)?;
    let total_if_shares_before = spot_market.insurance_fund.total_shares;
    let user_if_shares_before = spot_market.insurance_fund.user_shares;

    validate!(
        insurance_fund_stake.last_withdraw_request_shares
            <= insurance_fund_stake.checked_if_shares(spot_market)?,
        ErrorCode::InvalidInsuranceUnstakeSize,
        "last_withdraw_request_shares exceeds if_shares {} > {}",
        insurance_fund_stake.last_withdraw_request_shares,
        insurance_fund_stake.checked_if_shares(spot_market)?
    )?;

    validate!(
        insurance_fund_stake.if_base == spot_market.insurance_fund.shares_base,
        ErrorCode::InvalidIFRebase,
        "if stake base != spot market base"
    )?;

    insurance_fund_stake.last_withdraw_request_value = if_shares_to_vault_amount(
        insurance_fund_stake.last_withdraw_request_shares,
        spot_market.insurance_fund.total_shares,
        insurance_vault_amount,
    )?
    .min(insurance_vault_amount.saturating_sub(1));

    validate!(
        insurance_fund_stake.last_withdraw_request_value == 0
            || insurance_fund_stake.last_withdraw_request_value < insurance_vault_amount,
        ErrorCode::InvalidIFUnstakeSize,
        "Requested withdraw value is not below Insurance Fund balance"
    )?;

    let if_shares_after = insurance_fund_stake.checked_if_shares(spot_market)?;

    update_user_stats_if_stake_amount(
        0,
        insurance_vault_amount,
        insurance_fund_stake,
        user_stats,
        spot_market,
        now,
    )?;

    emit!(InsuranceFundStakeRecord {
        ts: now,
        user_authority: user_stats.authority,
        action: StakeAction::UnstakeRequest,
        amount: insurance_fund_stake.last_withdraw_request_value,
        market_index: spot_market.market_index,
        insurance_vault_amount_before: insurance_vault_amount,
        if_shares_before,
        user_if_shares_before,
        total_if_shares_before,
        if_shares_after,
        total_if_shares_after: spot_market.insurance_fund.total_shares,
        user_if_shares_after: spot_market.insurance_fund.user_shares,
    });

    insurance_fund_stake.last_withdraw_request_ts = now;

    Ok(())
}

pub fn cancel_request_remove_insurance_fund_stake(
    insurance_vault_amount: u64,
    insurance_fund_stake: &mut InsuranceFundStake,
    user_stats: &mut UserStats,
    spot_market: &mut SpotMarket,
    now: i64,
) -> DriftResult {
    apply_rebase_to_insurance_fund(insurance_vault_amount, spot_market)?;
    apply_rebase_to_insurance_fund_stake(insurance_fund_stake, spot_market)?;

    let if_shares_before = insurance_fund_stake.checked_if_shares(spot_market)?;
    let total_if_shares_before = spot_market.insurance_fund.total_shares;
    let user_if_shares_before = spot_market.insurance_fund.user_shares;

    validate!(
        insurance_fund_stake.if_base == spot_market.insurance_fund.shares_base,
        ErrorCode::InvalidIFRebase,
        "if stake base != spot market base"
    )?;

    validate!(
        insurance_fund_stake.last_withdraw_request_shares != 0,
        ErrorCode::InvalidIFUnstakeCancel,
        "No withdraw request in progress"
    )?;

    let if_shares_lost =
        calculate_if_shares_lost(insurance_fund_stake, spot_market, insurance_vault_amount)?;

    insurance_fund_stake.decrease_if_shares(if_shares_lost, spot_market)?;

    spot_market.insurance_fund.total_shares = spot_market
        .insurance_fund
        .total_shares
        .safe_sub(if_shares_lost)?;

    spot_market.insurance_fund.user_shares = spot_market
        .insurance_fund
        .user_shares
        .safe_sub(if_shares_lost)?;

    let if_shares_after = insurance_fund_stake.checked_if_shares(spot_market)?;

    update_user_stats_if_stake_amount(
        0,
        insurance_vault_amount,
        insurance_fund_stake,
        user_stats,
        spot_market,
        now,
    )?;

    emit!(InsuranceFundStakeRecord {
        ts: now,
        user_authority: user_stats.authority,
        action: StakeAction::UnstakeCancelRequest,
        amount: 0,
        market_index: spot_market.market_index,
        insurance_vault_amount_before: insurance_vault_amount,
        if_shares_before,
        user_if_shares_before,
        total_if_shares_before,
        if_shares_after,
        total_if_shares_after: spot_market.insurance_fund.total_shares,
        user_if_shares_after: spot_market.insurance_fund.user_shares,
    });

    insurance_fund_stake.last_withdraw_request_shares = 0;
    insurance_fund_stake.last_withdraw_request_value = 0;
    insurance_fund_stake.last_withdraw_request_ts = now;

    Ok(())
}

pub fn remove_insurance_fund_stake(
    insurance_vault_amount: u64,
    insurance_fund_stake: &mut InsuranceFundStake,
    user_stats: &mut UserStats,
    spot_market: &mut SpotMarket,
    now: i64,
) -> DriftResult<u64> {
    let time_since_withdraw_request =
        now.safe_sub(insurance_fund_stake.last_withdraw_request_ts)?;

    validate!(
        time_since_withdraw_request >= spot_market.insurance_fund.unstaking_period,
        ErrorCode::TryingToRemoveLiquidityTooFast
    )?;

    apply_rebase_to_insurance_fund(insurance_vault_amount, spot_market)?;
    apply_rebase_to_insurance_fund_stake(insurance_fund_stake, spot_market)?;

    let if_shares_before = insurance_fund_stake.checked_if_shares(spot_market)?;
    let total_if_shares_before = spot_market.insurance_fund.total_shares;
    let user_if_shares_before = spot_market.insurance_fund.user_shares;

    let n_shares = insurance_fund_stake.last_withdraw_request_shares;

    validate!(
        n_shares > 0,
        ErrorCode::InvalidIFUnstake,
        "Must submit withdraw request and wait the escrow period"
    )?;

    validate!(
        if_shares_before >= n_shares,
        ErrorCode::InsufficientIFShares
    )?;

    let amount = if_shares_to_vault_amount(
        n_shares,
        spot_market.insurance_fund.total_shares,
        insurance_vault_amount,
    )?;

    let _if_shares_lost =
        calculate_if_shares_lost(insurance_fund_stake, spot_market, insurance_vault_amount)?;

    let withdraw_amount = amount.min(insurance_fund_stake.last_withdraw_request_value);

    insurance_fund_stake.decrease_if_shares(n_shares, spot_market)?;

    insurance_fund_stake.cost_basis = insurance_fund_stake
        .cost_basis
        .safe_sub(withdraw_amount.cast()?)?;

    spot_market.insurance_fund.total_shares =
        spot_market.insurance_fund.total_shares.safe_sub(n_shares)?;

    spot_market.insurance_fund.user_shares =
        spot_market.insurance_fund.user_shares.safe_sub(n_shares)?;

    // reset insurance_fund_stake withdraw request info
    insurance_fund_stake.last_withdraw_request_shares = 0;
    insurance_fund_stake.last_withdraw_request_value = 0;
    insurance_fund_stake.last_withdraw_request_ts = now;

    let if_shares_after = insurance_fund_stake.checked_if_shares(spot_market)?;

    update_user_stats_if_stake_amount(
        -(withdraw_amount.cast()?),
        insurance_vault_amount,
        insurance_fund_stake,
        user_stats,
        spot_market,
        now,
    )?;

    emit!(InsuranceFundStakeRecord {
        ts: now,
        user_authority: user_stats.authority,
        action: StakeAction::Unstake,
        amount: withdraw_amount,
        market_index: spot_market.market_index,
        insurance_vault_amount_before: insurance_vault_amount,
        if_shares_before,
        user_if_shares_before,
        total_if_shares_before,
        if_shares_after,
        total_if_shares_after: spot_market.insurance_fund.total_shares,
        user_if_shares_after: spot_market.insurance_fund.user_shares,
    });

    Ok(withdraw_amount)
}

pub fn admin_remove_insurance_fund_stake(
    insurance_vault_amount: u64,
    n_shares: u128,
    spot_market: &mut SpotMarket,
    now: i64,
    admin_pubkey: Pubkey,
) -> DriftResult<u64> {
    apply_rebase_to_insurance_fund(insurance_vault_amount, spot_market)?;

    let total_if_shares_before = spot_market.insurance_fund.total_shares;
    let user_if_shares_before = spot_market.insurance_fund.user_shares;

    let if_shares_before = total_if_shares_before.safe_sub(user_if_shares_before)?;

    validate!(
        if_shares_before >= n_shares,
        ErrorCode::InsufficientIFShares,
        "if_shares_before={} < n_shares={}",
        if_shares_before,
        n_shares
    )?;

    let withdraw_amount = if_shares_to_vault_amount(
        n_shares,
        spot_market.insurance_fund.total_shares,
        insurance_vault_amount,
    )?;

    spot_market.insurance_fund.total_shares =
        spot_market.insurance_fund.total_shares.safe_sub(n_shares)?;

    let if_shares_after = spot_market
        .insurance_fund
        .total_shares
        .safe_sub(user_if_shares_before)?;

    emit!(InsuranceFundStakeRecord {
        ts: now,
        user_authority: admin_pubkey,
        action: StakeAction::Unstake,
        amount: withdraw_amount,
        market_index: spot_market.market_index,
        insurance_vault_amount_before: insurance_vault_amount,
        if_shares_before,
        user_if_shares_before,
        total_if_shares_before,
        if_shares_after,
        total_if_shares_after: spot_market.insurance_fund.total_shares,
        user_if_shares_after: spot_market.insurance_fund.user_shares,
    });

    Ok(withdraw_amount)
}

pub fn transfer_protocol_insurance_fund_stake(
    insurance_vault_amount: u64,
    n_shares: u128,
    target_insurance_fund_stake: &mut InsuranceFundStake,
    user_stats: &mut UserStats,
    spot_market: &mut SpotMarket,
    now: i64,
    signer_pubkey: Pubkey,
) -> DriftResult<u64> {
    apply_rebase_to_insurance_fund(insurance_vault_amount, spot_market)?;

    let total_if_shares_before = spot_market.insurance_fund.total_shares;
    let user_if_shares_before = spot_market.insurance_fund.user_shares;

    let if_shares_before = total_if_shares_before.safe_sub(user_if_shares_before)?;
    let target_if_shares_before = target_insurance_fund_stake.checked_if_shares(spot_market)?;
    validate!(
        if_shares_before >= n_shares,
        ErrorCode::InsufficientIFShares,
        "if_shares_before={} < n_shares={}",
        if_shares_before,
        n_shares
    )?;

    spot_market.insurance_fund.user_shares =
        spot_market.insurance_fund.user_shares.safe_add(n_shares)?;

    target_insurance_fund_stake.increase_if_shares(n_shares, spot_market)?;

    let target_if_shares_after = target_insurance_fund_stake.checked_if_shares(spot_market)?;

    if spot_market.market_index == QUOTE_SPOT_MARKET_INDEX {
        user_stats.if_staked_quote_asset_amount = if_shares_to_vault_amount(
            target_if_shares_after,
            spot_market.insurance_fund.total_shares,
            insurance_vault_amount,
        )?;
    } else if spot_market.market_index == GOV_SPOT_MARKET_INDEX {
        user_stats.if_staked_gov_token_amount = if_shares_to_vault_amount(
            target_if_shares_after,
            spot_market.insurance_fund.total_shares,
            insurance_vault_amount,
        )?;
    }

    let withdraw_amount = if_shares_to_vault_amount(
        n_shares,
        spot_market.insurance_fund.total_shares,
        insurance_vault_amount,
    )?;
    let user_if_shares_after = spot_market.insurance_fund.user_shares;

    let protocol_if_shares_after = spot_market
        .insurance_fund
        .total_shares
        .safe_sub(user_if_shares_after)?;

    emit!(InsuranceFundStakeRecord {
        ts: now,
        user_authority: signer_pubkey,
        action: StakeAction::UnstakeTransfer,
        amount: withdraw_amount,
        market_index: spot_market.market_index,
        insurance_vault_amount_before: insurance_vault_amount,
        if_shares_before,
        user_if_shares_before,
        total_if_shares_before,
        if_shares_after: protocol_if_shares_after,
        total_if_shares_after: spot_market.insurance_fund.total_shares,
        user_if_shares_after: spot_market.insurance_fund.user_shares,
    });

    emit!(InsuranceFundStakeRecord {
        ts: now,
        user_authority: target_insurance_fund_stake.authority,
        action: StakeAction::StakeTransfer,
        amount: withdraw_amount,
        market_index: spot_market.market_index,
        insurance_vault_amount_before: insurance_vault_amount,
        if_shares_before: target_if_shares_before,
        user_if_shares_before,
        total_if_shares_before,
        if_shares_after: target_insurance_fund_stake.checked_if_shares(spot_market)?,
        total_if_shares_after: spot_market.insurance_fund.total_shares,
        user_if_shares_after: spot_market.insurance_fund.user_shares,
    });

    Ok(withdraw_amount)
}

pub fn attempt_settle_revenue_to_insurance_fund<'info>(
    spot_market_vault: &InterfaceAccount<'info, TokenAccount>,
    insurance_fund_vault: &InterfaceAccount<'info, TokenAccount>,
    spot_market: &mut SpotMarket,
    now: i64,
    token_program: &Interface<'info, TokenInterface>,
    drift_signer: &AccountInfo<'info>,
    state: &State,
    mint: &Option<InterfaceAccount<'info, Mint>>,
    remaining_accounts: Option<&mut Peekable<Iter<'info, AccountInfo<'info>>>>,
) -> Result<()> {
    let valid_revenue_settle_time = if spot_market.insurance_fund.revenue_settle_period > 0 {
        let time_until_next_update = on_the_hour_update(
            now,
            spot_market.insurance_fund.last_revenue_settle_ts,
            spot_market.insurance_fund.revenue_settle_period,
        )?;

        time_until_next_update == 0
    } else {
        false
    };

    let _token_amount = if valid_revenue_settle_time {
        // uses proportion of revenue pool allocated to insurance fund
        let spot_market_vault_amount = spot_market_vault.amount;
        let insurance_fund_vault_amount = insurance_fund_vault.amount;

        let token_amount = settle_revenue_to_insurance_fund(
            spot_market_vault_amount,
            insurance_fund_vault_amount,
            spot_market,
            now,
            false,
        )?;

        if token_amount > 0 {
            msg!(
                "Spot market_index={} sending {} to insurance_fund_vault",
                spot_market.market_index,
                token_amount
            );

            send_from_program_vault(
                token_program,
                spot_market_vault,
                insurance_fund_vault,
                drift_signer,
                state.signer_nonce,
                token_amount.cast()?,
                mint,
                remaining_accounts,
            )?;
        }

        spot_market.insurance_fund.last_revenue_settle_ts = now;

        token_amount
    } else {
        0
    };

    Ok(())
}

pub fn settle_revenue_to_insurance_fund(
    spot_market_vault_amount: u64,
    insurance_vault_amount: u64,
    spot_market: &mut SpotMarket,
    now: i64,
    check_invariants: bool,
) -> DriftResult<u64> {
    update_spot_market_cumulative_interest(spot_market, None, now)?;

    if spot_market.insurance_fund.revenue_settle_period == 0 {
        // revenue pool not configured to settle, ending early
        return Ok(0);
    }

    validate!(
        spot_market.insurance_fund.user_factor <= spot_market.insurance_fund.total_factor,
        ErrorCode::RevenueSettingsCannotSettleToIF,
        "invalid if_factor settings on spot market"
    )?;

    let depositors_claim =
        validate_spot_market_vault_amount(spot_market, spot_market_vault_amount)?;

    let mut token_amount = get_token_amount(
        spot_market.revenue_pool.scaled_balance,
        spot_market,
        &SpotBalanceType::Deposit,
    )?;

    if depositors_claim < token_amount.cast()? {
        // only allow half of withdraw available when utilization is high
        token_amount = depositors_claim.max(0).cast::<u128>()?.safe_div(2)?;
    }

    if spot_market.insurance_fund.user_shares > 0 {
        // only allow MAX_APR_PER_REVENUE_SETTLE_TO_INSURANCE_FUND_VAULT or 1/10th of revenue pool to be settled
        let max_apr_per_revenue_settle: u128 = if spot_market.market_index == GOV_SPOT_MARKET_INDEX
        {
            MAX_APR_PER_REVENUE_SETTLE_TO_INSURANCE_FUND_VAULT_GOV
        } else {
            MAX_APR_PER_REVENUE_SETTLE_TO_INSURANCE_FUND_VAULT
        };

        let capped_apr_amount = insurance_vault_amount
            .cast::<u128>()?
            .safe_mul(max_apr_per_revenue_settle)?
            .safe_div(PERCENTAGE_PRECISION)?
            .safe_div(
                ONE_YEAR
                    .safe_div(spot_market.insurance_fund.revenue_settle_period.cast()?)?
                    .max(1),
            )?;
        let capped_token_pct_amount = token_amount.safe_div(10)?;
        token_amount = capped_token_pct_amount.min(capped_apr_amount);
    }

    let insurance_fund_token_amount = get_proportion_u128(
        token_amount,
        SHARE_OF_REVENUE_ALLOCATED_TO_INSURANCE_FUND_VAULT_NUMERATOR,
        SHARE_OF_REVENUE_ALLOCATED_TO_INSURANCE_FUND_VAULT_DENOMINATOR,
    )?
    .cast::<u64>()?;

    if check_invariants {
        validate!(
            insurance_fund_token_amount != 0,
            ErrorCode::NoRevenueToSettleToIF,
            "no amount to settle to insurance fund"
        )?;
    }

    spot_market.insurance_fund.last_revenue_settle_ts = now;

    let protocol_if_factor = spot_market
        .insurance_fund
        .total_factor
        .safe_sub(spot_market.insurance_fund.user_factor)?;

    // give protocol its cut
    if protocol_if_factor > 0 {
        let n_shares = vault_amount_to_if_shares(
            insurance_fund_token_amount
                .safe_mul(protocol_if_factor.cast()?)?
                .safe_div(spot_market.insurance_fund.total_factor.cast()?)?,
            spot_market.insurance_fund.total_shares,
            insurance_vault_amount,
        )?;

        spot_market.insurance_fund.total_shares =
            spot_market.insurance_fund.total_shares.safe_add(n_shares)?;
    }

    let total_if_shares_before = spot_market.insurance_fund.total_shares;

    update_revenue_pool_balances(
        insurance_fund_token_amount.cast::<u128>()?,
        &SpotBalanceType::Borrow,
        spot_market,
    )?;

    emit!(InsuranceFundRecord {
        ts: now,
        spot_market_index: spot_market.market_index,
        perp_market_index: 0, // todo: make option?
        amount: insurance_fund_token_amount.cast()?,

        user_if_factor: spot_market.insurance_fund.user_factor,
        total_if_factor: spot_market.insurance_fund.total_factor,
        vault_amount_before: spot_market_vault_amount,
        insurance_vault_amount_before: insurance_vault_amount,
        total_if_shares_before,
        total_if_shares_after: spot_market.insurance_fund.total_shares,
    });

    insurance_fund_token_amount.cast()
}

pub fn resolve_perp_pnl_deficit(
    vault_amount: u64,
    insurance_vault_amount: u64,
    spot_market: &mut SpotMarket,
    market: &mut PerpMarket,
    now: i64,
) -> DriftResult<u64> {
    validate!(
        market.amm.total_fee_minus_distributions < 0,
        ErrorCode::NoAmmPerpPnlDeficit,
        "market.amm.total_fee_minus_distributions={} must be negative",
        market.amm.total_fee_minus_distributions
    )?;

    let pnl_pool_token_amount = get_token_amount(
        market.pnl_pool.scaled_balance,
        spot_market,
        &SpotBalanceType::Deposit,
    )?;

    let net_user_pnl = calculate_net_user_pnl(
        &market.amm,
        market
            .amm
            .historical_oracle_data
            .last_oracle_price_twap_5min,
    )?;

    validate!(
        pnl_pool_token_amount.cast::<i128>()? < net_user_pnl,
        ErrorCode::SufficientPerpPnlPool,
        "pnl_pool_token_amount >= net_user_pnl ({} >= {})",
        pnl_pool_token_amount,
        net_user_pnl
    )?;

    update_spot_market_cumulative_interest(spot_market, None, now)?;

    let total_if_shares_before = spot_market.insurance_fund.total_shares;

    let excess_user_pnl_imbalance = if market.unrealized_pnl_max_imbalance > 0 {
        let net_unsettled_pnl = calculate_net_user_pnl(
            &market.amm,
            market.amm.historical_oracle_data.last_oracle_price,
        )?;

        net_unsettled_pnl.safe_sub(market.unrealized_pnl_max_imbalance.cast()?)?
    } else {
        0
    };

    validate!(
        excess_user_pnl_imbalance > 0,
        ErrorCode::PerpPnlDeficitBelowThreshold,
        "No excess_user_pnl_imbalance({}) to settle",
        excess_user_pnl_imbalance
    )?;

    let max_revenue_withdraw_per_period = market
        .insurance_claim
        .max_revenue_withdraw_per_period
        .cast::<i128>()?
        .safe_sub(
            market
                .insurance_claim
                .revenue_withdraw_since_last_settle
                .cast()?,
        )?
        .cast::<i128>()?;
    validate!(
        max_revenue_withdraw_per_period > 0,
        ErrorCode::MaxRevenueWithdrawPerPeriodReached,
        "max_revenue_withdraw_per_period={} as already been reached",
        max_revenue_withdraw_per_period
    )?;

    let max_insurance_withdraw = market
        .insurance_claim
        .quote_max_insurance
        .safe_sub(market.insurance_claim.quote_settled_insurance)?
        .cast::<i128>()?;

    validate!(
        max_insurance_withdraw > 0,
        ErrorCode::MaxIFWithdrawReached,
        "max_insurance_withdraw={}/{} as already been reached",
        market.insurance_claim.quote_settled_insurance,
        market.insurance_claim.quote_max_insurance,
    )?;

    let insurance_withdraw = excess_user_pnl_imbalance
        .min(max_revenue_withdraw_per_period)
        .min(max_insurance_withdraw)
        .min(insurance_vault_amount.saturating_sub(1).cast()?);

    validate!(
        insurance_withdraw > 0,
        ErrorCode::NoIFWithdrawAvailable,
        "No available funds for insurance_withdraw({}) for user_pnl_imbalance={}",
        insurance_withdraw,
        excess_user_pnl_imbalance
    )?;

    market.amm.total_fee_minus_distributions = market
        .amm
        .total_fee_minus_distributions
        .safe_add(insurance_withdraw)?;

    market.insurance_claim.revenue_withdraw_since_last_settle = market
        .insurance_claim
        .revenue_withdraw_since_last_settle
        .safe_add(insurance_withdraw.cast()?)?;

    market.insurance_claim.quote_settled_insurance = market
        .insurance_claim
        .quote_settled_insurance
        .safe_add(insurance_withdraw.cast()?)?;

    validate!(
        market.insurance_claim.quote_settled_insurance
            <= market.insurance_claim.quote_max_insurance,
        ErrorCode::MaxIFWithdrawReached,
        "quote_settled_insurance breached its max {}/{}",
        market.insurance_claim.quote_settled_insurance,
        market.insurance_claim.quote_max_insurance,
    )?;

    market.insurance_claim.last_revenue_withdraw_ts = now;

    update_spot_balances(
        insurance_withdraw.cast()?,
        &SpotBalanceType::Deposit,
        spot_market,
        &mut market.pnl_pool,
        false,
    )?;

    emit!(InsuranceFundRecord {
        ts: now,
        spot_market_index: spot_market.market_index,
        perp_market_index: market.market_index,
        amount: -insurance_withdraw.cast()?,
        user_if_factor: spot_market.insurance_fund.user_factor,
        total_if_factor: spot_market.insurance_fund.total_factor,
        vault_amount_before: vault_amount,
        insurance_vault_amount_before: insurance_vault_amount,
        total_if_shares_before,
        total_if_shares_after: spot_market.insurance_fund.total_shares,
    });

    insurance_withdraw.cast()
}

pub fn handle_if_begin_swap(
    if_rebalance_config: &mut IfRebalanceConfig,
    in_insurance_fund_vault_amount: u64,
    out_insurance_fund_vault_amount: u64,
    in_spot_market: &mut SpotMarket,
    out_spot_market: &mut SpotMarket,
    _in_amount: u64,
    now: i64,
) -> DriftResult<()> {
    if now
        > if_rebalance_config
            .epoch_start_ts
            .safe_add(if_rebalance_config.epoch_duration)?
    {
        if_rebalance_config.epoch_start_ts = now;
        if_rebalance_config.epoch_in_amount = 0;
    }

    apply_rebase_to_insurance_fund(in_insurance_fund_vault_amount, in_spot_market)?;
    apply_rebase_to_insurance_fund(out_insurance_fund_vault_amount, out_spot_market)?;

    Ok(())
}

pub fn handle_if_end_swap(
    if_rebalance_config: &mut IfRebalanceConfig,
    in_insurance_fund_vault_amount_after: u64,
    out_insurance_fund_vault_amount_after: u64,
    in_spot_market: &mut SpotMarket,
    out_spot_market: &mut SpotMarket,
    in_amount: u64,
    out_amount: u64,
    out_oracle_price: u64,
    now: i64,
) -> DriftResult<()> {
    let in_insurance_fund_vault_amount_before =
        in_insurance_fund_vault_amount_after.safe_add(in_amount)?;
    let out_insurance_fund_vault_amount_before =
        out_insurance_fund_vault_amount_after.safe_sub(out_amount)?;

    let in_if_total_shares_before = in_spot_market.insurance_fund.total_shares;
    let out_if_total_shares_before = out_spot_market.insurance_fund.total_shares;
    let in_if_user_shares_before = in_spot_market.insurance_fund.user_shares;
    let out_if_user_shares_before = out_spot_market.insurance_fund.user_shares;

    let in_share_price_before = calculate_share_price(
        in_spot_market.insurance_fund.total_shares,
        in_insurance_fund_vault_amount_before,
    )?;
    let out_share_price_before = calculate_share_price(
        out_spot_market.insurance_fund.total_shares,
        out_insurance_fund_vault_amount_before,
    )?;

    let in_shares = vault_amount_to_if_shares(
        in_amount,
        in_spot_market.insurance_fund.total_shares,
        in_insurance_fund_vault_amount_before,
    )?;
    let out_shares = vault_amount_to_if_shares(
        out_amount,
        out_spot_market.insurance_fund.total_shares,
        out_insurance_fund_vault_amount_before,
    )?;

    // validate shares less than protocol shares
    validate!(
        in_shares < in_spot_market.insurance_fund.get_protocol_shares()?,
        ErrorCode::InsufficientIFShares,
        "in_shares={} < total_shares={}",
        in_shares,
        in_spot_market.insurance_fund.get_protocol_shares()?
    )?;

    // increment spot market insurance funds total shares
    in_spot_market.insurance_fund.total_shares = in_spot_market
        .insurance_fund
        .total_shares
        .safe_sub(in_shares)?;
    out_spot_market.insurance_fund.total_shares = out_spot_market
        .insurance_fund
        .total_shares
        .safe_add(out_shares)?;

    let in_share_price_after = calculate_share_price(
        in_spot_market.insurance_fund.total_shares,
        in_insurance_fund_vault_amount_after,
    )?;
    let out_share_price_after = calculate_share_price(
        out_spot_market.insurance_fund.total_shares,
        out_insurance_fund_vault_amount_after,
    )?;

    if in_share_price_before > 0 && in_share_price_after > 0 {
        validate!(
            in_share_price_before - in_share_price_after <= 1,
            ErrorCode::InvalidIfRebalanceSwap,
            "in_share_price_before={} - in_share_price_after={} > 1",
            in_share_price_before,
            in_share_price_after
        )?;
    }

    if out_share_price_before > 0 && out_share_price_after > 0 {
        validate!(
            out_share_price_before - out_share_price_after <= 1,
            ErrorCode::InvalidIfRebalanceSwap,
            "out_share_price_before={} - out_share_price_after={} > 1",
            out_share_price_before,
            out_share_price_after
        )?;
    }

    // increment config current in amount
    if_rebalance_config.current_in_amount =
        if_rebalance_config.current_in_amount.safe_add(in_amount)?;
    if_rebalance_config.epoch_in_amount =
        if_rebalance_config.epoch_in_amount.safe_add(in_amount)?;
    // increment config current out amount
    if_rebalance_config.current_out_amount = if_rebalance_config
        .current_out_amount
        .safe_add(out_amount)?;

    validate!(
        if_rebalance_config.epoch_in_amount <= if_rebalance_config.epoch_max_in_amount,
        ErrorCode::InvalidIfRebalanceSwap,
        "epoch_in_amount={} > epoch_max_in_amount={}",
        if_rebalance_config.epoch_in_amount,
        if_rebalance_config.epoch_max_in_amount
    )?;

    validate!(
        if_rebalance_config.current_in_amount <= if_rebalance_config.total_in_amount,
        ErrorCode::InvalidIfRebalanceSwap,
        "current_in_amount={} > total_in_amount={}",
        if_rebalance_config.current_in_amount,
        if_rebalance_config.total_in_amount
    )?;

    let oracle_twap = out_spot_market
        .historical_oracle_data
        .last_oracle_price_twap;

    validate!(
        out_oracle_price <= oracle_twap.cast::<u64>()?,
        ErrorCode::InvalidIfRebalanceSwap,
        "out_oracle_price={} > oracle_twap={}",
        out_oracle_price,
        oracle_twap
    )?;

    let swap_price = calculate_fill_price(in_amount, out_amount, out_spot_market.get_precision())?;

    let max_slippage_bps = if_rebalance_config.max_slippage_bps.cast::<u64>()?;
    let max_slippage = out_oracle_price / (10000 / max_slippage_bps.max(1));

    validate!(
        swap_price <= out_oracle_price.safe_add(max_slippage)?,
        ErrorCode::InvalidIfRebalanceSwap,
        "swap_price={} > out_oracle_price={} + max_slippage={}",
        swap_price,
        out_oracle_price,
        max_slippage
    )?;

    emit!(InsuranceFundSwapRecord {
        ts: now,
        rebalance_config: if_rebalance_config.pubkey,
        in_market_index: if_rebalance_config.in_market_index,
        out_market_index: if_rebalance_config.out_market_index,
        in_amount,
        out_amount,
        out_oracle_price,
        out_oracle_price_twap: oracle_twap,
        in_vault_amount_before: in_insurance_fund_vault_amount_before,
        out_vault_amount_before: out_insurance_fund_vault_amount_before,
        in_fund_vault_amount_after: in_insurance_fund_vault_amount_after,
        out_fund_vault_amount_after: out_insurance_fund_vault_amount_after,
        in_if_total_shares_before,
        out_if_total_shares_before,
        in_if_user_shares_before,
        out_if_user_shares_before,
        in_if_total_shares_after: in_spot_market.insurance_fund.total_shares,
        out_if_total_shares_after: out_spot_market.insurance_fund.total_shares,
        in_if_user_shares_after: in_spot_market.insurance_fund.user_shares,
        out_if_user_shares_after: out_spot_market.insurance_fund.user_shares,
    });

    Ok(())
}

pub fn transfer_protocol_if_shares_to_revenue_pool(
    if_rebalance_config: &mut IfRebalanceConfig,
    spot_market: &mut SpotMarket,
    insurance_fund_vault_amount_before: u64,
    amount: u64,
    now: i64,
) -> DriftResult<()> {
    apply_rebase_to_insurance_fund(insurance_fund_vault_amount_before, spot_market)?;

    let shares = vault_amount_to_if_shares(
        amount,
        spot_market.insurance_fund.total_shares,
        insurance_fund_vault_amount_before,
    )?;

    let protocol_shares = spot_market.insurance_fund.get_protocol_shares()?;

    validate!(
        shares <= protocol_shares,
        ErrorCode::InsufficientIFShares,
        "shares={} > protocol_shares={}",
        shares,
        protocol_shares
    )?;

    validate!(
        amount <= if_rebalance_config.max_transfer_amount()?,
        ErrorCode::DefaultError,
        "amount={} > max_transfer_amount={}",
        amount,
        if_rebalance_config.max_transfer_amount()?
    )?;

    spot_market.insurance_fund.total_shares =
        spot_market.insurance_fund.total_shares.safe_sub(shares)?;

    update_revenue_pool_balances(amount.cast()?, &SpotBalanceType::Deposit, spot_market)?;

    if_rebalance_config.current_out_amount_transferred = if_rebalance_config
        .current_out_amount_transferred
        .safe_add(amount)?;

    emit!(TransferProtocolIfSharesToRevenuePoolRecord {
        ts: now,
        market_index: spot_market.market_index,
        amount,
        shares,
        if_vault_amount_before: insurance_fund_vault_amount_before,
        protocol_shares_before: protocol_shares,
        transfer_amount: amount,
    });

    Ok(())
}



================================================
FILE: programs/drift/src/controller/lp.rs
================================================
use anchor_lang::prelude::{msg, Pubkey};

use crate::bn::U192;
use crate::controller;
use crate::controller::position::update_position_and_market;
use crate::controller::position::{get_position_index, PositionDelta};
use crate::emit;
use crate::error::{DriftResult, ErrorCode};
use crate::get_struct_values;
use crate::math::casting::Cast;
use crate::math::cp_curve::{get_update_k_result, update_k};
use crate::math::lp::calculate_settle_lp_metrics;
use crate::math::position::calculate_base_asset_value_with_oracle_price;
use crate::math::safe_math::SafeMath;

use crate::state::events::{LPAction, LPRecord};
use crate::state::oracle_map::OracleMap;
use crate::state::perp_market::PerpMarket;
use crate::state::perp_market_map::PerpMarketMap;
use crate::state::state::State;
use crate::state::user::PerpPosition;
use crate::state::user::User;
use crate::validate;
use anchor_lang::prelude::Account;

#[cfg(test)]
mod tests;

pub fn apply_lp_rebase_to_perp_market(
    perp_market: &mut PerpMarket,
    expo_diff: i8,
) -> DriftResult<()> {
    // target_base_asset_amount_per_lp is the only one that it doesnt get applied
    // thus changing the base of lp and without changing target_base_asset_amount_per_lp
    // causes an implied change

    validate!(expo_diff != 0, ErrorCode::DefaultError, "expo_diff = 0")?;

    perp_market.amm.per_lp_base = perp_market.amm.per_lp_base.safe_add(expo_diff)?;
    let rebase_divisor: i128 = 10_i128.pow(expo_diff.abs().cast()?);

    if expo_diff > 0 {
        perp_market.amm.base_asset_amount_per_lp = perp_market
            .amm
            .base_asset_amount_per_lp
            .safe_mul(rebase_divisor)?;

        perp_market.amm.quote_asset_amount_per_lp = perp_market
            .amm
            .quote_asset_amount_per_lp
            .safe_mul(rebase_divisor)?;
    } else {
        perp_market.amm.base_asset_amount_per_lp = perp_market
            .amm
            .base_asset_amount_per_lp
            .safe_div(rebase_divisor)?;

        perp_market.amm.quote_asset_amount_per_lp = perp_market
            .amm
            .quote_asset_amount_per_lp
            .safe_div(rebase_divisor)?;
    }

    msg!(
        "rebasing perp market_index={} per_lp_base expo_diff={}",
        perp_market.market_index,
        expo_diff,
    );

    crate::validation::perp_market::validate_perp_market(perp_market)?;

    Ok(())
}

pub fn apply_lp_rebase_to_perp_position(
    perp_market: &PerpMarket,
    perp_position: &mut PerpPosition,
) -> DriftResult<()> {
    let expo_diff = perp_market
        .amm
        .per_lp_base
        .safe_sub(perp_position.per_lp_base)?;

    if expo_diff > 0 {
        let rebase_divisor: i64 = 10_i64.pow(expo_diff.cast()?);

        perp_position.last_base_asset_amount_per_lp = perp_position
            .last_base_asset_amount_per_lp
            .safe_mul(rebase_divisor)?;
        perp_position.last_quote_asset_amount_per_lp = perp_position
            .last_quote_asset_amount_per_lp
            .safe_mul(rebase_divisor)?;

        msg!(
            "rebasing perp position for market_index={} per_lp_base by expo_diff={}",
            perp_market.market_index,
            expo_diff,
        );
    } else if expo_diff < 0 {
        let rebase_divisor: i64 = 10_i64.pow(expo_diff.abs().cast()?);

        perp_position.last_base_asset_amount_per_lp = perp_position
            .last_base_asset_amount_per_lp
            .safe_div(rebase_divisor)?;
        perp_position.last_quote_asset_amount_per_lp = perp_position
            .last_quote_asset_amount_per_lp
            .safe_div(rebase_divisor)?;

        msg!(
            "rebasing perp position for market_index={} per_lp_base by expo_diff={}",
            perp_market.market_index,
            expo_diff,
        );
    }

    perp_position.per_lp_base = perp_position.per_lp_base.safe_add(expo_diff)?;

    Ok(())
}

pub fn mint_lp_shares(
    position: &mut PerpPosition,
    market: &mut PerpMarket,
    n_shares: u64,
) -> DriftResult<()> {
    let amm = market.amm;

    let (sqrt_k,) = get_struct_values!(amm, sqrt_k);

    if position.lp_shares > 0 {
        settle_lp_position(position, market)?;
    } else {
        position.last_base_asset_amount_per_lp = amm.base_asset_amount_per_lp.cast()?;
        position.last_quote_asset_amount_per_lp = amm.quote_asset_amount_per_lp.cast()?;
        position.per_lp_base = amm.per_lp_base;
    }

    // add share balance
    position.lp_shares = position.lp_shares.safe_add(n_shares)?;

    // update market state
    let new_sqrt_k = sqrt_k.safe_add(n_shares.cast()?)?;
    let new_sqrt_k_u192 = U192::from(new_sqrt_k);

    let update_k_result = get_update_k_result(market, new_sqrt_k_u192, true)?;
    update_k(market, &update_k_result)?;

    market.amm.user_lp_shares = market.amm.user_lp_shares.safe_add(n_shares.cast()?)?;

    crate::validation::perp_market::validate_perp_market(market)?;
    crate::validation::position::validate_perp_position_with_perp_market(position, market)?;

    Ok(())
}

pub fn settle_lp_position(
    position: &mut PerpPosition,
    market: &mut PerpMarket,
) -> DriftResult<(PositionDelta, i64)> {
    if position.base_asset_amount > 0 {
        validate!(
            position.last_cumulative_funding_rate.cast::<i128>()?
                == market.amm.cumulative_funding_rate_long,
            ErrorCode::InvalidPerpPositionDetected
        )?;
    } else if position.base_asset_amount < 0 {
        validate!(
            position.last_cumulative_funding_rate.cast::<i128>()?
                == market.amm.cumulative_funding_rate_short,
            ErrorCode::InvalidPerpPositionDetected
        )?;
    }

    apply_lp_rebase_to_perp_position(market, position)?;

    let lp_metrics: crate::math::lp::LPMetrics =
        calculate_settle_lp_metrics(&market.amm, position)?;

    let position_delta = PositionDelta {
        base_asset_amount: lp_metrics.base_asset_amount.cast()?,
        quote_asset_amount: lp_metrics.quote_asset_amount.cast()?,
        remainder_base_asset_amount: Some(lp_metrics.remainder_base_asset_amount.cast::<i64>()?),
    };

    let pnl: i64 = update_position_and_market(position, market, &position_delta)?;

    position.last_base_asset_amount_per_lp = market.amm.base_asset_amount_per_lp.cast()?;
    position.last_quote_asset_amount_per_lp = market.amm.quote_asset_amount_per_lp.cast()?;

    crate::validation::perp_market::validate_perp_market(market)?;
    crate::validation::position::validate_perp_position_with_perp_market(position, market)?;

    Ok((position_delta, pnl))
}

pub fn settle_lp(
    user: &mut User,
    user_key: &Pubkey,
    market: &mut PerpMarket,
    now: i64,
) -> DriftResult {
    if let Ok(position) = user.get_perp_position_mut(market.market_index) {
        if position.lp_shares > 0 {
            let (position_delta, pnl) = settle_lp_position(position, market)?;

            if position_delta.base_asset_amount != 0 || position_delta.quote_asset_amount != 0 {
                crate::emit!(LPRecord {
                    ts: now,
                    action: LPAction::SettleLiquidity,
                    user: *user_key,
                    market_index: market.market_index,
                    delta_base_asset_amount: position_delta.base_asset_amount,
                    delta_quote_asset_amount: position_delta.quote_asset_amount,
                    pnl,
                    n_shares: 0
                });
            }
        }
    }

    Ok(())
}

// note: must settle funding before settling the lp bc
// settling the lp can take on a new position which requires funding
// to be up-to-date
pub fn settle_funding_payment_then_lp(
    user: &mut User,
    user_key: &Pubkey,
    market: &mut PerpMarket,
    now: i64,
) -> DriftResult {
    crate::controller::funding::settle_funding_payment(user, user_key, market, now)?;
    settle_lp(user, user_key, market, now)
}

pub fn burn_lp_shares(
    position: &mut PerpPosition,
    market: &mut PerpMarket,
    shares_to_burn: u64,
    oracle_price: i64,
) -> DriftResult<(PositionDelta, i64)> {
    // settle
    let (mut position_delta, mut pnl) = settle_lp_position(position, market)?;

    // clean up
    let unsettled_remainder = market
        .amm
        .base_asset_amount_with_unsettled_lp
        .safe_add(position.remainder_base_asset_amount.cast()?)?;
    if shares_to_burn as u128 == market.amm.user_lp_shares && unsettled_remainder != 0 {
        // sub bc lps take the opposite side of the user
        position.remainder_base_asset_amount = position
            .remainder_base_asset_amount
            .safe_sub(unsettled_remainder.cast()?)?;
    }

    // update stats
    if position.remainder_base_asset_amount != 0 {
        let base_asset_amount = position.remainder_base_asset_amount as i128;

        // user closes the dust
        market.amm.base_asset_amount_with_amm = market
            .amm
            .base_asset_amount_with_amm
            .safe_sub(base_asset_amount)?;

        market.amm.base_asset_amount_with_unsettled_lp = market
            .amm
            .base_asset_amount_with_unsettled_lp
            .safe_add(base_asset_amount)?;

        let dust_base_asset_value = calculate_base_asset_value_with_oracle_price(base_asset_amount, oracle_price)?
                .safe_add(1) // round up
                ?;

        let dust_burn_position_delta = PositionDelta {
            base_asset_amount: 0,
            quote_asset_amount: -dust_base_asset_value.cast()?,
            remainder_base_asset_amount: Some(-position.remainder_base_asset_amount.cast()?),
        };

        update_position_and_market(position, market, &dust_burn_position_delta)?;

        msg!(
            "perp {} remainder_base_asset_amount burn fee= {}",
            position.market_index,
            dust_base_asset_value
        );

        position_delta.quote_asset_amount = position_delta
            .quote_asset_amount
            .safe_sub(dust_base_asset_value.cast()?)?;
        pnl = pnl.safe_sub(dust_base_asset_value.cast()?)?;
    }

    // update last_ metrics
    position.last_base_asset_amount_per_lp = market.amm.base_asset_amount_per_lp.cast()?;
    position.last_quote_asset_amount_per_lp = market.amm.quote_asset_amount_per_lp.cast()?;

    // burn shares
    position.lp_shares = position.lp_shares.safe_sub(shares_to_burn)?;

    market.amm.user_lp_shares = market.amm.user_lp_shares.safe_sub(shares_to_burn.cast()?)?;

    // update market state
    let new_sqrt_k = market.amm.sqrt_k.safe_sub(shares_to_burn.cast()?)?;
    let new_sqrt_k_u192 = U192::from(new_sqrt_k);

    let update_k_result = get_update_k_result(market, new_sqrt_k_u192, false)?;
    update_k(market, &update_k_result)?;

    crate::validation::perp_market::validate_perp_market(market)?;
    crate::validation::position::validate_perp_position_with_perp_market(position, market)?;

    Ok((position_delta, pnl))
}

pub fn remove_perp_lp_shares(
    perp_market_map: PerpMarketMap,
    oracle_map: &mut OracleMap,
    state: &Account<State>,
    user: &mut std::cell::RefMut<User>,
    user_key: Pubkey,
    shares_to_burn: u64,
    market_index: u16,
    now: i64,
) -> DriftResult<()> {
    let position_index = get_position_index(&user.perp_positions, market_index)?;

    // standardize n shares to burn
    // account for issue where lp shares are smaller than step size
    let shares_to_burn = if user.perp_positions[position_index].lp_shares == shares_to_burn {
        shares_to_burn
    } else {
        let market = perp_market_map.get_ref(&market_index)?;
        crate::math::orders::standardize_base_asset_amount(
            shares_to_burn.cast()?,
            market.amm.order_step_size,
        )?
        .cast()?
    };

    if shares_to_burn == 0 {
        return Ok(());
    }

    let mut market = perp_market_map.get_ref_mut(&market_index)?;

    let time_since_last_add_liquidity = now.safe_sub(user.last_add_perp_lp_shares_ts)?;

    validate!(
        time_since_last_add_liquidity >= state.lp_cooldown_time.cast()?,
        ErrorCode::TryingToRemoveLiquidityTooFast
    )?;

    controller::funding::settle_funding_payment(user, &user_key, &mut market, now)?;

    let position = &mut user.perp_positions[position_index];

    validate!(
        position.lp_shares >= shares_to_burn,
        ErrorCode::InsufficientLPTokens
    )?;

    let oracle_price = oracle_map.get_price_data(&market.oracle_id())?.price;
    let (position_delta, pnl) =
        burn_lp_shares(position, &mut market, shares_to_burn, oracle_price)?;

    emit!(LPRecord {
        ts: now,
        action: LPAction::RemoveLiquidity,
        user: user_key,
        n_shares: shares_to_burn,
        market_index,
        delta_base_asset_amount: position_delta.base_asset_amount,
        delta_quote_asset_amount: position_delta.quote_asset_amount,
        pnl,
    });

    Ok(())
}



================================================
FILE: programs/drift/src/controller/mod.rs
================================================
pub mod amm;
pub mod funding;
pub mod insurance;
pub mod liquidation;
pub mod orders;
pub mod pda;
pub mod pnl;
pub mod position;
pub mod repeg;
pub mod revenue_share;
pub mod spot_balance;
pub mod spot_position;
pub mod token;



================================================
FILE: programs/drift/src/controller/pda.rs
================================================
use crate::error::{DriftResult, ErrorCode};
use crate::msg;
use crate::validate;
use anchor_lang::prelude::{AccountInfo, Pubkey};
use solana_program::rent::Rent;

pub fn seed_and_create_pda<'a>(
    program_id: &Pubkey,
    funder: &AccountInfo<'a>,
    rent: &Rent,
    space: usize,
    owner: &Pubkey,
    system_program: &AccountInfo<'a>,
    pda_account: &AccountInfo<'a>,
    seeds: &[&[u8]],
) -> DriftResult {
    let (pda_address, bump) = Pubkey::find_program_address(seeds, program_id);
    validate!(&pda_address == pda_account.key, ErrorCode::InvalidPDA)?;

    let bump_seed = [bump];
    let pda_signer_seeds: &[&[&[u8]]] = &[&[seeds, &[&bump_seed]].concat()];

    if pda_account.lamports() > 0 {
        let required_lamports = rent
            .minimum_balance(space)
            .max(1)
            .saturating_sub(pda_account.lamports());

        if required_lamports > 0 {
            solana_program::program::invoke_signed_unchecked(
                &solana_program::system_instruction::transfer(
                    funder.key,
                    pda_account.key,
                    required_lamports,
                ),
                &[funder.clone(), pda_account.clone(), system_program.clone()],
                pda_signer_seeds,
            )
            .map_err(|e| {
                msg!("{:?}", e);
                ErrorCode::DefaultError
            })?;
        }

        solana_program::program::invoke_signed_unchecked(
            &solana_program::system_instruction::allocate(pda_account.key, space as u64),
            &[pda_account.clone(), system_program.clone()],
            pda_signer_seeds,
        )
        .map_err(|e| {
            msg!("{:?}", e);
            ErrorCode::DefaultError
        })?;

        solana_program::program::invoke_signed_unchecked(
            &solana_program::system_instruction::assign(pda_account.key, owner),
            &[pda_account.clone(), system_program.clone()],
            pda_signer_seeds,
        )
        .map_err(|e| {
            msg!("{:?}", e);
            ErrorCode::DefaultError
        })?;
    } else {
        solana_program::program::invoke_signed_unchecked(
            &solana_program::system_instruction::create_account(
                funder.key,
                pda_account.key,
                rent.minimum_balance(space).max(1),
                space as u64,
                owner,
            ),
            &[funder.clone(), pda_account.clone(), system_program.clone()],
            pda_signer_seeds,
        )
        .map_err(|e| {
            msg!("{:?}", e);
            ErrorCode::InvalidPDASigner
        })?;
    }

    Ok(())
}



================================================
FILE: programs/drift/src/controller/pnl.rs
================================================
use crate::controller::amm::{update_pnl_pool_and_user_balance, update_pool_balances};
use crate::controller::funding::settle_funding_payment;
use crate::controller::orders::{cancel_orders, validate_market_within_price_band};
use crate::controller::position::{
    get_position_index, update_position_and_market, update_quote_asset_amount,
    update_quote_asset_and_break_even_amount, update_settled_pnl, PositionDelta,
};
use crate::controller::spot_balance::{
    update_spot_balances, update_spot_market_cumulative_interest,
};
use crate::error::{DriftResult, ErrorCode};
use crate::math::amm::calculate_net_user_pnl;
use crate::math::oracle::{is_oracle_valid_for_action, DriftAction};

use crate::math::casting::Cast;
use crate::math::margin::{
    meets_maintenance_margin_requirement, meets_settle_pnl_maintenance_margin_requirement,
};
use crate::math::position::calculate_base_asset_value_with_expiry_price;
use crate::math::safe_math::SafeMath;
use crate::math::spot_balance::get_token_amount;

use crate::msg;
use crate::state::events::{OrderActionExplanation, SettlePnlExplanation, SettlePnlRecord};
use crate::state::oracle_map::OracleMap;
use crate::state::paused_operations::PerpOperation;
use crate::state::perp_market::MarketStatus;
use crate::state::perp_market_map::PerpMarketMap;
use crate::state::settle_pnl_mode::SettlePnlMode;
use crate::state::spot_market::{SpotBalance, SpotBalanceType};
use crate::state::spot_market_map::SpotMarketMap;
use crate::state::state::State;
use crate::state::user::{MarketType, User};
use crate::validate;
use anchor_lang::prelude::Pubkey;
use anchor_lang::prelude::*;
use std::ops::DerefMut;

#[cfg(test)]
mod tests;

#[cfg(test)]
mod delisting;

pub fn settle_pnl(
    market_index: u16,
    user: &mut User,
    authority: &Pubkey,
    user_key: &Pubkey,
    perp_market_map: &PerpMarketMap,
    spot_market_map: &SpotMarketMap,
    oracle_map: &mut OracleMap,
    clock: &Clock,
    state: &State,
    meets_margin_requirement: Option<bool>,
    mut mode: SettlePnlMode,
) -> DriftResult {
    validate!(!user.is_bankrupt(), ErrorCode::UserBankrupt)?;
    let now = clock.unix_timestamp;
    let tvl_before;
    let deposits_balance_before;
    let borrows_balance_before;
    {
        let spot_market = &mut spot_market_map.get_quote_spot_market_mut()?;
        update_spot_market_cumulative_interest(spot_market, None, now)?;

        tvl_before = spot_market.get_tvl()?;
        deposits_balance_before = spot_market.deposit_balance;
        borrows_balance_before = spot_market.borrow_balance;
    }

    let mut market = perp_market_map.get_ref_mut(&market_index)?;

    let oracle_price = oracle_map.get_price_data(&market.oracle_id())?.price;

    validate_market_within_price_band(&market, state, oracle_price)?;

    settle_funding_payment(user, user_key, &mut market, now)?;

    drop(market);

    let position_index = match get_position_index(&user.perp_positions, market_index) {
        Ok(index) => index,
        Err(e) => {
            return mode.result(
                e,
                market_index,
                &format!("User has no position in market {}", market_index),
            )
        }
    };
    let unrealized_pnl = user.perp_positions[position_index].get_unrealized_pnl(oracle_price)?;

    // cannot settle negative pnl this way on a user who is in liquidation territory
    if unrealized_pnl < 0 {
        // may already be cached
        let meets_margin_requirement = match meets_margin_requirement {
            Some(meets_margin_requirement) => meets_margin_requirement,
            None => meets_settle_pnl_maintenance_margin_requirement(
                user,
                perp_market_map,
                spot_market_map,
                oracle_map,
            )?,
        };

        // cannot settle pnl this way on a user who is in liquidation territory
        if !meets_margin_requirement {
            let msg = format!(
                "Does not meet margin requirement while settling Market = {}",
                market_index
            );
            return mode.result(
                ErrorCode::InsufficientCollateralForSettlingPNL,
                market_index,
                &msg,
            );
        }
    }

    let spot_market = &mut spot_market_map.get_quote_spot_market_mut()?;
    let perp_market = &mut perp_market_map.get_ref_mut(&market_index)?;

    if perp_market.amm.curve_update_intensity > 0 {
        let healthy_oracle = perp_market.amm.is_recent_oracle_valid(oracle_map.slot)?;

        if !healthy_oracle {
            let (_, oracle_validity) = oracle_map.get_price_data_and_validity(
                MarketType::Perp,
                perp_market.market_index,
                &perp_market.oracle_id(),
                perp_market
                    .amm
                    .historical_oracle_data
                    .last_oracle_price_twap,
                perp_market.get_max_confidence_interval_multiplier()?,
                0,
                0,
                None,
            )?;

            if !is_oracle_valid_for_action(oracle_validity, Some(DriftAction::SettlePnl))?
                || !perp_market.is_price_divergence_ok_for_settle_pnl(oracle_price)?
            {
                if !perp_market.amm.last_oracle_valid {
                    let msg = format!(
                        "Oracle Price detected as invalid ({}) on last perp market update for Market = {}",
                        oracle_validity,
                        market_index
                    );
                    return mode.result(oracle_validity.get_error_code(), market_index, &msg);
                }

                if oracle_map.slot != perp_market.amm.last_update_slot {
                    let msg = format!(
                        "Market={} AMM must be updated in a prior instruction within same slot (current={} != amm={}, last_oracle_valid={})",
                        market_index,
                        oracle_map.slot,
                        perp_market.amm.last_update_slot,
                        perp_market.amm.last_oracle_valid
                    );
                    return mode.result(ErrorCode::AMMNotUpdatedInSameSlot, market_index, &msg);
                }
            }
        }
    }

    if perp_market.is_operation_paused(PerpOperation::SettlePnl) {
        let msg = format!(
            "Cannot settle pnl under current market = {} status",
            market_index
        );
        return mode.result(
            ErrorCode::InvalidMarketStatusToSettlePnl,
            market_index,
            &msg,
        );
    }

    let base_asset_amount = user.perp_positions[position_index].base_asset_amount;
    if base_asset_amount != 0 {
        if perp_market.is_operation_paused(PerpOperation::SettlePnlWithPosition) {
            let msg = format!(
                "Cannot settle pnl with position under current market = {} operation paused",
                market_index
            );
            return mode.result(
                ErrorCode::InvalidMarketStatusToSettlePnl,
                market_index,
                &msg,
            );
        }

        if perp_market.status != MarketStatus::Active {
            let msg = format!(
                "Cannot settle pnl with position under non-Active current market = {} status",
                market_index
            );
            return mode.result(
                ErrorCode::InvalidMarketStatusToSettlePnl,
                market_index,
                &msg,
            );
        }
    } else if perp_market.status != MarketStatus::Active
        && perp_market.status != MarketStatus::ReduceOnly
    {
        let msg = format!(
            "Cannot settle pnl under current market = {} status (neither Active or ReduceOnly)",
            market_index
        );
        return mode.result(
            ErrorCode::InvalidMarketStatusToSettlePnl,
            market_index,
            &msg,
        );
    }

    let pnl_pool_token_amount = get_token_amount(
        perp_market.pnl_pool.scaled_balance,
        spot_market,
        perp_market.pnl_pool.balance_type(),
    )?;

    let fraction_of_fee_pool_token_amount = get_token_amount(
        perp_market.amm.fee_pool.scaled_balance,
        spot_market,
        perp_market.amm.fee_pool.balance_type(),
    )?
    .safe_div(5)?;

    // add a buffer from fee pool for pnl pool balance
    let pnl_tokens_available: i128 = pnl_pool_token_amount
        .safe_add(fraction_of_fee_pool_token_amount)?
        .cast()?;

    let net_user_pnl = calculate_net_user_pnl(&perp_market.amm, oracle_price)?;
    let max_pnl_pool_excess = if net_user_pnl < pnl_tokens_available {
        pnl_tokens_available.safe_sub(net_user_pnl.max(0))?
    } else {
        0
    };

    let user_unsettled_pnl: i128 =
        user.perp_positions[position_index].get_claimable_pnl(oracle_price, max_pnl_pool_excess)?;

    let pnl_to_settle_with_user = update_pool_balances(
        perp_market,
        spot_market,
        user.get_quote_spot_position(),
        user_unsettled_pnl,
        now,
    )?;

    // if the spot market balance has changed, we have to fail if we are in try settle mode
    if (spot_market.deposit_balance != deposits_balance_before
        || spot_market.borrow_balance != borrows_balance_before)
        && mode == SettlePnlMode::TrySettle
    {
        msg!("Spot market balance has changed, switch to MUST_SETTLE mode");
        mode = SettlePnlMode::MustSettle;
    }

    if user_unsettled_pnl == 0 {
        let msg = format!("User has no unsettled pnl for market {}", market_index);
        return mode.result(ErrorCode::NoUnsettledPnl, market_index, &msg);
    } else if pnl_to_settle_with_user == 0 {
        let msg = format!(
            "Pnl Pool cannot currently settle with user for market {}",
            market_index
        );
        return mode.result(ErrorCode::PnlPoolCantSettleUser, market_index, &msg);
    }

    let user_must_settle_themself = pnl_to_settle_with_user >= 0
        && max_pnl_pool_excess <= 0
        && !(pnl_to_settle_with_user > 0 && base_asset_amount == 0 && user.is_being_liquidated())
        && !(user.authority.eq(authority) || user.delegate.eq(authority));

    if user_must_settle_themself {
        let msg = format!(
            "Market = {} user must settle their own unsettled pnl when its positive and pnl pool not in excess",
            market_index
        );
        return mode.result(
            ErrorCode::UserMustSettleTheirOwnPositiveUnsettledPNL,
            market_index,
            &msg,
        );
    }

    update_spot_balances(
        pnl_to_settle_with_user.unsigned_abs(),
        if pnl_to_settle_with_user > 0 {
            &SpotBalanceType::Deposit
        } else {
            &SpotBalanceType::Borrow
        },
        spot_market,
        user.get_quote_spot_position_mut(),
        false,
    )?;

    update_quote_asset_amount(
        &mut user.perp_positions[position_index],
        perp_market,
        -pnl_to_settle_with_user.cast()?,
    )?;

    update_settled_pnl(user, position_index, pnl_to_settle_with_user.cast()?)?;

    let quote_asset_amount_after = user.perp_positions[position_index].quote_asset_amount;
    let quote_entry_amount = user.perp_positions[position_index].quote_entry_amount;

    crate::validation::perp_market::validate_perp_market(perp_market)?;
    crate::validation::position::validate_perp_position_with_perp_market(
        &user.perp_positions[position_index],
        perp_market,
    )?;

    emit!(SettlePnlRecord {
        ts: now,
        user: *user_key,
        market_index,
        pnl: pnl_to_settle_with_user,
        base_asset_amount,
        quote_asset_amount_after,
        quote_entry_amount,
        settle_price: oracle_price,
        explanation: SettlePnlExplanation::None,
    });

    let tvl_after = spot_market.get_tvl()?;

    validate!(
        tvl_before.safe_sub(tvl_after)? <= 10,
        ErrorCode::DefaultError,
        "Settle Pnl TVL mismatch: before={}, after={}",
        tvl_before,
        tvl_after
    )?;

    Ok(())
}

pub fn settle_expired_position(
    perp_market_index: u16,
    user: &mut User,
    user_key: &Pubkey,
    perp_market_map: &PerpMarketMap,
    spot_market_map: &SpotMarketMap,
    oracle_map: &mut OracleMap,
    clock: &Clock,
    state: &State,
) -> DriftResult {
    validate!(!user.is_bankrupt(), ErrorCode::UserBankrupt)?;

    let position_index = match get_position_index(&user.perp_positions, perp_market_index) {
        Ok(index) => index,
        Err(_) => {
            msg!("User has no position for market {}", perp_market_index);
            return Ok(());
        }
    };

    let can_skip_margin_calc = user.perp_positions[position_index].base_asset_amount == 0
        && user.perp_positions[position_index].quote_asset_amount > 0;

    // cannot settle pnl this way on a user who is in liquidation territory
    if !meets_maintenance_margin_requirement(user, perp_market_map, spot_market_map, oracle_map)?
        && !can_skip_margin_calc
    {
        return Err(ErrorCode::InsufficientCollateralForSettlingPNL);
    }

    let fee_structure = &state.perp_fee_structure;
    let now = clock.unix_timestamp;
    let slot = clock.slot;

    {
        let quote_spot_market = &mut spot_market_map.get_quote_spot_market_mut()?;
        update_spot_market_cumulative_interest(quote_spot_market, None, now)?;
    }

    settle_funding_payment(
        user,
        user_key,
        perp_market_map.get_ref_mut(&perp_market_index)?.deref_mut(),
        now,
    )?;

    cancel_orders(
        user,
        user_key,
        None,
        perp_market_map,
        spot_market_map,
        oracle_map,
        now,
        slot,
        OrderActionExplanation::MarketExpired,
        Some(MarketType::Perp),
        Some(perp_market_index),
        None,
    )?;

    let quote_spot_market = &mut spot_market_map.get_quote_spot_market_mut()?;
    let perp_market = &mut perp_market_map.get_ref_mut(&perp_market_index)?;
    validate!(
        perp_market.status == MarketStatus::Settlement,
        ErrorCode::PerpMarketNotInSettlement,
        "Perp Market isn't in settlement, expiry_ts={}",
        perp_market.expiry_ts
    )?;

    let position_settlement_ts = perp_market
        .expiry_ts
        .safe_add(state.settlement_duration.cast()?)?;

    validate!(
        now > position_settlement_ts,
        ErrorCode::PerpMarketSettlementBufferNotReached,
        "Market requires {} seconds buffer to settle after expiry_ts",
        state.settlement_duration
    )?;

    validate!(
        user.perp_positions[position_index].open_orders == 0,
        ErrorCode::PerpMarketSettlementUserHasOpenOrders,
        "User must first cancel open orders for expired market"
    )?;

    let base_asset_value = calculate_base_asset_value_with_expiry_price(
        &user.perp_positions[position_index],
        perp_market.expiry_price,
    )?;

    let base_asset_amount = user.perp_positions[position_index].base_asset_amount;
    let quote_entry_amount = user.perp_positions[position_index].quote_entry_amount;

    let position_delta = PositionDelta {
        quote_asset_amount: base_asset_value,
        base_asset_amount: -user.perp_positions[position_index].base_asset_amount,
    };

    update_position_and_market(
        &mut user.perp_positions[position_index],
        perp_market,
        &position_delta,
    )?;

    let fee = base_asset_value
        .safe_mul(fee_structure.fee_tiers[0].fee_numerator as i64)?
        .safe_div(fee_structure.fee_tiers[0].fee_denominator as i64)?;

    update_quote_asset_and_break_even_amount(
        &mut user.perp_positions[position_index],
        perp_market,
        -fee.abs(),
    )?;

    let pnl = user.perp_positions[position_index].quote_asset_amount;

    let pnl_to_settle_with_user =
        update_pnl_pool_and_user_balance(perp_market, quote_spot_market, user, pnl.cast()?)?;

    update_quote_asset_amount(
        &mut user.perp_positions[position_index],
        perp_market,
        -pnl_to_settle_with_user.cast()?,
    )?;

    update_settled_pnl(user, position_index, pnl_to_settle_with_user.cast()?)?;

    perp_market.amm.base_asset_amount_with_amm = perp_market
        .amm
        .base_asset_amount_with_amm
        .safe_add(position_delta.base_asset_amount.cast()?)?;

    let quote_asset_amount_after = user.perp_positions[position_index].quote_asset_amount;

    emit!(SettlePnlRecord {
        ts: now,
        user: *user_key,
        market_index: perp_market_index,
        pnl: pnl_to_settle_with_user,
        base_asset_amount,
        quote_asset_amount_after,
        quote_entry_amount,
        settle_price: perp_market.expiry_price,
        explanation: SettlePnlExplanation::ExpiredPosition,
    });

    validate!(
        user.perp_positions[position_index].is_available(),
        ErrorCode::UnableToSettleExpiredUserPosition,
        "Issue occurred in expired settlement"
    )?;

    Ok(())
}



================================================
FILE: programs/drift/src/controller/position.rs
================================================
use crate::msg;
use anchor_lang::prelude::*;
use borsh::{BorshDeserialize, BorshSerialize};

use crate::controller;
use crate::controller::amm::SwapDirection;
use crate::error::{DriftResult, ErrorCode};
use crate::math::casting::Cast;
use crate::math::constants::{MAX_BASE_ASSET_AMOUNT_WITH_AMM, PERP_DECIMALS};
use crate::math::orders::{
    calculate_quote_asset_amount_for_maker_order, get_position_delta_for_fill,
    is_multiple_of_step_size,
};
use crate::math::position::{
    get_new_position_amounts, get_position_update_type, PositionUpdateType,
};
use crate::math::safe_math::SafeMath;
use crate::math_error;
use crate::safe_increment;
use crate::state::perp_market::PerpMarket;
use crate::state::user::{PerpPosition, PerpPositions, User};
use crate::validate;

#[cfg(test)]
mod tests;

#[derive(Clone, Copy, BorshSerialize, BorshDeserialize, PartialEq, Debug, Eq, Default)]
pub enum PositionDirection {
    #[default]
    Long,
    Short,
}

impl PositionDirection {
    pub fn opposite(&self) -> Self {
        match self {
            PositionDirection::Long => PositionDirection::Short,
            PositionDirection::Short => PositionDirection::Long,
        }
    }
}

pub fn add_new_position(
    user_positions: &mut PerpPositions,
    market_index: u16,
) -> DriftResult<usize> {
    let new_position_index = user_positions
        .iter()
        .position(|market_position| market_position.is_available())
        .ok_or(ErrorCode::MaxNumberOfPositions)?;

    let max_margin_ratio = {
        let old_position = &user_positions[new_position_index];

        if old_position.market_index == market_index {
            old_position.max_margin_ratio
        } else {
            0_u16
        }
    };

    let new_market_position = PerpPosition {
        market_index,
        max_margin_ratio,
        ..PerpPosition::default()
    };

    user_positions[new_position_index] = new_market_position;

    Ok(new_position_index)
}

pub fn get_position_index(user_positions: &PerpPositions, market_index: u16) -> DriftResult<usize> {
    let position_index = user_positions
        .iter()
        .position(|market_position| market_position.is_for(market_index));

    match position_index {
        Some(position_index) => Ok(position_index),
        None => Err(ErrorCode::UserHasNoPositionInMarket),
    }
}

#[derive(Default, PartialEq, Debug)]
pub struct PositionDelta {
    pub quote_asset_amount: i64,
    pub base_asset_amount: i64,
}

impl PositionDelta {
    pub fn get_delta_base_abs(&self) -> DriftResult<i128> {
        self.base_asset_amount.abs().cast::<i128>()
    }
}

pub fn update_position_and_market(
    position: &mut PerpPosition,
    market: &mut PerpMarket,
    delta: &PositionDelta,
) -> DriftResult<i64> {
    if delta.base_asset_amount == 0 {
        update_quote_asset_amount(position, market, delta.quote_asset_amount)?;
        return Ok(delta.quote_asset_amount);
    }

    let update_type = get_position_update_type(position, delta)?;

    // Update User
    let (new_base_asset_amount, new_quote_asset_amount) =
        get_new_position_amounts(position, delta)?;

    let (new_quote_entry_amount, new_quote_break_even_amount, pnl) = match update_type {
        PositionUpdateType::Open | PositionUpdateType::Increase => {
            let new_quote_entry_amount = position
                .quote_entry_amount
                .safe_add(delta.quote_asset_amount)?;

            let new_quote_break_even_amount = position
                .quote_break_even_amount
                .safe_add(delta.quote_asset_amount)?;

            (new_quote_entry_amount, new_quote_break_even_amount, 0_i64)
        }
        PositionUpdateType::Reduce | PositionUpdateType::Close => {
            let current_base_i128 = position.get_base_asset_amount_abs()?;
            let delta_base_i128 = delta.get_delta_base_abs()?;

            let new_quote_entry_amount = position.quote_entry_amount.safe_sub(
                position
                    .quote_entry_amount
                    .cast::<i128>()?
                    .safe_mul(delta_base_i128)?
                    .safe_div(current_base_i128)?
                    .cast()?,
            )?;

            let new_quote_break_even_amount = position.quote_break_even_amount.safe_sub(
                position
                    .quote_break_even_amount
                    .cast::<i128>()?
                    .safe_mul(delta_base_i128)?
                    .safe_div(current_base_i128)?
                    .cast()?,
            )?;

            let pnl = position
                .quote_entry_amount
                .safe_sub(new_quote_entry_amount)?
                .safe_add(delta.quote_asset_amount)?;

            (new_quote_entry_amount, new_quote_break_even_amount, pnl)
        }
        PositionUpdateType::Flip => {
            let current_base_i128 = position.get_base_asset_amount_abs()?;
            let delta_base_i128 = delta.get_delta_base_abs()?;

            // same calculation for new_quote_entry_amount
            let new_quote_break_even_amount = delta.quote_asset_amount.safe_sub(
                delta
                    .quote_asset_amount
                    .cast::<i128>()?
                    .safe_mul(current_base_i128)?
                    .safe_div(delta_base_i128)?
                    .cast()?,
            )?;

            let pnl = position.quote_entry_amount.safe_add(
                delta
                    .quote_asset_amount
                    .safe_sub(new_quote_break_even_amount)?,
            )?;

            (
                new_quote_break_even_amount,
                new_quote_break_even_amount,
                pnl,
            )
        }
    };

    // Update Market open interest
    if let PositionUpdateType::Open = update_type {
        if position.quote_asset_amount == 0 && position.base_asset_amount == 0 {
            market.number_of_users = market.number_of_users.safe_add(1)?;
        }

        market.number_of_users_with_base = market.number_of_users_with_base.safe_add(1)?;
    } else if let PositionUpdateType::Close = update_type {
        if new_base_asset_amount == 0 && new_quote_asset_amount == 0 {
            market.number_of_users = market.number_of_users.saturating_sub(1);
        }

        market.number_of_users_with_base = market.number_of_users_with_base.saturating_sub(1);
    }

    market.amm.quote_asset_amount = market
        .amm
        .quote_asset_amount
        .safe_add(delta.quote_asset_amount.cast()?)?;

    match update_type {
        PositionUpdateType::Open | PositionUpdateType::Increase => {
            if new_base_asset_amount > 0 {
                market.amm.base_asset_amount_long = market
                    .amm
                    .base_asset_amount_long
                    .safe_add(delta.base_asset_amount.cast()?)?;
                market.amm.quote_entry_amount_long = market
                    .amm
                    .quote_entry_amount_long
                    .safe_add(delta.quote_asset_amount.cast()?)?;
                market.amm.quote_break_even_amount_long =
                    market
                        .amm
                        .quote_break_even_amount_long
                        .safe_add(delta.quote_asset_amount.cast()?)?;
            } else {
                market.amm.base_asset_amount_short = market
                    .amm
                    .base_asset_amount_short
                    .safe_add(delta.base_asset_amount.cast()?)?;
                market.amm.quote_entry_amount_short = market
                    .amm
                    .quote_entry_amount_short
                    .safe_add(delta.quote_asset_amount.cast()?)?;
                market.amm.quote_break_even_amount_short = market
                    .amm
                    .quote_break_even_amount_short
                    .safe_add(delta.quote_asset_amount.cast()?)?;
            }
        }
        PositionUpdateType::Reduce | PositionUpdateType::Close => {
            if position.base_asset_amount > 0 {
                market.amm.base_asset_amount_long = market
                    .amm
                    .base_asset_amount_long
                    .safe_add(delta.base_asset_amount.cast()?)?;
                market.amm.quote_entry_amount_long = market.amm.quote_entry_amount_long.safe_sub(
                    position
                        .quote_entry_amount
                        .safe_sub(new_quote_entry_amount)?
                        .cast()?,
                )?;
                market.amm.quote_break_even_amount_long =
                    market.amm.quote_break_even_amount_long.safe_sub(
                        position
                            .quote_break_even_amount
                            .safe_sub(new_quote_break_even_amount)?
                            .cast()?,
                    )?;
            } else {
                market.amm.base_asset_amount_short = market
                    .amm
                    .base_asset_amount_short
                    .safe_add(delta.base_asset_amount.cast()?)?;
                market.amm.quote_entry_amount_short =
                    market.amm.quote_entry_amount_short.safe_sub(
                        position
                            .quote_entry_amount
                            .safe_sub(new_quote_entry_amount)?
                            .cast()?,
                    )?;
                market.amm.quote_break_even_amount_short =
                    market.amm.quote_break_even_amount_short.safe_sub(
                        position
                            .quote_break_even_amount
                            .safe_sub(new_quote_break_even_amount)?
                            .cast()?,
                    )?;
            }
        }
        PositionUpdateType::Flip => {
            if new_base_asset_amount > 0 {
                market.amm.base_asset_amount_short = market
                    .amm
                    .base_asset_amount_short
                    .safe_sub(position.base_asset_amount.cast()?)?;
                market.amm.base_asset_amount_long = market
                    .amm
                    .base_asset_amount_long
                    .safe_add(new_base_asset_amount.cast()?)?;

                market.amm.quote_entry_amount_short = market
                    .amm
                    .quote_entry_amount_short
                    .safe_sub(position.quote_entry_amount.cast()?)?;
                market.amm.quote_entry_amount_long = market
                    .amm
                    .quote_entry_amount_long
                    .safe_add(new_quote_entry_amount.cast()?)?;

                market.amm.quote_break_even_amount_short = market
                    .amm
                    .quote_break_even_amount_short
                    .safe_sub(position.quote_break_even_amount.cast()?)?;
                market.amm.quote_break_even_amount_long =
                    market
                        .amm
                        .quote_break_even_amount_long
                        .safe_add(new_quote_break_even_amount.cast()?)?;
            } else {
                market.amm.base_asset_amount_long = market
                    .amm
                    .base_asset_amount_long
                    .safe_sub(position.base_asset_amount.cast()?)?;
                market.amm.base_asset_amount_short = market
                    .amm
                    .base_asset_amount_short
                    .safe_add(new_base_asset_amount.cast()?)?;

                market.amm.quote_entry_amount_long = market
                    .amm
                    .quote_entry_amount_long
                    .safe_sub(position.quote_entry_amount.cast()?)?;
                market.amm.quote_entry_amount_short = market
                    .amm
                    .quote_entry_amount_short
                    .safe_add(new_quote_entry_amount.cast()?)?;

                market.amm.quote_break_even_amount_long =
                    market
                        .amm
                        .quote_break_even_amount_long
                        .safe_sub(position.quote_break_even_amount.cast()?)?;
                market.amm.quote_break_even_amount_short = market
                    .amm
                    .quote_break_even_amount_short
                    .safe_add(new_quote_break_even_amount.cast()?)?;
            }
        }
    }

    // Validate that user funding rate is up to date before modifying
    match position.get_direction() {
        PositionDirection::Long if position.base_asset_amount != 0 => {
            validate!(
                position.last_cumulative_funding_rate.cast::<i128>()? == market.amm.cumulative_funding_rate_long,
                ErrorCode::InvalidPositionLastFundingRate,
                "position.last_cumulative_funding_rate {} market.amm.cumulative_funding_rate_long {}",
                position.last_cumulative_funding_rate.cast::<i128>()?,
                market.amm.cumulative_funding_rate_long,
            )?;
        }
        PositionDirection::Short => {
            validate!(
                position.last_cumulative_funding_rate == market.amm.cumulative_funding_rate_short.cast::<i64>()?,
                ErrorCode::InvalidPositionLastFundingRate,
                "position.last_cumulative_funding_rate {} market.amm.cumulative_funding_rate_short {}",
                position.last_cumulative_funding_rate,
                market.amm.cumulative_funding_rate_short,
            )?;
        }
        _ => {}
    }

    // Update user position
    if let PositionUpdateType::Close = update_type {
        position.last_cumulative_funding_rate = 0;
    } else if matches!(
        update_type,
        PositionUpdateType::Open | PositionUpdateType::Increase | PositionUpdateType::Flip
    ) {
        if new_base_asset_amount > 0 {
            position.last_cumulative_funding_rate =
                market.amm.cumulative_funding_rate_long.cast()?;
        } else {
            position.last_cumulative_funding_rate =
                market.amm.cumulative_funding_rate_short.cast()?;
        }
    }

    validate!(
        is_multiple_of_step_size(
            position.base_asset_amount.unsigned_abs(),
            market.amm.order_step_size
        )?,
        ErrorCode::InvalidPerpPositionDetected,
        "update_position_and_market left invalid position before {} after {}",
        position.base_asset_amount,
        new_base_asset_amount
    )?;

    position.base_asset_amount = new_base_asset_amount;

    position.quote_asset_amount = new_quote_asset_amount;
    position.quote_entry_amount = new_quote_entry_amount;
    position.quote_break_even_amount = new_quote_break_even_amount;

    Ok(pnl)
}

pub fn update_position_with_base_asset_amount(
    base_asset_amount: u64,
    direction: PositionDirection,
    market: &mut PerpMarket,
    user: &mut User,
    position_index: usize,
    fill_price: Option<u64>,
) -> DriftResult<(u64, i64, i64)> {
    let swap_direction = match direction {
        PositionDirection::Long => SwapDirection::Remove,
        PositionDirection::Short => SwapDirection::Add,
    };

    let (quote_asset_swapped, quote_asset_amount_surplus) =
        controller::amm::swap_base_asset(market, base_asset_amount, swap_direction)?;

    let (quote_asset_amount, quote_asset_amount_surplus) = match fill_price {
        Some(fill_price) => calculate_quote_asset_amount_surplus(
            direction,
            quote_asset_swapped,
            base_asset_amount,
            fill_price,
        )?,
        None => (quote_asset_swapped, quote_asset_amount_surplus),
    };

    let position_delta =
        get_position_delta_for_fill(base_asset_amount, quote_asset_amount, direction)?;

    let pnl = update_position_and_market(
        &mut user.perp_positions[position_index],
        market,
        &position_delta,
    )?;

    market.amm.base_asset_amount_with_amm = market
        .amm
        .base_asset_amount_with_amm
        .safe_add(position_delta.base_asset_amount.cast()?)?;

    validate!(
        market.amm.base_asset_amount_with_amm.unsigned_abs() <= MAX_BASE_ASSET_AMOUNT_WITH_AMM,
        ErrorCode::InvalidAmmDetected,
        "market.amm.base_asset_amount_with_amm={} cannot exceed MAX_BASE_ASSET_AMOUNT_WITH_AMM",
        market.amm.base_asset_amount_with_amm
    )?;

    controller::amm::update_spread_reserves(market)?;

    Ok((quote_asset_amount, quote_asset_amount_surplus, pnl))
}

fn calculate_quote_asset_amount_surplus(
    position_direction: PositionDirection,
    quote_asset_swapped: u64,
    base_asset_amount: u64,
    fill_price: u64,
) -> DriftResult<(u64, i64)> {
    let quote_asset_amount = calculate_quote_asset_amount_for_maker_order(
        base_asset_amount,
        fill_price,
        PERP_DECIMALS,
        position_direction,
    )?;

    let quote_asset_amount_surplus = match position_direction {
        PositionDirection::Long => quote_asset_amount
            .cast::<i64>()?
            .safe_sub(quote_asset_swapped.cast()?)?,
        PositionDirection::Short => quote_asset_swapped
            .cast::<i64>()?
            .safe_sub(quote_asset_amount.cast()?)?,
    };

    Ok((quote_asset_amount, quote_asset_amount_surplus))
}

pub fn update_quote_asset_and_break_even_amount(
    position: &mut PerpPosition,
    market: &mut PerpMarket,
    delta: i64,
) -> DriftResult {
    update_quote_asset_amount(position, market, delta)?;
    update_quote_break_even_amount(position, market, delta)
}

pub fn update_quote_asset_amount(
    position: &mut PerpPosition,
    market: &mut PerpMarket,
    delta: i64,
) -> DriftResult<()> {
    if delta == 0 {
        return Ok(());
    }

    if position.quote_asset_amount == 0 && position.base_asset_amount == 0 {
        market.number_of_users = market.number_of_users.safe_add(1)?;
    }

    position.quote_asset_amount = position.quote_asset_amount.safe_add(delta)?;

    market.amm.quote_asset_amount = market.amm.quote_asset_amount.safe_add(delta.cast()?)?;

    if position.quote_asset_amount == 0 && position.base_asset_amount == 0 {
        market.number_of_users = market.number_of_users.saturating_sub(1);
    }

    Ok(())
}

pub fn update_quote_break_even_amount(
    position: &mut PerpPosition,
    market: &mut PerpMarket,
    delta: i64,
) -> DriftResult<()> {
    if delta == 0 || position.base_asset_amount == 0 {
        return Ok(());
    }

    position.quote_break_even_amount = position.quote_break_even_amount.safe_add(delta)?;
    match position.get_direction() {
        PositionDirection::Long => {
            market.amm.quote_break_even_amount_long = market
                .amm
                .quote_break_even_amount_long
                .safe_add(delta.cast()?)?
        }
        PositionDirection::Short => {
            market.amm.quote_break_even_amount_short = market
                .amm
                .quote_break_even_amount_short
                .safe_add(delta.cast()?)?
        }
    }

    Ok(())
}

pub fn update_settled_pnl(user: &mut User, position_index: usize, delta: i64) -> DriftResult<()> {
    update_user_settled_pnl(user, delta)?;
    update_position_settled_pnl(&mut user.perp_positions[position_index], delta)?;
    Ok(())
}

pub fn update_position_settled_pnl(position: &mut PerpPosition, delta: i64) -> DriftResult<()> {
    position.settled_pnl = position.settled_pnl.safe_add(delta)?;

    Ok(())
}

pub fn update_user_settled_pnl(user: &mut User, delta: i64) -> DriftResult<()> {
    safe_increment!(user.settled_perp_pnl, delta);
    Ok(())
}

pub fn increase_open_bids_and_asks(
    position: &mut PerpPosition,
    direction: &PositionDirection,
    base_asset_amount_unfilled: u64,
    update: bool,
) -> DriftResult {
    if !update {
        return Ok(());
    }

    match direction {
        PositionDirection::Long => {
            position.open_bids = position
                .open_bids
                .safe_add(base_asset_amount_unfilled.cast()?)?;
        }
        PositionDirection::Short => {
            position.open_asks = position
                .open_asks
                .safe_sub(base_asset_amount_unfilled.cast()?)?;
        }
    }

    Ok(())
}

pub fn decrease_open_bids_and_asks(
    position: &mut PerpPosition,
    direction: &PositionDirection,
    base_asset_amount_unfilled: u64,
    update: bool,
) -> DriftResult {
    if !update {
        return Ok(());
    }

    match direction {
        PositionDirection::Long => {
            position.open_bids = position
                .open_bids
                .safe_sub(base_asset_amount_unfilled.cast()?)?
                .max(0);
        }
        PositionDirection::Short => {
            position.open_asks = position
                .open_asks
                .safe_add(base_asset_amount_unfilled.cast()?)?
                .min(0);
        }
    }

    Ok(())
}



================================================
FILE: programs/drift/src/controller/repeg.rs
================================================
use std::cmp::min;

use crate::math::oracle::LogMode;
use crate::msg;
use crate::state::oracle::MMOraclePriceData;
use anchor_lang::prelude::AccountInfo;
use anchor_lang::prelude::*;

use crate::controller::amm::update_spreads;
use crate::controller::spot_balance::update_spot_balances;
use crate::error::ErrorCode;
use crate::error::*;
use crate::load_mut;
use crate::math::amm;
use crate::math::bn;
use crate::math::casting::Cast;
use crate::math::constants::{
    K_BPS_UPDATE_SCALE, MAX_SQRT_K, QUOTE_PRECISION, QUOTE_SPOT_MARKET_INDEX,
};
use crate::math::cp_curve;
use crate::math::cp_curve::get_update_k_result;
use crate::math::cp_curve::UpdateKResult;
use crate::math::oracle;
use crate::math::oracle::{is_oracle_valid_for_action, oracle_validity, DriftAction};
use crate::math::repeg;
use crate::math::safe_math::SafeMath;
use crate::math::spot_balance::get_token_amount;

use crate::state::oracle::OracleSource;
use crate::state::oracle_map::OracleMap;
use crate::state::perp_market::{MarketStatus, PerpMarket};
use crate::state::perp_market_map::PerpMarketMap;
use crate::state::spot_market::SpotBalance;
use crate::state::spot_market::SpotBalanceType;
use crate::state::spot_market_map::SpotMarketMap;
use crate::state::state::{OracleGuardRails, State};
use crate::state::user::MarketType;
use crate::validate;

#[cfg(test)]
mod tests;

pub fn repeg(
    market: &mut PerpMarket,
    price_oracle: &AccountInfo,
    new_peg_candidate: u128,
    clock_slot: u64,
    oracle_guard_rails: &OracleGuardRails,
) -> DriftResult<i128> {
    // for adhoc admin only repeg

    if new_peg_candidate == market.amm.peg_multiplier {
        return Err(ErrorCode::InvalidRepegRedundant);
    }
    let (terminal_price_before, _terminal_quote_reserves, _terminal_base_reserves) =
        amm::calculate_terminal_price_and_reserves(&market.amm)?;

    let (repegged_market, adjustment_cost) = repeg::adjust_peg_cost(market, new_peg_candidate)?;

    let (oracle_is_valid, direction_valid, profitability_valid, price_impact_valid) =
        repeg::calculate_repeg_validity_from_oracle_account(
            &repegged_market,
            price_oracle,
            terminal_price_before,
            clock_slot,
            oracle_guard_rails,
        )?;

    // cannot repeg if oracle is invalid
    if !oracle_is_valid {
        return Err(ErrorCode::InvalidOracle);
    }

    // only push terminal in direction of oracle
    if !direction_valid {
        return Err(ErrorCode::InvalidRepegDirection);
    }

    // only push terminal up to closer edge of oracle confidence band
    if !profitability_valid {
        return Err(ErrorCode::InvalidRepegProfitability);
    }

    // only push mark up to further edge of oracle confidence band
    if !price_impact_valid {
        // todo
        // return Err(ErrorCode::InvalidRepegPriceImpact);
        return Err(ErrorCode::InvalidRepegProfitability);
    }

    // modify market's total fee change and peg change
    let cost_applied = apply_cost_to_market(market, adjustment_cost, true)?;
    if cost_applied {
        market.amm.peg_multiplier = new_peg_candidate;
    } else {
        return Err(ErrorCode::InvalidRepegProfitability);
    }

    Ok(adjustment_cost)
}

pub fn update_amms(
    perp_market_map: &mut PerpMarketMap,
    oracle_map: &mut OracleMap,
    state: &State,
    clock: &Clock,
) -> DriftResult<bool> {
    // up to ~60k compute units (per amm) worst case
    let clock_slot = clock.slot;
    let now = clock.unix_timestamp;

    let updated = true; // todo
    for (_key, market_account_loader) in perp_market_map.0.iter_mut() {
        let market = &mut load_mut!(market_account_loader)?;
        let oracle_price_data = oracle_map.get_price_data(&market.oracle_id())?;
        let mm_oracle_price_data = market.get_mm_oracle_price_data(
            *oracle_price_data,
            clock_slot,
            &state.oracle_guard_rails.validity,
        )?;

        _update_amm(market, &mm_oracle_price_data, state, now, clock_slot)?;
    }

    Ok(updated)
}

pub fn update_amm(
    market_index: u16,
    perp_market_map: &PerpMarketMap,
    oracle_map: &mut OracleMap,
    state: &State,
    clock: &Clock,
) -> DriftResult<i128> {
    let market = &mut perp_market_map.get_ref_mut(&market_index)?;
    let oracle_price_data = oracle_map.get_price_data(&market.oracle_id())?;
    let mm_oracle_price_data = market.get_mm_oracle_price_data(
        *oracle_price_data,
        clock.slot,
        &state.oracle_guard_rails.validity,
    )?;

    let cost_of_update = _update_amm(
        market,
        &mm_oracle_price_data,
        state,
        clock.unix_timestamp,
        clock.slot,
    )?;

    Ok(cost_of_update)
}

pub fn _update_amm(
    market: &mut PerpMarket,
    mm_oracle_price_data: &MMOraclePriceData,
    state: &State,
    now: i64,
    clock_slot: u64,
) -> DriftResult<i128> {
    if matches!(
        market.status,
        MarketStatus::Settlement | MarketStatus::Delisted
    ) {
        return Ok(0);
    }

    let oracle_data = &mm_oracle_price_data.get_safe_oracle_price_data();
    let oracle_validity = oracle::oracle_validity(
        MarketType::Perp,
        market.market_index,
        market.amm.historical_oracle_data.last_oracle_price_twap,
        oracle_data,
        &state.oracle_guard_rails.validity,
        market.get_max_confidence_interval_multiplier()?,
        &market.amm.oracle_source,
        oracle::LogMode::SafeMMOracle,
        market.amm.oracle_slot_delay_override,
        market.amm.oracle_low_risk_slot_delay_override,
    )?;

    let mut amm_update_cost = 0;
    let mut amm_not_successfully_updated = false;
    if is_oracle_valid_for_action(oracle_validity, Some(DriftAction::UpdateAMMCurve))? {
        let curve_update_intensity =
            min(market.amm.curve_update_intensity, 100_u8).cast::<i128>()?;

        if curve_update_intensity > 0 {
            let (optimal_peg, fee_budget, check_lower_bound) =
                repeg::calculate_optimal_peg_and_budget(market, mm_oracle_price_data)?;

            let (repegged_market, repegged_cost) = repeg::adjust_amm(
                market,
                optimal_peg,
                fee_budget,
                curve_update_intensity >= 100,
            )?;

            let cost_applied = apply_cost_to_market(market, repegged_cost, check_lower_bound)?;
            if cost_applied {
                cp_curve::update_k(
                    market,
                    &UpdateKResult {
                        sqrt_k: repegged_market.amm.sqrt_k,
                        base_asset_reserve: repegged_market.amm.base_asset_reserve,
                        quote_asset_reserve: repegged_market.amm.quote_asset_reserve,
                    },
                )?;
                market.amm.peg_multiplier = repegged_market.amm.peg_multiplier;
                amm_update_cost = repegged_cost;
            } else {
                msg!("amm_not_successfully_updated = true (repeg cost not applied for check_lower_bound={})", check_lower_bound);
                amm_not_successfully_updated = true;
            }
        }
    }

    let reserve_price_after = market.amm.reserve_price()?;

    if is_oracle_valid_for_action(oracle_validity, Some(DriftAction::UpdateTwap))? {
        let sanitize_clamp_denominator = market.get_sanitize_clamp_denominator()?;

        amm::update_oracle_price_twap(
            &mut market.amm,
            now,
            mm_oracle_price_data,
            Some(reserve_price_after),
            sanitize_clamp_denominator,
        )?;
    }

    update_spreads(market, reserve_price_after, Some(clock_slot))?;

    if is_oracle_valid_for_action(oracle_validity, Some(DriftAction::FillOrderAmmLowRisk))? {
        if !amm_not_successfully_updated {
            market.amm.last_update_slot = clock_slot;
        }
        market.amm.last_oracle_valid = true;
    } else {
        market.amm.last_oracle_valid = false;
    }

    Ok(amm_update_cost)
}

pub fn update_amm_and_check_validity(
    market: &mut PerpMarket,
    mm_oracle_price_data: &MMOraclePriceData,
    state: &State,
    now: i64,
    clock_slot: u64,
    action: Option<DriftAction>,
) -> DriftResult {
    _update_amm(market, mm_oracle_price_data, state, now, clock_slot)?;

    // 1 hour EMA
    let risk_ema_price = market.amm.historical_oracle_data.last_oracle_price_twap;

    let oracle_validity = oracle_validity(
        MarketType::Perp,
        market.market_index,
        risk_ema_price,
        &mm_oracle_price_data.get_safe_oracle_price_data(),
        &state.oracle_guard_rails.validity,
        market.get_max_confidence_interval_multiplier()?,
        &market.amm.oracle_source,
        LogMode::SafeMMOracle,
        market.amm.oracle_slot_delay_override,
        market.amm.oracle_low_risk_slot_delay_override,
    )?;

    validate!(
        is_oracle_valid_for_action(oracle_validity, action)?,
        ErrorCode::InvalidOracle,
        "Invalid Oracle ({:?} vs ema={:?}) for perp market index={} and action={:?}",
        mm_oracle_price_data.get_safe_oracle_price_data(),
        risk_ema_price,
        market.market_index,
        action
    )?;

    Ok(())
}

pub fn apply_cost_to_market(
    market: &mut PerpMarket,
    cost: i128,
    check_lower_bound: bool,
) -> DriftResult<bool> {
    // positive cost is expense, negative cost is revenue
    // Reduce pnl to quote asset precision and take the absolute value
    if cost > 0 {
        let new_total_fee_minus_distributions =
            market.amm.total_fee_minus_distributions.safe_sub(cost)?;

        let fee_reserved_for_protocol = repeg::get_total_fee_lower_bound(market)?
            .safe_add(market.amm.total_liquidation_fee)?
            .safe_sub(market.amm.total_fee_withdrawn)?
            .cast::<i128>()?;
        // Only a portion of the protocol fees are allocated to repegging
        // This checks that the total_fee_minus_distributions does not decrease too much after repeg
        if check_lower_bound {
            if new_total_fee_minus_distributions >= fee_reserved_for_protocol {
                market.amm.total_fee_minus_distributions = new_total_fee_minus_distributions;
            } else {
                return Ok(false);
            }
        } else {
            market.amm.total_fee_minus_distributions = new_total_fee_minus_distributions;
        }
    } else {
        market.amm.total_fee_minus_distributions = market
            .amm
            .total_fee_minus_distributions
            .safe_add(cost.abs())?;
    }

    market.amm.net_revenue_since_last_funding = market
        .amm
        .net_revenue_since_last_funding
        .safe_sub(cost as i64)?;

    Ok(true)
}

pub fn settle_expired_market(
    market_index: u16,
    market_map: &PerpMarketMap,
    _oracle_map: &mut OracleMap,
    spot_market_map: &SpotMarketMap,
    _state: &State,
    clock: &Clock,
) -> DriftResult {
    let now = clock.unix_timestamp;
    let market = &mut market_map.get_ref_mut(&market_index)?;

    validate!(
        market.expiry_ts != 0,
        ErrorCode::MarketSettlementAttemptOnActiveMarket,
        "Market isn't set to expire"
    )?;

    validate!(
        market.expiry_ts <= now,
        ErrorCode::MarketSettlementAttemptTooEarly,
        "Market hasn't expired yet (expiry={} > now{})",
        market.expiry_ts,
        now
    )?;

    validate!(
        market.amm.base_asset_amount_with_unsettled_lp == 0,
        ErrorCode::MarketSettlementRequiresSettledLP,
        "Outstanding LP in market"
    )?;

    let spot_market = &mut spot_market_map.get_ref_mut(&QUOTE_SPOT_MARKET_INDEX)?;
    let fee_reserved_for_protocol = repeg::get_total_fee_lower_bound(market)?
        .safe_add(market.amm.total_liquidation_fee)?
        .safe_sub(market.amm.total_fee_withdrawn)?
        .cast::<i128>()?;
    let budget = market
        .amm
        .total_fee_minus_distributions
        .safe_sub(fee_reserved_for_protocol)?
        .max(0);

    let available_fee_pool = get_token_amount(
        market.amm.fee_pool.scaled_balance,
        spot_market,
        &SpotBalanceType::Deposit,
    )?
    .cast::<i128>()?
    .safe_sub(fee_reserved_for_protocol)?
    .max(0);

    let fee_pool_transfer = budget.min(available_fee_pool);

    update_spot_balances(
        fee_pool_transfer.unsigned_abs(),
        &SpotBalanceType::Borrow,
        spot_market,
        &mut market.amm.fee_pool,
        false,
    )?;

    update_spot_balances(
        fee_pool_transfer.unsigned_abs(),
        &SpotBalanceType::Deposit,
        spot_market,
        &mut market.pnl_pool,
        false,
    )?;

    if budget > 0 {
        let (k_scale_numerator, k_scale_denominator) = cp_curve::calculate_budgeted_k_scale(
            market,
            budget.cast()?,
            K_BPS_UPDATE_SCALE * 100,
            K_BPS_UPDATE_SCALE,
        )?;

        let new_sqrt_k = bn::U192::from(market.amm.sqrt_k)
            .safe_mul(bn::U192::from(k_scale_numerator))?
            .safe_div(bn::U192::from(k_scale_denominator))?
            .min(bn::U192::from(MAX_SQRT_K));

        let update_k_result = get_update_k_result(market, new_sqrt_k, true)?;

        let adjustment_cost = cp_curve::adjust_k_cost(market, &update_k_result)?;

        let cost_applied = apply_cost_to_market(market, adjustment_cost, true)?;

        validate!(
            cost_applied,
            ErrorCode::InvalidUpdateK,
            "Issue applying k increase on market"
        )?;

        if cost_applied {
            cp_curve::update_k(market, &update_k_result)?;
        }
    }

    validate!(
        10_u128.pow(spot_market.decimals) == QUOTE_PRECISION,
        ErrorCode::UnsupportedSpotMarket,
        "Only support bank.decimals == QUOTE_PRECISION"
    )?;

    let target_expiry_price = if market.amm.oracle_source == OracleSource::Prelaunch {
        market.amm.historical_oracle_data.last_oracle_price
    } else {
        market.amm.historical_oracle_data.last_oracle_price_twap
    };

    crate::dlog!(target_expiry_price);

    validate!(
        target_expiry_price > 0,
        ErrorCode::MarketSettlementTargetPriceInvalid,
        "target_expiry_price <= 0 {}",
        target_expiry_price
    )?;

    let pnl_pool_token_amount = get_token_amount(
        market.pnl_pool.scaled_balance,
        spot_market,
        market.pnl_pool.balance_type(),
    )?;

    let fee_pool_token_amount = get_token_amount(
        market.amm.fee_pool.scaled_balance,
        spot_market,
        market.amm.fee_pool.balance_type(),
    )?;

    let total_excess_balance: i128 = pnl_pool_token_amount
        .safe_add(fee_pool_token_amount)?
        .cast()?;

    crate::dlog!(market.market_index);
    crate::dlog!(total_excess_balance);

    let expiry_price =
        amm::calculate_expiry_price(&market.amm, target_expiry_price, total_excess_balance)?;

    market.expiry_price = expiry_price;
    market.status = MarketStatus::Settlement;

    crate::dlog!(market.expiry_price);

    Ok(())
}



================================================
FILE: programs/drift/src/controller/revenue_share.rs
================================================
use anchor_lang::prelude::*;

use crate::controller::spot_balance;
use crate::math::safe_math::SafeMath;
use crate::math::spot_balance::get_token_amount;
use crate::state::events::{emit_stack, RevenueShareSettleRecord};
use crate::state::perp_market_map::PerpMarketMap;
use crate::state::revenue_share::{RevenueShareEscrowZeroCopyMut, RevenueShareOrder};
use crate::state::revenue_share_map::RevenueShareMap;
use crate::state::spot_market::SpotBalance;
use crate::state::spot_market_map::SpotMarketMap;
use crate::state::traits::Size;
use crate::state::user::MarketType;

/// Runs through the user's RevenueShareEscrow account and sweeps any accrued fees to the corresponding
/// builders and referrer.
pub fn sweep_completed_revenue_share_for_market<'a>(
    market_index: u16,
    revenue_share_escrow: &mut RevenueShareEscrowZeroCopyMut,
    perp_market_map: &PerpMarketMap<'a>,
    spot_market_map: &SpotMarketMap<'a>,
    revenue_share_map: &RevenueShareMap<'a>,
    now_ts: i64,
    builder_codes_feature_enabled: bool,
    builder_referral_feature_enabled: bool,
) -> crate::error::DriftResult<()> {
    let perp_market = &mut perp_market_map.get_ref_mut(&market_index)?;
    let quote_spot_market = &mut spot_market_map.get_quote_spot_market_mut()?;

    spot_balance::update_spot_market_cumulative_interest(quote_spot_market, None, now_ts)?;

    let orders_len = revenue_share_escrow.orders_len();
    for i in 0..orders_len {
        let (
            is_completed,
            is_referral_order,
            order_market_type,
            order_market_index,
            fees_accrued,
            builder_idx,
        ) = {
            let ord_ro = match revenue_share_escrow.get_order(i) {
                Ok(o) => o,
                Err(_) => {
                    continue;
                }
            };
            (
                ord_ro.is_completed(),
                ord_ro.is_referral_order(),
                ord_ro.market_type,
                ord_ro.market_index,
                ord_ro.fees_accrued,
                ord_ro.builder_idx,
            )
        };

        if is_referral_order {
            if fees_accrued == 0
                || !(order_market_type == MarketType::Perp && order_market_index == market_index)
            {
                continue;
            }
        } else if !(is_completed
            && order_market_type == MarketType::Perp
            && order_market_index == market_index
            && fees_accrued > 0)
        {
            continue;
        }

        let pnl_pool_token_amount = get_token_amount(
            perp_market.pnl_pool.scaled_balance,
            quote_spot_market,
            perp_market.pnl_pool.balance_type(),
        )?;

        // TODO: should we add buffer on pnl pool?
        if pnl_pool_token_amount < fees_accrued as u128 {
            msg!(
                "market {} PNL pool has insufficient balance to sweep fees for builder. pnl_pool_token_amount: {}, fees_accrued: {}",
                market_index,
                pnl_pool_token_amount,
                fees_accrued
            );
            break;
        }

        if is_referral_order {
            if builder_referral_feature_enabled {
                let referrer_authority =
                    if let Some(referrer_authority) = revenue_share_escrow.get_referrer() {
                        referrer_authority
                    } else {
                        continue;
                    };

                let referrer_user = revenue_share_map.get_user_ref_mut(&referrer_authority);
                let referrer_rev_share =
                    revenue_share_map.get_revenue_share_account_mut(&referrer_authority);

                if referrer_user.is_ok() && referrer_rev_share.is_ok() {
                    let mut referrer_user = referrer_user.unwrap();
                    let mut referrer_rev_share = referrer_rev_share.unwrap();

                    spot_balance::transfer_spot_balances(
                        fees_accrued as i128,
                        quote_spot_market,
                        &mut perp_market.pnl_pool,
                        referrer_user.get_quote_spot_position_mut(),
                    )?;

                    referrer_rev_share.total_referrer_rewards = referrer_rev_share
                        .total_referrer_rewards
                        .safe_add(fees_accrued as u64)?;

                    emit_stack::<_, { RevenueShareSettleRecord::SIZE }>(
                        RevenueShareSettleRecord {
                            ts: now_ts,
                            builder: None,
                            referrer: Some(referrer_authority),
                            fee_settled: fees_accrued as u64,
                            market_index: order_market_index,
                            market_type: order_market_type,
                            builder_total_referrer_rewards: referrer_rev_share
                                .total_referrer_rewards,
                            builder_total_builder_rewards: referrer_rev_share.total_builder_rewards,
                            builder_sub_account_id: referrer_user.sub_account_id,
                        },
                    )?;

                    // zero out the order
                    if let Ok(builder_order) = revenue_share_escrow.get_order_mut(i) {
                        builder_order.fees_accrued = 0;
                    }
                }
            }
        } else if builder_codes_feature_enabled {
            let builder_authority = match revenue_share_escrow
                .get_approved_builder_mut(builder_idx)
                .map(|builder| builder.authority)
            {
                Ok(auth) => auth,
                Err(_) => {
                    msg!("failed to get approved_builder from escrow account");
                    continue;
                }
            };

            let builder_user = revenue_share_map.get_user_ref_mut(&builder_authority);
            let builder_rev_share =
                revenue_share_map.get_revenue_share_account_mut(&builder_authority);

            if builder_user.is_ok() && builder_rev_share.is_ok() {
                let mut builder_user = builder_user.unwrap();
                let mut builder_revenue_share = builder_rev_share.unwrap();

                spot_balance::transfer_spot_balances(
                    fees_accrued as i128,
                    quote_spot_market,
                    &mut perp_market.pnl_pool,
                    builder_user.get_quote_spot_position_mut(),
                )?;

                builder_revenue_share.total_builder_rewards = builder_revenue_share
                    .total_builder_rewards
                    .safe_add(fees_accrued as u64)?;

                emit_stack::<_, { RevenueShareSettleRecord::SIZE }>(RevenueShareSettleRecord {
                    ts: now_ts,
                    builder: Some(builder_authority),
                    referrer: None,
                    fee_settled: fees_accrued as u64,
                    market_index: order_market_index,
                    market_type: order_market_type,
                    builder_total_referrer_rewards: builder_revenue_share.total_referrer_rewards,
                    builder_total_builder_rewards: builder_revenue_share.total_builder_rewards,
                    builder_sub_account_id: builder_user.sub_account_id,
                })?;

                // remove order
                if let Ok(builder_order) = revenue_share_escrow.get_order_mut(i) {
                    *builder_order = RevenueShareOrder::default();
                }
            } else {
                msg!(
                    "Builder user or builder not found for builder authority: {}",
                    builder_authority
                );
            }
        } else {
            msg!("Builder codes nor builder referral feature is not enabled");
        }
    }

    Ok(())
}



================================================
FILE: programs/drift/src/controller/spot_balance.rs
================================================
use crate::math::oracle::{oracle_validity, LogMode};
use crate::state::state::ValidityGuardRails;
use std::cmp::max; //, OracleValidity};

use crate::msg;
use anchor_lang::prelude::*;

use crate::error::{DriftResult, ErrorCode};
use crate::math::amm::sanitize_new_price;
use crate::math::casting::Cast;
use crate::math::constants::{
    FIVE_MINUTE, IF_FACTOR_PRECISION, ONE_HOUR, ONE_MINUTE, QUOTE_SPOT_MARKET_INDEX,
    SPOT_MARKET_TOKEN_TWAP_WINDOW,
};
use crate::math::spot_balance::{
    calculate_accumulated_interest, calculate_utilization, get_interest_token_amount,
    get_spot_balance, get_token_amount, InterestAccumulated,
};
use crate::math::stats::{calculate_new_twap, calculate_weighted_average};

use crate::math::oracle::{is_oracle_valid_for_action, DriftAction};
use crate::math::safe_math::SafeMath;
use crate::state::events::SpotInterestRecord;
use crate::state::oracle::OraclePriceData;
use crate::state::paused_operations::SpotOperation;
use crate::state::spot_market::{SpotBalance, SpotBalanceType, SpotMarket};
use crate::state::user::MarketType;
use crate::validate;

#[cfg(test)]
mod tests;

pub fn update_spot_market_twap_stats(
    spot_market: &mut SpotMarket,
    oracle_price_data: Option<&OraclePriceData>,
    now: i64,
) -> DriftResult {
    let since_last = max(0_i64, now.safe_sub(spot_market.last_twap_ts.cast()?)?);
    let from_start = max(1_i64, SPOT_MARKET_TOKEN_TWAP_WINDOW.safe_sub(since_last)?);

    let deposit_token_amount = get_token_amount(
        spot_market.deposit_balance,
        spot_market,
        &SpotBalanceType::Deposit,
    )?;

    let borrow_token_amount = get_token_amount(
        spot_market.borrow_balance,
        spot_market,
        &SpotBalanceType::Borrow,
    )?;

    spot_market.deposit_token_twap = calculate_weighted_average(
        deposit_token_amount.cast()?,
        spot_market.deposit_token_twap.cast()?,
        since_last,
        from_start,
        None,
    )?
    .cast()?;

    spot_market.borrow_token_twap = calculate_weighted_average(
        borrow_token_amount.cast()?,
        spot_market.borrow_token_twap.cast()?,
        since_last,
        from_start,
        None,
    )?
    .cast()?;

    let utilization = calculate_utilization(deposit_token_amount, borrow_token_amount)?;

    spot_market.utilization_twap = calculate_weighted_average(
        utilization.cast()?,
        spot_market.utilization_twap.cast()?,
        since_last,
        from_start,
        None,
    )?
    .cast()?;

    if let Some(oracle_price_data) = oracle_price_data {
        let sanitize_clamp_denominator = spot_market.get_sanitize_clamp_denominator()?;

        let capped_oracle_update_price: i64 = sanitize_new_price(
            oracle_price_data.price,
            spot_market.historical_oracle_data.last_oracle_price_twap,
            sanitize_clamp_denominator,
        )?;

        let oracle_price_twap = calculate_new_twap(
            capped_oracle_update_price,
            now,
            spot_market.historical_oracle_data.last_oracle_price_twap,
            spot_market.historical_oracle_data.last_oracle_price_twap_ts,
            ONE_HOUR,
        )?;

        let oracle_price_twap_5min = calculate_new_twap(
            capped_oracle_update_price,
            now,
            spot_market
                .historical_oracle_data
                .last_oracle_price_twap_5min,
            spot_market.historical_oracle_data.last_oracle_price_twap_ts,
            FIVE_MINUTE as i64,
        )?;

        spot_market.historical_oracle_data.last_oracle_price = oracle_price_data.price;
        spot_market.historical_oracle_data.last_oracle_conf = oracle_price_data.confidence;
        spot_market.historical_oracle_data.last_oracle_delay = oracle_price_data.delay;

        if oracle_price_twap != spot_market.historical_oracle_data.last_oracle_price_twap
            || since_last >= (ONE_MINUTE as i64)
        {
            spot_market.historical_oracle_data.last_oracle_price_twap = oracle_price_twap;
            spot_market
                .historical_oracle_data
                .last_oracle_price_twap_5min = oracle_price_twap_5min;
            spot_market.historical_oracle_data.last_oracle_price_twap_ts = now;
        }
    }

    spot_market.last_twap_ts = now.cast()?;

    Ok(())
}

pub fn update_spot_market_cumulative_interest(
    spot_market: &mut SpotMarket,
    oracle_price_data: Option<&OraclePriceData>,
    now: i64,
) -> DriftResult {
    if spot_market.is_operation_paused(SpotOperation::UpdateCumulativeInterest) {
        update_spot_market_twap_stats(spot_market, oracle_price_data, now)?;
        return Ok(());
    }

    let InterestAccumulated {
        deposit_interest,
        borrow_interest,
    } = calculate_accumulated_interest(spot_market, now)?;

    if deposit_interest > 0 && borrow_interest > 1 {
        // borrowers -> lenders IF fee here
        let deposit_interest_for_stakers = deposit_interest
            .safe_mul(spot_market.insurance_fund.total_factor as u128)?
            .safe_div(IF_FACTOR_PRECISION)?;

        let deposit_interest_for_lenders =
            deposit_interest.safe_sub(deposit_interest_for_stakers)?;

        if deposit_interest_for_lenders > 0 {
            spot_market.cumulative_deposit_interest = spot_market
                .cumulative_deposit_interest
                .safe_add(deposit_interest_for_lenders)?;

            spot_market.cumulative_borrow_interest = spot_market
                .cumulative_borrow_interest
                .safe_add(borrow_interest)?;
            spot_market.last_interest_ts = now.cast()?;

            // add deposit_interest_for_stakers as balance for revenue_pool
            let token_amount = get_interest_token_amount(
                spot_market.deposit_balance,
                spot_market,
                deposit_interest_for_stakers,
            )?;

            update_revenue_pool_balances(token_amount, &SpotBalanceType::Deposit, spot_market)?;

            emit!(SpotInterestRecord {
                ts: now,
                market_index: spot_market.market_index,
                deposit_balance: spot_market.deposit_balance,
                cumulative_deposit_interest: spot_market.cumulative_deposit_interest,
                borrow_balance: spot_market.borrow_balance,
                cumulative_borrow_interest: spot_market.cumulative_borrow_interest,
                optimal_utilization: spot_market.optimal_utilization,
                optimal_borrow_rate: spot_market.optimal_borrow_rate,
                max_borrow_rate: spot_market.max_borrow_rate,
            });
        }
    }

    update_spot_market_twap_stats(spot_market, oracle_price_data, now)?;

    Ok(())
}

pub fn update_revenue_pool_balances(
    token_amount: u128,
    update_direction: &SpotBalanceType,
    spot_market: &mut SpotMarket,
) -> DriftResult {
    let mut spot_balance = spot_market.revenue_pool;
    update_spot_balances(
        token_amount,
        update_direction,
        spot_market,
        &mut spot_balance,
        false,
    )?;
    spot_market.revenue_pool = spot_balance;

    Ok(())
}

pub fn update_spot_balances(
    mut token_amount: u128,
    update_direction: &SpotBalanceType,
    spot_market: &mut SpotMarket,
    spot_balance: &mut dyn SpotBalance,
    is_leaving_drift: bool,
) -> DriftResult {
    let increase_user_existing_balance = update_direction == spot_balance.balance_type();
    if increase_user_existing_balance {
        let round_up = spot_balance.balance_type() == &SpotBalanceType::Borrow;
        let balance_delta =
            get_spot_balance(token_amount, spot_market, update_direction, round_up)?;
        spot_balance.increase_balance(balance_delta)?;
        increase_spot_balance(balance_delta, spot_market, update_direction)?;
    } else {
        let current_token_amount = get_token_amount(
            spot_balance.balance(),
            spot_market,
            spot_balance.balance_type(),
        )?;

        let reduce_user_existing_balance = current_token_amount != 0;
        if reduce_user_existing_balance {
            // determine how much to reduce balance based on size of current token amount
            let (token_delta, balance_delta) = if current_token_amount > token_amount {
                let round_up =
                    is_leaving_drift || spot_balance.balance_type() == &SpotBalanceType::Borrow;
                let balance_delta = get_spot_balance(
                    token_amount,
                    spot_market,
                    spot_balance.balance_type(),
                    round_up,
                )?;
                (token_amount, balance_delta)
            } else {
                (current_token_amount, spot_balance.balance())
            };

            decrease_spot_balance(balance_delta, spot_market, spot_balance.balance_type())?;
            spot_balance.decrease_balance(balance_delta)?;
            token_amount = token_amount.safe_sub(token_delta)?;
        }

        if token_amount > 0 {
            spot_balance.update_balance_type(*update_direction)?;
            let round_up = update_direction == &SpotBalanceType::Borrow;
            let balance_delta =
                get_spot_balance(token_amount, spot_market, update_direction, round_up)?;
            spot_balance.increase_balance(balance_delta)?;
            increase_spot_balance(balance_delta, spot_market, update_direction)?;
        }
    }

    if is_leaving_drift && update_direction == &SpotBalanceType::Borrow {
        let deposit_token_amount = get_token_amount(
            spot_market.deposit_balance,
            spot_market,
            &SpotBalanceType::Deposit,
        )?;

        let borrow_token_amount = get_token_amount(
            spot_market.borrow_balance,
            spot_market,
            &SpotBalanceType::Borrow,
        )?;

        validate!(
            deposit_token_amount >= borrow_token_amount,
            ErrorCode::SpotMarketInsufficientDeposits,
            "Spot Market has insufficent deposits to complete withdraw: deposits ({}) borrows ({})",
            deposit_token_amount,
            borrow_token_amount
        )?;
    }

    Ok(())
}

pub fn transfer_spot_balances(
    token_amount: i128,
    spot_market: &mut SpotMarket,
    from_spot_balance: &mut dyn SpotBalance,
    to_spot_balance: &mut dyn SpotBalance,
) -> DriftResult {
    validate!(
        from_spot_balance.market_index() == to_spot_balance.market_index(),
        ErrorCode::UnequalMarketIndexForSpotTransfer,
        "transfer market indexes arent equal",
    )?;

    if token_amount == 0 {
        return Ok(());
    }

    if from_spot_balance.balance_type() == &SpotBalanceType::Deposit {
        validate!(
            spot_market.deposit_balance >= from_spot_balance.balance(),
            ErrorCode::InvalidSpotMarketState,
            "spot_market.deposit_balance={} lower than individual spot balance={}",
            spot_market.deposit_balance,
            from_spot_balance.balance()
        )?;
    }

    update_spot_balances(
        token_amount.unsigned_abs(),
        if token_amount < 0 {
            &SpotBalanceType::Deposit
        } else {
            &SpotBalanceType::Borrow
        },
        spot_market,
        from_spot_balance,
        false,
    )?;

    update_spot_balances(
        token_amount.unsigned_abs(),
        if token_amount < 0 {
            &SpotBalanceType::Borrow
        } else {
            &SpotBalanceType::Deposit
        },
        spot_market,
        to_spot_balance,
        false,
    )?;

    Ok(())
}

pub fn transfer_revenue_pool_to_spot_balance(
    token_amount: u128,
    spot_market: &mut SpotMarket,
    to_spot_balance: &mut dyn SpotBalance,
) -> DriftResult {
    validate!(
        to_spot_balance.market_index() == spot_market.market_index,
        ErrorCode::UnequalMarketIndexForSpotTransfer,
        "transfer market indexes arent equal",
    )?;

    update_revenue_pool_balances(token_amount, &SpotBalanceType::Borrow, spot_market)?;

    update_spot_balances(
        token_amount,
        &SpotBalanceType::Deposit,
        spot_market,
        to_spot_balance,
        false,
    )?;

    Ok(())
}

pub fn transfer_spot_balance_to_revenue_pool(
    token_amount: u128,
    spot_market: &mut SpotMarket,
    from_spot_balance: &mut dyn SpotBalance,
) -> DriftResult {
    validate!(
        from_spot_balance.market_index() == spot_market.market_index,
        ErrorCode::UnequalMarketIndexForSpotTransfer,
        "transfer market indexes arent equal",
    )?;

    update_spot_balances(
        token_amount,
        &SpotBalanceType::Borrow,
        spot_market,
        from_spot_balance,
        false,
    )?;

    update_revenue_pool_balances(token_amount, &SpotBalanceType::Deposit, spot_market)?;

    Ok(())
}

pub fn update_spot_market_and_check_validity(
    spot_market: &mut SpotMarket,
    oracle_price_data: &OraclePriceData,
    validity_guard_rails: &ValidityGuardRails,
    now: i64,
    action: Option<DriftAction>,
) -> DriftResult {
    // update spot market EMAs with new/current data
    update_spot_market_cumulative_interest(spot_market, Some(oracle_price_data), now)?;

    if spot_market.market_index == QUOTE_SPOT_MARKET_INDEX {
        return Ok(());
    }

    // 1 hour EMA
    let risk_ema_price = spot_market.historical_oracle_data.last_oracle_price_twap;

    let oracle_validity = oracle_validity(
        MarketType::Spot,
        spot_market.market_index,
        risk_ema_price,
        oracle_price_data,
        validity_guard_rails,
        spot_market.get_max_confidence_interval_multiplier()?,
        &spot_market.oracle_source,
        LogMode::ExchangeOracle,
        0,
        0,
    )?;

    validate!(
        is_oracle_valid_for_action(oracle_validity, action)?,
        ErrorCode::InvalidOracle,
        "Invalid Oracle ({:?} vs ema={:?}) for spot market index={} and action={:?}",
        oracle_price_data,
        risk_ema_price,
        spot_market.market_index,
        action
    )?;

    Ok(())
}

fn increase_spot_balance(
    delta: u128,
    spot_market: &mut SpotMarket,
    balance_type: &SpotBalanceType,
) -> DriftResult {
    match balance_type {
        SpotBalanceType::Deposit => {
            spot_market.deposit_balance = spot_market.deposit_balance.safe_add(delta)?
        }
        SpotBalanceType::Borrow => {
            spot_market.borrow_balance = spot_market.borrow_balance.safe_add(delta)?
        }
    }

    Ok(())
}

fn decrease_spot_balance(
    delta: u128,
    spot_market: &mut SpotMarket,
    balance_type: &SpotBalanceType,
) -> DriftResult {
    match balance_type {
        SpotBalanceType::Deposit => {
            spot_market.deposit_balance = spot_market.deposit_balance.safe_sub(delta)?
        }
        SpotBalanceType::Borrow => {
            spot_market.borrow_balance = spot_market.borrow_balance.safe_sub(delta)?
        }
    }

    Ok(())
}



================================================
FILE: programs/drift/src/controller/spot_position.rs
================================================
use crate::msg;

use crate::controller::position::PositionDirection;
use crate::controller::spot_balance::update_spot_balances;
use crate::error::DriftResult;
use crate::error::ErrorCode;
use crate::math::casting::Cast;
use crate::math::safe_math::SafeMath;
use crate::math::spot_withdraw::check_withdraw_limits;
use crate::math_error;
use crate::safe_decrement;
use crate::safe_increment;
use crate::state::paused_operations::SpotOperation;
use crate::state::perp_market::MarketStatus;
use crate::state::spot_market::{AssetTier, SpotBalance, SpotBalanceType, SpotMarket};
use crate::state::user::{SpotPosition, User};

use crate::validate;

#[cfg(test)]
mod tests;

pub fn increase_spot_open_bids_and_asks(
    spot_position: &mut SpotPosition,
    direction: &PositionDirection,
    base_asset_amount_unfilled: u64,
    update: bool,
) -> DriftResult {
    if !update {
        return Ok(());
    }

    match direction {
        PositionDirection::Long => {
            spot_position.open_bids = spot_position
                .open_bids
                .safe_add(base_asset_amount_unfilled.cast()?)?;
        }
        PositionDirection::Short => {
            spot_position.open_asks = spot_position
                .open_asks
                .safe_sub(base_asset_amount_unfilled.cast()?)?;
        }
    }

    Ok(())
}

pub fn decrease_spot_open_bids_and_asks(
    spot_position: &mut SpotPosition,
    direction: &PositionDirection,
    base_asset_amount_unfilled: u64,
    update: bool,
) -> DriftResult {
    if !update {
        return Ok(());
    }

    match direction {
        PositionDirection::Long => {
            spot_position.open_bids = spot_position
                .open_bids
                .safe_sub(base_asset_amount_unfilled.cast()?)?
                .max(0);
        }
        PositionDirection::Short => {
            spot_position.open_asks = spot_position
                .open_asks
                .safe_add(base_asset_amount_unfilled.cast()?)?
                .min(0);
        }
    }

    Ok(())
}

pub fn update_spot_balances_and_cumulative_deposits(
    token_amount: u128,
    update_direction: &SpotBalanceType,
    spot_market: &mut SpotMarket,
    spot_position: &mut SpotPosition,
    is_leaving_drift: bool,
    cumulative_deposit_delta: Option<u128>,
) -> DriftResult {
    update_spot_balances(
        token_amount,
        update_direction,
        spot_market,
        spot_position,
        is_leaving_drift,
    )?;

    let cumulative_deposit_delta = cumulative_deposit_delta.unwrap_or(token_amount);
    match update_direction {
        SpotBalanceType::Deposit => {
            safe_increment!(
                spot_position.cumulative_deposits,
                cumulative_deposit_delta.cast()?
            )
        }
        SpotBalanceType::Borrow => {
            safe_decrement!(
                spot_position.cumulative_deposits,
                cumulative_deposit_delta.cast()?
            )
        }
    }

    Ok(())
}

pub fn update_spot_balances_and_cumulative_deposits_with_limits(
    token_amount: u128,
    update_direction: &SpotBalanceType,
    spot_market: &mut SpotMarket,
    user: &mut User,
) -> DriftResult {
    let spot_position_index = user.force_get_spot_position_index(spot_market.market_index)?;

    update_spot_balances_and_cumulative_deposits(
        token_amount,
        update_direction,
        spot_market,
        &mut user.spot_positions[spot_position_index],
        true,
        None,
    )?;

    let valid_withdraw = check_withdraw_limits(spot_market, Some(user), Some(token_amount))?;

    validate!(
        valid_withdraw,
        ErrorCode::DailyWithdrawLimit,
        "Spot Market {} has hit daily withdraw limit. Attempted withdraw amount of {} by {}",
        spot_market.market_index,
        token_amount,
        user.authority
    )?;

    validate!(
        matches!(
            spot_market.status,
            MarketStatus::Active | MarketStatus::ReduceOnly | MarketStatus::Settlement
        ),
        ErrorCode::MarketWithdrawPaused,
        "Spot Market {} withdraws are currently paused, market not active or in settlement",
        spot_market.market_index
    )?;

    validate!(
        !spot_market.is_operation_paused(SpotOperation::Withdraw),
        ErrorCode::MarketWithdrawPaused,
        "Spot Market {} withdraws are currently paused",
        spot_market.market_index
    )?;

    validate!(
        !(spot_market.asset_tier == AssetTier::Protected
            && user.spot_positions[spot_position_index].balance_type() == &SpotBalanceType::Borrow),
        ErrorCode::ProtectedAssetTierViolation,
        "Spot Market {} has Protected status and cannot be borrowed",
        spot_market.market_index
    )?;

    Ok(())
}

#[cfg(test)]
pub fn transfer_spot_position_deposit(
    token_amount: i128,
    spot_market: &mut SpotMarket,
    from_spot_position: &mut SpotPosition,
    to_spot_position: &mut SpotPosition,
) -> DriftResult {
    validate!(
        from_spot_position.market_index == to_spot_position.market_index,
        ErrorCode::UnequalMarketIndexForSpotTransfer,
        "transfer market indexes arent equal",
    )?;

    if token_amount < 0 {
        update_spot_balances_and_cumulative_deposits(
            token_amount.unsigned_abs(),
            &SpotBalanceType::Deposit,
            spot_market,
            from_spot_position,
            false,
            None,
        )?;

        update_spot_balances_and_cumulative_deposits(
            token_amount.unsigned_abs(),
            &SpotBalanceType::Borrow,
            spot_market,
            to_spot_position,
            false,
            None,
        )?;
    } else {
        update_spot_balances_and_cumulative_deposits(
            token_amount.unsigned_abs(),
            &SpotBalanceType::Deposit,
            spot_market,
            to_spot_position,
            false,
            None,
        )?;

        update_spot_balances_and_cumulative_deposits(
            token_amount.unsigned_abs(),
            &SpotBalanceType::Borrow,
            spot_market,
            from_spot_position,
            false,
            None,
        )?;
    }

    Ok(())
}



================================================
FILE: programs/drift/src/controller/token.rs
================================================
use crate::error::ErrorCode;
use crate::signer::get_signer_seeds;
use crate::validate;
use anchor_lang::prelude::*;
use anchor_spl::token_2022::spl_token_2022;
use anchor_spl::token_2022::spl_token_2022::extension::transfer_fee::TransferFeeConfig;
use anchor_spl::token_2022::spl_token_2022::extension::{
    BaseStateWithExtensions, StateWithExtensions,
};
use anchor_spl::token_2022::spl_token_2022::state::Mint as MintInner;
use anchor_spl::token_interface::{
    self, CloseAccount, Mint, TokenAccount, TokenInterface, Transfer, TransferChecked,
};
use std::iter::Peekable;
use std::slice::Iter;

pub fn send_from_program_vault<'info>(
    token_program: &Interface<'info, TokenInterface>,
    from: &InterfaceAccount<'info, TokenAccount>,
    to: &InterfaceAccount<'info, TokenAccount>,
    authority: &AccountInfo<'info>,
    nonce: u8,
    amount: u64,
    mint: &Option<InterfaceAccount<'info, Mint>>,
    remaining_accounts: Option<&mut Peekable<Iter<'info, AccountInfo<'info>>>>,
) -> Result<()> {
    let signature_seeds = get_signer_seeds(&nonce);
    let signers = &[&signature_seeds[..]];

    if let Some(mint) = mint {
        if let Some(remaining_accounts) = remaining_accounts {
            transfer_checked_with_transfer_hook(
                token_program,
                from,
                to,
                authority,
                amount,
                mint,
                remaining_accounts,
                signers,
            )
        } else {
            let mint_account_info = mint.to_account_info();

            validate_mint_fee(&mint_account_info)?;

            let cpi_accounts = TransferChecked {
                from: from.to_account_info(),
                mint: mint_account_info,
                to: to.to_account_info(),
                authority: authority.to_account_info(),
            };

            let cpi_program = token_program.to_account_info();
            let cpi_context = CpiContext::new_with_signer(cpi_program, cpi_accounts, signers);
            token_interface::transfer_checked(cpi_context, amount, mint.decimals)
        }
    } else {
        let cpi_accounts = Transfer {
            from: from.to_account_info(),
            to: to.to_account_info(),
            authority: authority.to_account_info(),
        };

        let cpi_program = token_program.to_account_info();
        let cpi_context = CpiContext::new_with_signer(cpi_program, cpi_accounts, signers);
        #[allow(deprecated)]
        token_interface::transfer(cpi_context, amount)
    }
}

pub fn receive<'info>(
    token_program: &Interface<'info, TokenInterface>,
    from: &InterfaceAccount<'info, TokenAccount>,
    to: &InterfaceAccount<'info, TokenAccount>,
    authority: &AccountInfo<'info>,
    amount: u64,
    mint: &Option<InterfaceAccount<'info, Mint>>,
    remaining_accounts: Option<&mut Peekable<Iter<'info, AccountInfo<'info>>>>,
) -> Result<()> {
    if let Some(mint) = mint {
        if let Some(remaining_account_metas) = remaining_accounts {
            transfer_checked_with_transfer_hook(
                token_program,
                from,
                to,
                authority,
                amount,
                mint,
                remaining_account_metas,
                &[],
            )
        } else {
            let mint_account_info = mint.to_account_info();

            validate_mint_fee(&mint_account_info)?;

            let cpi_accounts = TransferChecked {
                from: from.to_account_info(),
                to: to.to_account_info(),
                mint: mint_account_info,
                authority: authority.to_account_info(),
            };
            let cpi_program = token_program.to_account_info();
            let cpi_context = CpiContext::new(cpi_program, cpi_accounts);
            token_interface::transfer_checked(cpi_context, amount, mint.decimals)
        }
    } else {
        let cpi_accounts = Transfer {
            from: from.to_account_info(),
            to: to.to_account_info(),
            authority: authority.to_account_info(),
        };
        let cpi_program = token_program.to_account_info();
        let cpi_context = CpiContext::new(cpi_program, cpi_accounts);
        #[allow(deprecated)]
        token_interface::transfer(cpi_context, amount)
    }
}

pub fn close_vault<'info>(
    token_program: &Interface<'info, TokenInterface>,
    account: &InterfaceAccount<'info, TokenAccount>,
    destination: &AccountInfo<'info>,
    authority: &AccountInfo<'info>,
    nonce: u8,
) -> Result<()> {
    let signature_seeds = get_signer_seeds(&nonce);
    let signers = &[&signature_seeds[..]];
    let cpi_accounts = CloseAccount {
        account: account.to_account_info(),
        destination: destination.clone(),
        authority: authority.to_account_info(),
    };
    let cpi_program = token_program.to_account_info();
    let cpi_context = CpiContext::new_with_signer(cpi_program, cpi_accounts, signers);
    token_interface::close_account(cpi_context)
}

pub fn validate_mint_fee(account_info: &AccountInfo) -> Result<()> {
    let mint_data = account_info.try_borrow_data()?;
    let mint_with_extension = StateWithExtensions::<MintInner>::unpack(&mint_data)?;
    if let Ok(fee_config) = mint_with_extension.get_extension::<TransferFeeConfig>() {
        let fee = u16::from(
            fee_config
                .get_epoch_fee(Clock::get()?.epoch)
                .transfer_fee_basis_points,
        );
        validate!(fee == 0, ErrorCode::NonZeroTransferFee)?
    }

    Ok(())
}

pub fn transfer_checked_with_transfer_hook<'info>(
    token_program: &Interface<'info, TokenInterface>,
    from: &InterfaceAccount<'info, TokenAccount>,
    to: &InterfaceAccount<'info, TokenAccount>,
    authority: &AccountInfo<'info>,
    amount: u64,
    mint: &InterfaceAccount<'info, Mint>,
    remaining_accounts: &mut Peekable<Iter<'info, AccountInfo<'info>>>,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    let mint_account_info = mint.to_account_info();

    validate_mint_fee(&mint_account_info)?;

    let from_account_info = from.to_account_info();
    let to_account_info = to.to_account_info();
    let authority_account_info = authority.to_account_info();

    let mut ix = spl_token_2022::instruction::transfer_checked(
        token_program.key,
        &from_account_info.key,
        &mint_account_info.key,
        &to_account_info.key,
        &authority_account_info.key,
        &[],
        amount,
        mint.decimals,
    )?;

    let mut account_infos = vec![
        from_account_info,
        mint_account_info,
        to_account_info,
        authority_account_info,
    ];

    for account_info in remaining_accounts {
        ix.accounts.push(if account_info.is_writable {
            AccountMeta::new(*account_info.key, account_info.is_signer)
        } else {
            AccountMeta::new_readonly(*account_info.key, account_info.is_writable)
        });
        account_infos.push(account_info.to_account_info());
    }

    solana_program::program::invoke_signed(&ix, &account_infos, signer_seeds).map_err(Into::into)
}

pub fn initialize_token_account<'info>(
    token_program: &Interface<'info, TokenInterface>,
    account: &AccountInfo<'info>,
    owner: &AccountInfo<'info>,
    mint: &InterfaceAccount<'info, Mint>,
) -> Result<()> {
    let cpi_program = token_program.to_account_info();
    let accounts = ::anchor_spl::token_interface::InitializeAccount3 {
        account: account.to_account_info(),
        mint: mint.to_account_info(),
        authority: owner.to_account_info(),
    };
    let cpi_ctx = anchor_lang::context::CpiContext::new(cpi_program, accounts);
    ::anchor_spl::token_interface::initialize_account3(cpi_ctx)?;

    Ok(())
}

pub fn initialize_immutable_owner<'info>(
    token_program: &Interface<'info, TokenInterface>,
    account: &AccountInfo<'info>,
) -> Result<()> {
    let accounts = ::anchor_spl::token_interface::InitializeImmutableOwner {
        account: account.to_account_info(),
    };
    let cpi_ctx = anchor_lang::context::CpiContext::new(token_program.to_account_info(), accounts);
    ::anchor_spl::token_interface::initialize_immutable_owner(cpi_ctx)?;

    Ok(())
}



================================================
FILE: programs/drift/src/controller/insurance/tests.rs
================================================
use anchor_lang::prelude::Pubkey;

use crate::controller::insurance::*;
use crate::math::constants::{
    QUOTE_PRECISION, SPOT_BALANCE_PRECISION, SPOT_CUMULATIVE_INTEREST_PRECISION,
};
use crate::state::perp_market::PoolBalance;
use crate::state::spot_market::InsuranceFund;
use crate::state::user::UserStats;
#[test]
pub fn basic_stake_if_test() {
    assert_eq!(0_i32.signum(), 0);
    assert_eq!(1_i32.signum(), 1);
    assert_eq!(-1_i32.signum(), -1);

    assert_eq!(0_i128.signum(), 0);
    assert_eq!(1_i128.signum(), 1);

    let mut if_balance = 0;

    let mut if_stake = InsuranceFundStake::new(Pubkey::default(), 0, 0);
    let mut user_stats = UserStats {
        number_of_sub_accounts: 0,
        ..UserStats::default()
    };
    let amount = QUOTE_PRECISION as u64; // $1
    let mut spot_market = SpotMarket {
        deposit_balance: 0,
        cumulative_deposit_interest: 1111 * SPOT_CUMULATIVE_INTEREST_PRECISION / 1000,
        insurance_fund: InsuranceFund {
            unstaking_period: 0,
            ..InsuranceFund::default()
        },
        ..SpotMarket::default()
    };

    add_insurance_fund_stake(
        amount,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .unwrap();
    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    if_balance += amount;

    // must request first
    assert!(remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0
    )
    .is_err());

    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    assert_eq!(spot_market.insurance_fund.total_shares, amount as u128);
    assert_eq!(spot_market.insurance_fund.shares_base, 0);

    request_remove_insurance_fund_stake(
        if_stake.unchecked_if_shares(),
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();
    assert_eq!(
        if_stake.last_withdraw_request_shares,
        if_stake.unchecked_if_shares()
    );
    assert_eq!(if_stake.last_withdraw_request_value, if_balance - 1); //rounding in favor
    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    assert_eq!(spot_market.insurance_fund.total_shares, amount as u128);
    assert_eq!(spot_market.insurance_fund.shares_base, 0);

    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(amount_returned, amount - 1);
    if_balance -= amount_returned;

    assert_eq!(if_stake.unchecked_if_shares(), 0);
    assert_eq!(if_stake.cost_basis, 1);
    assert_eq!(if_stake.last_withdraw_request_shares, 0);
    assert_eq!(if_stake.last_withdraw_request_value, 0);
    assert_eq!(spot_market.insurance_fund.total_shares, 0);
    assert_eq!(spot_market.insurance_fund.shares_base, 0);
    assert_eq!(if_balance, 1);

    add_insurance_fund_stake(
        1234,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .unwrap();
    assert_eq!(if_stake.cost_basis, 1234);
    assert_eq!(spot_market.insurance_fund.user_shares, 1234);
    assert_eq!(spot_market.insurance_fund.total_shares, 1235); // protocol claims the 1 balance
    assert_eq!(spot_market.insurance_fund.shares_base, 0);
}

#[test]
pub fn basic_seeded_stake_if_test() {
    let mut if_balance = (1000 * QUOTE_PRECISION) as u64;
    let mut if_stake = InsuranceFundStake::new(Pubkey::default(), 0, 0);
    let mut user_stats = UserStats {
        number_of_sub_accounts: 0,
        ..UserStats::default()
    };
    let amount = QUOTE_PRECISION as u64; // $1
    let mut spot_market = SpotMarket {
        deposit_balance: 0,
        cumulative_deposit_interest: 1111 * SPOT_CUMULATIVE_INTEREST_PRECISION / 1000,
        insurance_fund: InsuranceFund {
            unstaking_period: 0,
            ..InsuranceFund::default()
        },
        ..SpotMarket::default()
    };

    assert_eq!(spot_market.insurance_fund.total_shares, 0);
    assert_eq!(spot_market.insurance_fund.user_shares, 0);

    add_insurance_fund_stake(
        amount,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .unwrap();

    assert_eq!(
        spot_market.insurance_fund.total_shares,
        (1001 * QUOTE_PRECISION)
    ); // seeded works
    assert_eq!(spot_market.insurance_fund.user_shares, QUOTE_PRECISION);
    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    if_balance += amount;

    // must request first
    assert!(remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0
    )
    .is_err());
    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);

    request_remove_insurance_fund_stake(
        if_stake.unchecked_if_shares(),
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();
    assert_eq!(
        if_stake.last_withdraw_request_shares,
        if_stake.unchecked_if_shares()
    );
    assert_eq!(if_stake.last_withdraw_request_value, 1000000);

    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(amount_returned, amount);
    if_balance -= amount_returned;

    assert_eq!(if_stake.unchecked_if_shares(), 0);
    assert_eq!(if_stake.cost_basis, 0);
    assert_eq!(if_stake.last_withdraw_request_shares, 0);
    assert_eq!(if_stake.last_withdraw_request_value, 0);
    assert_eq!(if_balance, 1000000000);

    add_insurance_fund_stake(
        1234,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .unwrap();
    assert_eq!(if_stake.cost_basis, 1234);
}

#[test]
pub fn large_num_seeded_stake_if_test() {
    let mut if_balance = (199_000_000 * QUOTE_PRECISION) as u64; // ~200M
    let mut if_stake = InsuranceFundStake::new(Pubkey::default(), 0, 0);
    let mut user_stats = UserStats {
        number_of_sub_accounts: 0,
        ..UserStats::default()
    };

    let amount = 199_000_001; // ~200M + 1

    // all funds in revenue pool
    let mut spot_market = SpotMarket {
        deposit_balance: 100 * SPOT_BALANCE_PRECISION,
        cumulative_deposit_interest: 1111 * SPOT_CUMULATIVE_INTEREST_PRECISION / 1000,
        insurance_fund: InsuranceFund {
            unstaking_period: 0,
            revenue_settle_period: 1,
            ..InsuranceFund::default()
        },
        revenue_pool: PoolBalance {
            market_index: 0,
            scaled_balance: 100 * SPOT_BALANCE_PRECISION,
            ..PoolBalance::default()
        },
        ..SpotMarket::default()
    };

    assert_eq!(spot_market.insurance_fund.total_shares, 0);
    assert_eq!(spot_market.insurance_fund.user_shares, 0);

    add_insurance_fund_stake(
        amount,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .unwrap();

    assert_eq!(spot_market.insurance_fund.total_shares, 199000199000001); // seeded works
    assert_eq!(spot_market.insurance_fund.user_shares, 199000001);
    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    if_balance += amount;

    // must request first
    assert!(remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0
    )
    .is_err());
    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    let spot_market_vault_amount = get_token_amount(
        spot_market.deposit_balance,
        &spot_market,
        &SpotBalanceType::Deposit,
    )
    .unwrap() as u64;
    assert_eq!(spot_market_vault_amount, 111);

    let flow = settle_revenue_to_insurance_fund(
        spot_market_vault_amount,
        if_balance,
        &mut spot_market,
        1,
        true,
    )
    .unwrap();
    assert_eq!(flow, 11);
    assert_eq!(spot_market.revenue_pool.scaled_balance, 90099009901);
    let spot_market_vault_amount = get_token_amount(
        spot_market.deposit_balance,
        &spot_market,
        &SpotBalanceType::Deposit,
    )
    .unwrap() as u64;
    assert_eq!(spot_market_vault_amount, 100);

    if_balance += flow;

    request_remove_insurance_fund_stake(
        if_stake.unchecked_if_shares(),
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();
    assert_eq!(
        if_stake.last_withdraw_request_shares,
        if_stake.unchecked_if_shares()
    );
    assert_eq!(if_stake.last_withdraw_request_value, 199000001);

    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        1,
    ))
    .unwrap();
    assert_eq!(amount_returned, amount);
    if_balance -= amount_returned;

    assert_eq!(if_stake.unchecked_if_shares(), 0);
    assert_eq!(if_stake.cost_basis, 0);
    assert_eq!(if_stake.last_withdraw_request_shares, 0);
    assert_eq!(if_stake.last_withdraw_request_value, 0);
    assert_eq!(if_balance, 199000000000011);
    assert_eq!(spot_market.insurance_fund.user_shares, 0);
    assert_eq!(spot_market.insurance_fund.total_shares, 199000000000000);

    spot_market.revenue_pool.scaled_balance = 100 * SPOT_BALANCE_PRECISION;

    add_insurance_fund_stake(
        199033744205760,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        20,
        false,
    )
    .unwrap();
    assert_eq!(if_stake.cost_basis, 199033744205760);
    assert_eq!(spot_market.insurance_fund.user_shares, 199033744205748);

    add_insurance_fund_stake(
        199033744205760,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        30,
        false,
    )
    .unwrap();
    assert_eq!(if_stake.cost_basis, 398067488411520);
    assert_eq!(spot_market.insurance_fund.user_shares, 597134982544960);
}

#[test]
pub fn gains_stake_if_test() {
    let mut if_balance = 0;
    let mut if_stake = InsuranceFundStake::new(Pubkey::default(), 0, 0);
    let mut user_stats = UserStats {
        number_of_sub_accounts: 0,
        ..UserStats::default()
    };
    let amount = QUOTE_PRECISION as u64; // $1
    let mut spot_market = SpotMarket {
        deposit_balance: 0,
        cumulative_deposit_interest: 1111 * SPOT_CUMULATIVE_INTEREST_PRECISION / 1000,
        insurance_fund: InsuranceFund {
            unstaking_period: 0,
            ..InsuranceFund::default()
        },
        ..SpotMarket::default()
    };

    add_insurance_fund_stake(
        amount,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .unwrap();
    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    if_balance += amount;

    // gains
    if_balance += amount / 19;

    let n_shares = if_stake.unchecked_if_shares();
    let expected_amount_returned = (amount + amount / 19) / 3 - 1;

    request_remove_insurance_fund_stake(
        n_shares / 3,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();
    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(amount_returned, expected_amount_returned);
    assert_eq!(if_stake.unchecked_if_shares(), n_shares * 2 / 3 + 1);
    if_balance -= amount_returned;

    request_remove_insurance_fund_stake(
        n_shares / 3,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();
    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(if_stake.unchecked_if_shares(), n_shares / 3 + 1);
    assert_eq!(amount_returned, expected_amount_returned);
    if_balance -= amount_returned;

    request_remove_insurance_fund_stake(
        1,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();

    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(amount_returned, 1);

    request_remove_insurance_fund_stake(
        n_shares / 3 - 1,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();

    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(amount_returned, expected_amount_returned + 1);

    if_balance -= amount_returned;

    assert_eq!(if_balance, 2);
}

#[test]
pub fn losses_stake_if_test() {
    let mut if_balance = 0;
    let mut if_stake = InsuranceFundStake::new(Pubkey::default(), 0, 0);
    let mut user_stats = UserStats {
        number_of_sub_accounts: 0,
        ..UserStats::default()
    };
    let amount = QUOTE_PRECISION as u64; // $1
    let mut spot_market = SpotMarket {
        deposit_balance: 0,
        cumulative_deposit_interest: 1111 * SPOT_CUMULATIVE_INTEREST_PRECISION / 1000,
        insurance_fund: InsuranceFund {
            unstaking_period: 0,
            ..InsuranceFund::default()
        },
        ..SpotMarket::default()
    };

    add_insurance_fund_stake(
        amount,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .unwrap();
    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    if_balance += amount;

    // gains
    if_balance -= amount / 19;

    let n_shares = if_stake.unchecked_if_shares();
    let expected_amount_returned = (amount - amount / 19) / 3;

    request_remove_insurance_fund_stake(
        n_shares / 3,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();

    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(amount_returned, expected_amount_returned);
    assert_eq!(if_stake.unchecked_if_shares(), n_shares * 2 / 3 + 1);
    if_balance -= amount_returned;

    request_remove_insurance_fund_stake(
        n_shares / 3,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();
    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(if_stake.unchecked_if_shares(), n_shares / 3 + 1);
    assert_eq!(amount_returned, expected_amount_returned);
    if_balance -= amount_returned;

    request_remove_insurance_fund_stake(
        1,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();

    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(if_stake.unchecked_if_shares(), n_shares / 3);
    assert_eq!(amount_returned, 0);

    request_remove_insurance_fund_stake(
        n_shares / 3,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    )
    .unwrap();
    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
    ))
    .unwrap();
    assert_eq!(amount_returned, expected_amount_returned + 1);
    assert_eq!(if_stake.cost_basis, 52632);
    assert_eq!(if_stake.unchecked_if_shares(), 0);

    if_balance -= amount_returned;

    assert_eq!(if_balance, 1); // todo, should be stricer w/ rounding?
}

#[test]
pub fn escrow_losses_stake_if_test() {
    let mut if_balance = 0;
    let mut if_stake = InsuranceFundStake::new(Pubkey::default(), 0, 0);
    let mut user_stats = UserStats {
        number_of_sub_accounts: 0,
        ..UserStats::default()
    };
    let amount = (QUOTE_PRECISION * 100_000) as u64; // $100k
    let mut spot_market = SpotMarket {
        deposit_balance: 0,
        cumulative_deposit_interest: 1111 * SPOT_CUMULATIVE_INTEREST_PRECISION / 1000,
        insurance_fund: InsuranceFund {
            unstaking_period: 60 * 60 * 24 * 7, // 7 weeks
            ..InsuranceFund::default()
        },
        ..SpotMarket::default()
    };

    let now = 7842193748;

    add_insurance_fund_stake(
        amount,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .unwrap();
    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    if_balance += amount;

    // losses
    if_balance -= amount / 19;

    let n_shares = if_stake.unchecked_if_shares();
    let expected_amount_returned = (amount - amount / 19) / 3;

    let o = if_shares_to_vault_amount(
        n_shares / 3,
        spot_market.insurance_fund.total_shares,
        if_balance,
    )
    .unwrap();
    assert_eq!(if_stake.last_withdraw_request_shares, 0);

    request_remove_insurance_fund_stake(
        n_shares / 3,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        now,
    )
    .unwrap();
    assert_eq!(if_stake.last_withdraw_request_shares, 33333333333);
    assert_eq!(
        if_stake.last_withdraw_request_value,
        expected_amount_returned
    );
    assert_eq!(expected_amount_returned, o);
    assert_eq!(o, 31578947368);

    // not enough time for withdraw
    assert!(remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        now + 60 * 60 * 24,
    )
    .is_err());

    // more losses
    if_balance = if_balance - if_balance / 2;

    // appropriate time for withdraw
    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        now + 60 * 60 * 24 * 7 + 3254,
    ))
    .unwrap();
    if_balance -= amount_returned;

    // since losses occured during withdraw, worse than expected at time of request
    assert_eq!(amount_returned < (expected_amount_returned - 1), true);
    assert_eq!(amount_returned, 15_789_473_684); //15k
    assert_eq!(if_stake.unchecked_if_shares(), n_shares * 2 / 3 + 1);
    assert_eq!(if_stake.cost_basis, 84_210_526_316); //84k
    assert_eq!(if_balance, 31_578_947_369); //31k
}

#[test]
pub fn escrow_gains_stake_if_test() {
    let mut if_balance = 0;
    let mut if_stake = InsuranceFundStake::new(Pubkey::default(), 0, 0);
    let mut user_stats = UserStats {
        number_of_sub_accounts: 0,
        ..UserStats::default()
    };
    let amount = 100_000_384_939_u64; // $100k + change
    let mut spot_market = SpotMarket {
        deposit_balance: 0,
        cumulative_deposit_interest: 1111 * SPOT_CUMULATIVE_INTEREST_PRECISION / 1000,
        insurance_fund: InsuranceFund {
            unstaking_period: 60 * 60 * 24 * 7, // 7 weeks
            total_shares: 1,
            user_shares: 0,
            ..InsuranceFund::default()
        },
        ..SpotMarket::default()
    };

    let now = 7842193748;
    assert_eq!(if_balance, 0);
    // right now other users have claim on a zero balance IF... should not give them your money here
    assert!(add_insurance_fund_stake(
        amount,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .is_err());

    if_balance = 1;
    add_insurance_fund_stake(
        amount,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        0,
        false,
    )
    .unwrap();

    assert_eq!(if_stake.unchecked_if_shares(), amount as u128);
    if_balance += amount;
    assert_eq!(if_balance, 100000384940);

    // gains
    if_balance += amount / 13 - 1;

    assert_eq!(if_balance, 107692722242);

    let n_shares = if_stake.unchecked_if_shares();
    let expected_amount_returned =
        (if_balance as u128 * n_shares / spot_market.insurance_fund.total_shares) as u64;

    let o = if_shares_to_vault_amount(
        n_shares,
        spot_market.insurance_fund.total_shares,
        if_balance,
    )
    .unwrap();
    request_remove_insurance_fund_stake(
        n_shares,
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        now,
    )
    .unwrap();
    let value_at_req = if_stake.last_withdraw_request_value;
    assert_eq!(value_at_req, 107692722240);
    assert_eq!(o, 107692722240);

    // not enough time for withdraw
    assert!(remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        now + 60 * 60 * 24,
    )
    .is_err());

    // more gains
    if_balance = if_balance + if_balance / 412;

    let ideal_amount_returned =
        (if_balance as u128 * n_shares / spot_market.insurance_fund.total_shares) as u64;

    // appropriate time for withdraw
    let amount_returned = (remove_insurance_fund_stake(
        if_balance,
        &mut if_stake,
        &mut user_stats,
        &mut spot_market,
        now + 60 * 60 * 24 * 7 + 3254,
    ))
    .unwrap();
    assert_eq!(if_stake.last_withdraw_request_shares, 0);
    assert_eq!(if_stake.last_withdraw_request_value, 0);

    if_balance -= amount_returned;

    assert_eq!(amount_returned < ideal_amount_returned, true);
    assert_eq!(ideal_amount_returned - amount_returned, 261390102);
    assert_eq!(amount_returned, value_at_req);

    // since gains occured, not passed on to user after request
    assert_eq!(amount_returned, (expected_amount_returned));
    assert_eq!(if_stake.unchecked_if_shares(), 0);
    assert_eq!(if_balance, 261_390_104); //$261 for protocol/other stakers
}

#[test]
pub fn drained_stake_if_test_rebase_on_new_add() {
    let mut if_balance = 0;
    let mut if_stake = InsuranceFundStake::new(Pubkey::default(), 0, 0);
    let mut user_stats = UserStats {
        number_of_sub_accounts: 0,
        ..UserStats::default()
    };
    let amount = 100_000_384_939_u64; // $100k + change

    let mut spot_market = SpotMarket {
        deposit_balance: 0,
        cumulative_deposit_interest: 1111 * SPOT_CUMULATIVE_INTEREST_PRECISION / 1000,
        insurance_fund: InsuranceFund {
            unstaking_period: 60 * 60 * 24 * 7, // 7 weeks
            total_shares: 100_000 * QUOTE_PRECISION,
            user_shares: 80_000 * QUOTE_PRECISION,
            ..InsuranceFund::default()
        },
        ..SpotMarket::default()
    };

    assert_eq!(if_balance, 0);

    let mut orig_if_stake = InsuranceFundStake::new(Pubkey::default(), 0, 0);
 