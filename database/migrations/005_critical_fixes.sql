-- QuantDesk Hybrid Points System - Critical Fixes Migration
-- Addresses security, validation, and performance issues identified in review
-- Generated by @dev - December 25, 2024

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ==============================================
-- CRITICAL FIX 1: DATA VALIDATION CONSTRAINTS
-- ==============================================

-- Add CHECK constraints for data integrity
ALTER TABLE points_allocation_periods 
ADD CONSTRAINT check_positive_points_pool 
CHECK (total_points_pool > 0);

ALTER TABLE points_allocation_periods 
ADD CONSTRAINT check_valid_dates 
CHECK (end_date > start_date);

ALTER TABLE activity_multipliers 
ADD CONSTRAINT check_positive_multipliers 
CHECK (base_multiplier > 0 AND early_user_bonus > 0 
       AND active_user_bonus > 0 AND community_bonus > 0);

ALTER TABLE activity_multipliers 
ADD CONSTRAINT check_reasonable_multipliers 
CHECK (base_multiplier <= 10 AND early_user_bonus <= 10 
       AND active_user_bonus <= 10 AND community_bonus <= 10);

ALTER TABLE trading_activity_log 
ADD CONSTRAINT check_valid_activity_type 
CHECK (activity_type IN ('trade', 'deposit', 'withdrawal', 'staking', 'insurance_fund'));

ALTER TABLE trading_activity_log 
ADD CONSTRAINT check_valid_side 
CHECK (side IS NULL OR side IN ('long', 'short', 'buy', 'sell', 'maker', 'taker'));

ALTER TABLE trading_activity_log 
ADD CONSTRAINT check_positive_amount 
CHECK (amount > 0);

ALTER TABLE trading_activity_log 
ADD CONSTRAINT check_reasonable_leverage 
CHECK (leverage IS NULL OR (leverage >= 1 AND leverage <= 100));

-- ==============================================
-- CRITICAL FIX 2: POINT POOL TRACKING
-- ==============================================

-- Add point pool consumption tracking
ALTER TABLE points_allocation_periods 
ADD COLUMN points_distributed BIGINT DEFAULT 0;

ALTER TABLE points_allocation_periods 
ADD COLUMN points_remaining BIGINT GENERATED ALWAYS AS (total_points_pool - points_distributed) STORED;

-- Add constraint to prevent overspending
ALTER TABLE points_allocation_periods 
ADD CONSTRAINT check_points_not_exceeded 
CHECK (points_distributed <= total_points_pool);

-- ==============================================
-- CRITICAL FIX 3: ACTIVE USER DETECTION
-- ==============================================

-- Create function to properly detect active users
CREATE OR REPLACE FUNCTION is_active_user(user_uuid UUID)
RETURNS BOOLEAN AS $$
DECLARE
    recent_activity_count INTEGER;
    days_since_last_activity INTEGER;
BEGIN
    -- Check if user has activity in last 30 days
    SELECT COUNT(*) INTO recent_activity_count
    FROM trading_activity_log 
    WHERE user_id = user_uuid 
    AND created_at > NOW() - INTERVAL '30 days';
    
    -- Check days since last activity
    SELECT EXTRACT(DAYS FROM NOW() - MAX(created_at)) INTO days_since_last_activity
    FROM trading_activity_log 
    WHERE user_id = user_uuid;
    
    -- User is active if they have recent activity OR joined recently
    RETURN recent_activity_count > 0 OR days_since_last_activity IS NULL OR days_since_last_activity <= 7;
END;
$$ LANGUAGE plpgsql;

-- ==============================================
-- CRITICAL FIX 4: RATE LIMITING SYSTEM
-- ==============================================

-- Create rate limiting table
CREATE TABLE IF NOT EXISTS user_rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    activity_type VARCHAR(50) NOT NULL,
    window_start TIMESTAMP NOT NULL,
    activity_count INTEGER DEFAULT 0,
    last_activity TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, activity_type, window_start)
);

-- Create indexes for rate limiting
CREATE INDEX IF NOT EXISTS idx_user_rate_limits_user_id ON user_rate_limits(user_id);
CREATE INDEX IF NOT EXISTS idx_user_rate_limits_activity_type ON user_rate_limits(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_rate_limits_window_start ON user_rate_limits(window_start);

-- Create function to check rate limits
CREATE OR REPLACE FUNCTION check_rate_limit(
    user_uuid UUID,
    activity_type_param VARCHAR(50),
    max_activities_per_hour INTEGER DEFAULT 100,
    max_activities_per_day INTEGER DEFAULT 1000
)
RETURNS BOOLEAN AS $$
DECLARE
    hourly_count INTEGER;
    daily_count INTEGER;
    current_hour TIMESTAMP;
    current_day TIMESTAMP;
BEGIN
    -- Get current hour and day boundaries
    current_hour := date_trunc('hour', NOW());
    current_day := date_trunc('day', NOW());
    
    -- Check hourly rate limit
    SELECT COALESCE(SUM(activity_count), 0) INTO hourly_count
    FROM user_rate_limits
    WHERE user_id = user_uuid
    AND activity_type = activity_type_param
    AND window_start >= current_hour;
    
    -- Check daily rate limit
    SELECT COALESCE(SUM(activity_count), 0) INTO daily_count
    FROM user_rate_limits
    WHERE user_id = user_uuid
    AND activity_type = activity_type_param
    AND window_start >= current_day;
    
    -- Return false if limits exceeded
    RETURN hourly_count < max_activities_per_hour AND daily_count < max_activities_per_day;
END;
$$ LANGUAGE plpgsql;

-- Create function to update rate limits
CREATE OR REPLACE FUNCTION update_rate_limit(
    user_uuid UUID,
    activity_type_param VARCHAR(50)
)
RETURNS VOID AS $$
DECLARE
    current_hour TIMESTAMP;
BEGIN
    current_hour := date_trunc('hour', NOW());
    
    -- Insert or update rate limit record
    INSERT INTO user_rate_limits (user_id, activity_type, window_start, activity_count, last_activity)
    VALUES (user_uuid, activity_type_param, current_hour, 1, NOW())
    ON CONFLICT (user_id, activity_type, window_start)
    DO UPDATE SET 
        activity_count = user_rate_limits.activity_count + 1,
        last_activity = NOW(),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql;

-- ==============================================
-- CRITICAL FIX 5: FRAUD DETECTION SYSTEM
-- ==============================================

-- Create fraud detection table
CREATE TABLE IF NOT EXISTS fraud_detection_log (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    activity_type VARCHAR(50) NOT NULL,
    amount DECIMAL(20,2) NOT NULL,
    suspicion_score DECIMAL(5,2) NOT NULL,
    detection_reason TEXT NOT NULL,
    is_flagged BOOLEAN DEFAULT false,
    reviewed_by UUID REFERENCES users(id),
    reviewed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Create indexes for fraud detection
CREATE INDEX IF NOT EXISTS idx_fraud_detection_user_id ON fraud_detection_log(user_id);
CREATE INDEX IF NOT EXISTS idx_fraud_detection_flagged ON fraud_detection_log(is_flagged);
CREATE INDEX IF NOT EXISTS idx_fraud_detection_score ON fraud_detection_log(suspicion_score DESC);

-- Create function to detect suspicious activity
CREATE OR REPLACE FUNCTION detect_suspicious_activity(
    user_uuid UUID,
    activity_type_param VARCHAR(50),
    activity_amount DECIMAL(20,2)
)
RETURNS DECIMAL(5,2) AS $$
DECLARE
    avg_amount DECIMAL(20,2);
    max_amount DECIMAL(20,2);
    recent_count INTEGER;
    suspicion_score DECIMAL(5,2) := 0;
    detection_reason TEXT := '';
BEGIN
    -- Get user's average activity amount
    SELECT AVG(amount), MAX(amount), COUNT(*) INTO avg_amount, max_amount, recent_count
    FROM trading_activity_log 
    WHERE user_id = user_uuid
    AND activity_type = activity_type_param
    AND created_at > NOW() - INTERVAL '30 days';
    
    -- If no recent activity, set baseline
    IF avg_amount IS NULL THEN
        avg_amount := 100; -- Default baseline
        max_amount := 1000; -- Default max
        recent_count := 0;
    END IF;
    
    -- Calculate suspicion score
    -- Score 1: Amount significantly above average
    IF activity_amount > (avg_amount * 10) THEN
        suspicion_score := suspicion_score + 3.0;
        detection_reason := detection_reason || 'Amount 10x above average; ';
    ELSIF activity_amount > (avg_amount * 5) THEN
        suspicion_score := suspicion_score + 2.0;
        detection_reason := detection_reason || 'Amount 5x above average; ';
    ELSIF activity_amount > (avg_amount * 2) THEN
        suspicion_score := suspicion_score + 1.0;
        detection_reason := detection_reason || 'Amount 2x above average; ';
    END IF;
    
    -- Score 2: Amount above historical max
    IF activity_amount > max_amount THEN
        suspicion_score := suspicion_score + 2.0;
        detection_reason := detection_reason || 'Above historical max; ';
    END IF;
    
    -- Score 3: High frequency activity
    IF recent_count > 50 THEN
        suspicion_score := suspicion_score + 1.0;
        detection_reason := detection_reason || 'High frequency activity; ';
    END IF;
    
    -- Score 4: Very large amounts
    IF activity_amount > 100000 THEN -- $100k+
        suspicion_score := suspicion_score + 2.0;
        detection_reason := detection_reason || 'Very large amount; ';
    END IF;
    
    -- Log suspicious activity if score > 2
    IF suspicion_score > 2.0 THEN
        INSERT INTO fraud_detection_log (
            user_id, activity_type, amount, suspicion_score, detection_reason, is_flagged
        ) VALUES (
            user_uuid, activity_type_param, activity_amount, suspicion_score, 
            TRIM(detection_reason), suspicion_score > 4.0
        );
    END IF;
    
    RETURN suspicion_score;
END;
$$ LANGUAGE plpgsql;

-- ==============================================
-- CRITICAL FIX 6: ENHANCED POINTS CALCULATION
-- ==============================================

-- Update the calculate_dynamic_points function with proper active user detection
CREATE OR REPLACE FUNCTION calculate_dynamic_points(
    activity_type VARCHAR(50),
    amount DECIMAL(20,2),
    period_id UUID,
    market_symbol VARCHAR(20) DEFAULT NULL,
    side VARCHAR(10) DEFAULT NULL,
    leverage DECIMAL(5,2) DEFAULT NULL,
    user_created_at TIMESTAMP DEFAULT NULL
)
RETURNS INTEGER AS $$
DECLARE
    points INTEGER := 0;
    base_multiplier DECIMAL(5,2) := 1.00;
    early_user_bonus DECIMAL(5,2) := 1.00;
    active_user_bonus DECIMAL(5,2) := 1.00;
    community_bonus DECIMAL(5,2) := 1.00;
    total_multiplier DECIMAL(5,2) := 1.00;
    is_early_user BOOLEAN := false;
    is_active_user BOOLEAN := false;
    period_start TIMESTAMP;
    user_uuid UUID;
BEGIN
    -- Get period start date
    SELECT start_date INTO period_start
    FROM points_allocation_periods
    WHERE id = period_id;
    
    -- Get user ID from user_created_at (simplified for now)
    -- In production, this would be passed as a parameter
    SELECT id INTO user_uuid FROM users WHERE created_at = user_created_at LIMIT 1;
    
    -- Check if user is early user (joined before period start)
    IF user_created_at IS NOT NULL AND user_created_at < period_start THEN
        is_early_user := true;
    END IF;
    
    -- Check if user is active user using proper function
    IF user_uuid IS NOT NULL THEN
        is_active_user := is_active_user(user_uuid);
    END IF;
    
    -- Get multipliers for this activity type and period
    SELECT 
        am.base_multiplier,
        am.early_user_bonus,
        am.active_user_bonus,
        am.community_bonus
    INTO 
        base_multiplier,
        early_user_bonus,
        active_user_bonus,
        community_bonus
    FROM activity_multipliers am
    WHERE am.period_id = calculate_dynamic_points.period_id
        AND am.activity_type = calculate_dynamic_points.activity_type;
    
    -- Calculate total multiplier
    total_multiplier := base_multiplier;
    
    IF is_early_user THEN
        total_multiplier := total_multiplier * early_user_bonus;
    END IF;
    
    IF is_active_user THEN
        total_multiplier := total_multiplier * active_user_bonus;
    END IF;
    
    -- Community bonus (simplified - could be based on referrals, etc.)
    total_multiplier := total_multiplier * community_bonus;
    
    -- Calculate base points based on activity type
    CASE activity_type
        WHEN 'trade' THEN
            -- Trading volume points: Dynamic based on period allocation
            points := FLOOR(amount * 0.01 * total_multiplier); -- 1% of amount as base
            -- Bonus for maker volume
            IF side = 'maker' THEN
                points := FLOOR(points * 1.5); -- 50% bonus for makers
            END IF;
            -- Leverage bonus
            IF leverage > 1 THEN
                points := FLOOR(points * (1 + (leverage - 1) * 0.1)); -- 10% bonus per leverage point
            END IF;
            
        WHEN 'deposit' THEN
            -- Deposit points: Higher multiplier than trading
            points := FLOOR(amount * 0.02 * total_multiplier); -- 2% of amount as base
            
        WHEN 'staking' THEN
            -- Staking points: Highest multiplier
            points := FLOOR(amount * 0.03 * total_multiplier); -- 3% of amount as base
            
        WHEN 'insurance_fund' THEN
            -- Insurance fund points: Highest multiplier
            points := FLOOR(amount * 0.05 * total_multiplier); -- 5% of amount as base
            
        WHEN 'withdrawal' THEN
            -- Small penalty for withdrawals to encourage retention
            points := FLOOR(-amount * 0.005 * total_multiplier); -- 0.5% penalty
            
        ELSE
            points := 0;
    END CASE;
    
    -- Ensure points are not negative
    IF points < 0 THEN
        points := 0;
    END IF;
    
    RETURN points;
END;
$$ LANGUAGE plpgsql;

-- ==============================================
-- CRITICAL FIX 7: ENHANCED ACTIVITY PROCESSING
-- ==============================================

-- Update the process_trading_activity function with all security measures
CREATE OR REPLACE FUNCTION process_trading_activity(
    user_uuid UUID,
    activity_type VARCHAR(50),
    amount DECIMAL(20,2),
    market_symbol VARCHAR(20) DEFAULT NULL,
    side VARCHAR(10) DEFAULT NULL,
    leverage DECIMAL(5,2) DEFAULT NULL
)
RETURNS INTEGER AS $$
DECLARE
    points_earned INTEGER;
    activity_id UUID;
    current_period_id UUID;
    user_created_at TIMESTAMP;
    total_multiplier DECIMAL(5,2);
    bonus_type VARCHAR(50);
    suspicion_score DECIMAL(5,2);
    rate_limit_ok BOOLEAN;
BEGIN
    -- Validate inputs
    IF user_uuid IS NULL OR activity_type IS NULL OR amount <= 0 THEN
        RAISE EXCEPTION 'Invalid input parameters';
    END IF;
    
    -- Check rate limits
    rate_limit_ok := check_rate_limit(user_uuid, activity_type);
    IF NOT rate_limit_ok THEN
        RAISE EXCEPTION 'Rate limit exceeded for user % and activity %', user_uuid, activity_type;
    END IF;
    
    -- Detect suspicious activity
    suspicion_score := detect_suspicious_activity(user_uuid, activity_type, amount);
    IF suspicion_score > 4.0 THEN
        RAISE EXCEPTION 'Suspicious activity detected for user %', user_uuid;
    END IF;
    
    -- Get current active period
    SELECT id INTO current_period_id
    FROM points_allocation_periods
    WHERE is_active = true
    ORDER BY start_date DESC
    LIMIT 1;
    
    -- If no active period, return 0
    IF current_period_id IS NULL THEN
        RAISE EXCEPTION 'No active period found';
    END IF;
    
    -- Check if period has remaining points
    IF (SELECT points_remaining FROM points_allocation_periods WHERE id = current_period_id) <= 0 THEN
        RAISE EXCEPTION 'Period point pool exhausted';
    END IF;
    
    -- Get user creation date
    SELECT created_at INTO user_created_at
    FROM users
    WHERE id = user_uuid;
    
    -- Calculate points for this activity
    points_earned := calculate_dynamic_points(
        activity_type, 
        amount, 
        current_period_id, 
        market_symbol, 
        side, 
        leverage, 
        user_created_at
    );
    
    -- Determine bonus type
    bonus_type := 'base';
    IF user_created_at < (SELECT start_date FROM points_allocation_periods WHERE id = current_period_id) THEN
        bonus_type := 'early_user';
    END IF;
    
    -- Log the activity
    INSERT INTO trading_activity_log (
        user_id,
        period_id,
        activity_type,
        amount,
        market_symbol,
        side,
        leverage,
        points_earned,
        multiplier_applied,
        bonus_type
    ) VALUES (
        user_uuid,
        current_period_id,
        activity_type,
        amount,
        market_symbol,
        side,
        leverage,
        points_earned,
        1.00, -- Will be calculated properly in the function
        bonus_type
    ) RETURNING id INTO activity_id;
    
    -- Update rate limits
    PERFORM update_rate_limit(user_uuid, activity_type);
    
    -- Update trading metrics
    CASE activity_type
        WHEN 'trade' THEN
            PERFORM update_trading_metrics(
                user_uuid,
                trading_volume := amount,
                maker_volume := CASE WHEN side = 'maker' THEN amount ELSE 0 END,
                taker_volume := CASE WHEN side = 'taker' THEN amount ELSE 0 END,
                trade_count := 1
            );
        WHEN 'deposit' THEN
            PERFORM update_trading_metrics(
                user_uuid,
                deposit_amount := amount
            );
        WHEN 'withdrawal' THEN
            PERFORM update_trading_metrics(
                user_uuid,
                withdrawal_amount := amount
            );
        WHEN 'staking' THEN
            PERFORM update_trading_metrics(
                user_uuid,
                staking_amount := amount
            );
        WHEN 'insurance_fund' THEN
            PERFORM update_trading_metrics(
                user_uuid,
                insurance_fund_stake := amount
            );
    END CASE;
    
    -- Award points to user
    IF points_earned > 0 THEN
        INSERT INTO points_transactions (
            user_id,
            points,
            transaction_type,
            source,
            description,
            metadata
        ) VALUES (
            user_uuid,
            points_earned,
            'earned',
            'trading_activity',
            'Trading activity: ' || activity_type || ' - ' || amount || ' USD',
            jsonb_build_object(
                'activity_type', activity_type,
                'amount', amount,
                'market_symbol', market_symbol,
                'side', side,
                'leverage', leverage,
                'activity_log_id', activity_id,
                'period_id', current_period_id,
                'bonus_type', bonus_type,
                'suspicion_score', suspicion_score
            )
        );
        
        -- Update period points distributed
        UPDATE points_allocation_periods 
        SET points_distributed = points_distributed + points_earned
        WHERE id = current_period_id;
    END IF;
    
    RETURN points_earned;
END;
$$ LANGUAGE plpgsql;

-- ==============================================
-- CRITICAL FIX 8: SYSTEM CONFIGURATION
-- ==============================================

-- Create system configuration table
CREATE TABLE IF NOT EXISTS system_config (
    config_key VARCHAR(100) PRIMARY KEY,
    config_value JSONB NOT NULL,
    description TEXT,
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Insert default configurations
INSERT INTO system_config (config_key, config_value, description) VALUES
('point_calculation_percentages', '{"trade": 0.01, "deposit": 0.02, "staking": 0.03, "insurance_fund": 0.05}', 'Base percentages for point calculation'),
('rate_limits', '{"max_activities_per_hour": 100, "max_activities_per_day": 1000}', 'Rate limiting configuration'),
('fraud_detection', '{"suspicious_multiplier": 10, "min_activity_amount": 1, "max_suspicion_score": 4.0}', 'Fraud detection thresholds'),
('multiplier_limits', '{"max_base_multiplier": 10, "max_bonus_multiplier": 10}', 'Maximum allowed multipliers')
ON CONFLICT (config_key) DO NOTHING;

-- ==============================================
-- CRITICAL FIX 9: ADDITIONAL INDEXES
-- ==============================================

-- Add additional performance indexes
CREATE INDEX IF NOT EXISTS idx_trading_activity_log_suspicion ON trading_activity_log(created_at DESC) WHERE points_earned > 0;
CREATE INDEX IF NOT EXISTS idx_points_allocation_periods_active ON points_allocation_periods(is_active, start_date);
CREATE INDEX IF NOT EXISTS idx_activity_multipliers_lookup ON activity_multipliers(period_id, activity_type);

-- ==============================================
-- CRITICAL FIX 10: COMMENTS AND DOCUMENTATION
-- ==============================================

-- Add comprehensive comments
COMMENT ON TABLE points_allocation_periods IS 'Points allocation periods with consumption tracking and validation';
COMMENT ON TABLE activity_multipliers IS 'Activity multipliers with validation constraints';
COMMENT ON TABLE user_rate_limits IS 'Rate limiting system to prevent abuse';
COMMENT ON TABLE fraud_detection_log IS 'Fraud detection and suspicious activity logging';
COMMENT ON TABLE system_config IS 'System configuration for flexible parameter management';

COMMENT ON FUNCTION is_active_user IS 'Properly detects active users based on recent activity';
COMMENT ON FUNCTION check_rate_limit IS 'Checks if user has exceeded rate limits';
COMMENT ON FUNCTION detect_suspicious_activity IS 'Detects and scores suspicious activity patterns';
COMMENT ON FUNCTION calculate_dynamic_points IS 'Enhanced points calculation with proper active user detection';
COMMENT ON FUNCTION process_trading_activity IS 'Enhanced activity processing with all security measures';

-- ==============================================
-- MIGRATION COMPLETION
-- ==============================================

-- Grant permissions (adjust as needed for your setup)
-- GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO quantdesk_user;
-- GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO quantdesk_user;

-- Migration completed successfully
SELECT 'QuantDesk Hybrid Points System - Critical Fixes migration completed successfully!' as status;
